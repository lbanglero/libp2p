{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEuC;AACJ;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4DAA+B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAiB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,kBAAkB,wFAAwF,IAAI;AAC9G;AACA;AACA;AACA,qCAAqC,4DAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAiB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,YAAY,IAAI,IAAI;AACtC;AACA;AACA;AACA;AACA,mDAAmD,4DAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAkB;AACjD;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA,iCAAiC,iDAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa,IAAI,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,wEAAwE,IAAI;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAiB;AAChC;AACA;AACA,kBAAkB,uBAAuB,IAAI,8CAAiB,8CAA8C;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sCAAsC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,KAAK,sBAAsB;AACpE;AACA;AACA;;AAEA;AACA,kBAAkB,kCAAkC,IAAI;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAA+B;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAsD,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,iBAAiB,WAAW,KAAK,kBAAkB;AACnD,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,uBAAuB,IAAI;AAC7C;AACA;AACA,gCAAgC,4DAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,uCAAuC,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY,eAAe,kBAAkB,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,8CAAiB,qCAAqC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,uDAAuD,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY,eAAe,kBAAkB,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB,IAAI,kEAAkE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAsB;AAC9C;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAAiB;AACrD;AACA;AACA;AACA,yCAAyC,8CAAiB,cAAc;AACxE;AACA,2BAA2B,4DAA+B,cAAc,8CAAiB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uBAAuB,IAAI,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,mDAAmD,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA,2BAA2B,+CAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sCAAsC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,2BAA2B,EAAE,QAAQ;AACrC;AACA,iCAAiC,EAAE,QAAQ,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,8BAA8B,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAA+B;AACzD;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA,2BAA2B,+CAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sCAAsC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA,gEAAgE,4DAA+B;AAC/F;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,4DAA+B;AACtE;AACA,oCAAoC,8CAAiB;AACrD;AACA;AACA,qEAAqE,GAAG;AACxE,oCAAoC,8CAAiB;AACrD;AACA;AACA;AACA,sDAAsD,8CAAiB;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,gCAAgC,8CAAiB;AACjD,uCAAuC,4DAA+B;AACtE;AACA;AACA;AACA,sDAAsD,8CAAiB;AACvE;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,+CAAkB;AAC9C;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,kBAAkB,kCAAkC,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4DAA+B;AACvF;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,IAAI,4BAA4B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,4CAA4C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C,6BAA6B,8CAAiB;AAC9C;AACA;AACA,iCAAiC,8CAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA,kBAAkB,yCAAyC,IAAI;AAC/D;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,4BAA4B,IAAI;AAClD;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kDAAkD,IAAI;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB,IAAI;AAC1C,wBAAwB,4DAA+B;AACvD;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAA+B;AACvD;AACA;AACA;AACA,wBAAwB,4DAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,8BAA8B,4DAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgiB;;;;;;;;;;;;ACvjGnhB;;AAEb;AACA,eAAe,sBAAsB;AACrC,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,mBAAmB;AAC9B,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,mBAAO,CAAC,6EAAkB;AACnD,qBAAqB;AACrB;AACA,iDAAiD,MAAM;AACvD;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB,kBAAe;;;;;;;;;;;;ACXF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uBAAuB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,wCAAwC,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAe;;;;;;;;;;;;ACxHF;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0DAA0D,OAAO;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA,gBAAgB,YAAY;AAC5B;;AAEA;AACA,4DAA4D;AAC5D,gEAAgE;AAChE,oEAAoE;AACpE,wEAAwE;AACxE;AACA,2DAA2D,SAAS;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAA6B;AACjC;AACA;;;;;;;;;;;AC/UA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpBa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACTa;AACb,uBAAuB,mBAAO,CAAC,0DAAc;;AAE7C,OAAO,gBAAgB;AACvB,OAAO,sBAAsB;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qFAAqF;AACrF,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,UAAU;AACpC;;AAEA;AACA;;;;;;;;;;;AC1KA,8HAA+C;;;;;;;;;;;ACA/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,YAAY;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ,IAA8B;;AAEtC,YAAY,KAA6B;AACzC;AACA;;AAEA,QAAQ,mBAAmB;;AAE3B,MAAM,KAAK,EAqBN;AACL,CAAC;;;;;;;;;;;ACpkBD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,EAAE,eAAe;;AAEjB,EAAE,eAAe;;AAEjB,EAAE,eAAe;;AAEjB,CAAC;;;;;;;;;;;;AC/MD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,EAAE,mBAAmB,EAAE,iBAAiB,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,eAAe;AACf,cAAc;AACd,eAAe;AACf,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9Yf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB,EAAE,sBAAsB;AAC3E;AACA;AACA;AACA,iCAAiC,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB;AACvG;AACA;AACA,iCAAiC,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB;AAC/H;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,sBAAsB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2R;;;;;;;;;;;;;;;;;;;;AClVhO;AAC3D;AACO;AACP,mBAAmB,oDAAS;AAC5B;AACA;AACO;AACP,mBAAmB,oDAAS;AAC5B;AACA;AACO;AACP,mBAAmB,kDAAO;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3BqC;AACrC;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClCA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxMO;AACA;AACA;AACP;;;;;;;;;;;;;;;ACHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVuC;AAChC,sBAAsB,gDAAY;AACzC;;;;;;;;;;;;;;;;;;;ACFyD;AACV;AACM;AACP;AACvC;AACP;AACA,eAAe,4DAAM;AACrB,KAAK;AACL;AACA,oBAAoB,2DAAO,CAAC,wDAAM;AAClC,2BAA2B,0DAAM,CAAC,wDAAM;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,yDAAM;AAChC,0BAA0B,yDAAM;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,yDAAM;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,yDAAM;AACrB,KAAK;AACL;AACA,eAAe,uEAAgB;AAC/B,KAAK;AACL;AACA,eAAe,uEAAgB;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;AC1CgC;AACyC;AAClE;AACP,mBAAmB,8DAAqB;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChBmC;AACW;AACvC,wBAAwB;AAC/B,+BAA+B,4CAAK;AACpC;AACA;;;;;;;;;;;;;;;;;;;;;ACLuE;AACpB;AAC5C;AACP,+BAA+B,4DAAiB;AAChD;AACA;AACA;AACA,6CAA6C,+DAAkB,qBAAqB;AACpF,8CAA8C,+DAAkB,sBAAsB;AACtF;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,4DAAiB;AAChD;AACA;AACA;AACA,gDAAgD,+DAAkB,qBAAqB;AACvF,iDAAiD,+DAAkB,sBAAsB;AACzF;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,4DAAiB;AAChD;AACA;AACA;AACA,8CAA8C,+DAAkB,uBAAuB;AACvF;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,4DAAiB;AAChD;AACA;AACA;AACA,iDAAiD,+DAAkB,uBAAuB;AAC1F;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,4DAAiB;AAChD;AACA;AACA,gCAAgC,mBAAmB,EAAE,SAAS,+DAAkB,eAAe;AAC/F,gCAAgC,mBAAmB,EAAE,SAAS,+DAAkB,eAAe;AAC/F;AACA;;;;;;;;;;;;;;;ACvDO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnB0D;AACmB;AAC5B;AACL;AACS;AACT;AACb;AAC8B;AACD;AACV;AACT;AACqB;AACf;AAC8C;AAC/B;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,gBAAgB,oDAAoD;AACpE,gBAAgB,UAAU;AAC1B;AACA,kCAAkC,2DAAa;AAC/C,sBAAsB,sDAAU;AAChC;AACA,iCAAiC,4DAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wDAAe;AACxD;AACA;AACA,KAAK,mEAAmB;AACxB;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D,kCAAkC,mEAAQ;AAC1C,2BAA2B,uDAAc;AACzC,2BAA2B,uDAAc;AACzC,2BAA2B,qEAA0B;AACrD,SAAS;AACT;AACA,sBAAsB,yDAAS;AAC/B;AACA,iCAAiC,yEAAmB;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAc;AAC5C;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D,kCAAkC,mEAAQ;AAC1C,2BAA2B,uDAAc;AACzC,2BAA2B,uDAAc;AACzC,2BAA2B,qEAA0B;AACrD,SAAS;AACT;AACA,sBAAsB,yDAAS;AAC/B;AACA,iCAAiC,yEAAmB;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAU;AACzC;AACA,cAAc,6CAAI;AAClB,QAAQ,6DAAa;AACrB;AACA,oBAAoB,0DAAM,WAAW,eAAe,uDAAc,EAAE;AACpE,QAAQ,6DAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1L6D;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCmI;AACzE;AACkB;AACrE;AACP,YAAY,kFAAkF;AAC9F,0BAA0B,iEAAsB;AAChD,mBAAmB,0DAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8DAAkB;AACtB;AACA,4CAA4C,iDAAO;AACnD;AACA,IAAI,iEAAqB;AACzB;AACA;AACA;AACA,IAAI,iEAAqB;AACzB,IAAI,8DAAkB;AACtB;AACA,kCAAkC,iEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAc;AAClB;AACA;AACA,kDAAkD,iDAAO;AACzD,wDAAwD,iDAAO;AAC/D;AACA;AACO;AACP,YAAY,kFAAkF;AAC9F,0BAA0B,iEAAsB;AAChD,mBAAmB,0DAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8DAAkB;AACtB;AACA;AACA;AACA,IAAI,iEAAqB;AACzB;AACA;AACA;AACA,IAAI,iEAAqB;AACzB;AACA;AACA;AACA,kCAAkC,iEAAsB;AACxD;AACA,IAAI,0DAAc;AAClB;AACA;AACA,kDAAkD,iDAAO;AACzD,wDAAwD,iDAAO;AAC/D;AACA;AACA;;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACwE;AACX;AACtD;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,wDAAe;AAChD,iCAAiC,wDAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,sDAAsD;AACvD;;;;;;;;;;;;;;;;;;;;;;;;ACtHgD;AACiB;AACJ;AACJ;AACtB;AACnC;AACA;AACO,gBAAgB,wDAAe;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,0DAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAc;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAA0B,uCAAuC,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAA0B,uCAAuC,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAA0B,uCAAuC,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChQgD;AACoD;AACtD;AAC9C;AACA;AACO;AACP;AACA;AACA,4BAA4B,kBAAkB,KAAK,iFAAsC;AACzF,8BAA8B,iFAAsC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAc,CAAC,2DAAc;AACvD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,4BAA4B,kBAAkB,KAAK,qEAA0B;AAC7E,8BAA8B,qEAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzDyD;AACzB;AACe;AACiB;AACa;AAC3B;AACS;AACpD;AACP;AACA,WAAW,oEAAqB;AAChC;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,wBAAwB,oEAAqB;AAC7C;AACA;AACA,iBAAiB,mDAAM;AACvB,wDAAwD,qDAAQ,8BAA8B,8CAA8C,qDAAQ,gCAAgC;AACpL;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAmB;AACrC;AACA;AACO;AACP,mBAAmB,mEAAoB;AACvC;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9C8D;AACX;AAC5C;AACP;AACA;AACA;AACA,mBAAmB,2CAAO;AAC1B,aAAa,iEAAS;AACtB;AACA,mBAAmB,2CAAO;AAC1B,aAAa,iEAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAM;AACvB;AACA;AACA;AACO;AACP,qBAAqB,2CAAO,iBAAiB,2CAAO;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC7CmC;AACI;AAC0B;AAC9B;AACG;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,4CAAK;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACfiD;AACJ;AACtC;AACA;AACA;AACA;AACP;AACA;AACO;AACP,4DAA4D,+CAAK;AACjE;AACA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,+DAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,mDAAS;AACpB;AACA;;;;;;;;;;;;;;;;;;;ACpDiD;AACD;AACH;AACuB;AAC7D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAyC,EAAE,mDAAS;AACnE;AACA;AACA,6BAA6B,+DAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAQ;AACpC;AACA,2BAA2B,8CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAU,GAAG,wCAAwC;AACpE;AACA;AACA;AACA,kBAAkB,0DAAgB;AAClC,4CAA4C,mDAAS;AACrD,eAAe,oDAAU;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpD2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,2CAAO;AACpB;AACA;AACA,aAAa,2CAAO;AACpB;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpF4C;AACS;AACb;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qEAAqE,mBAAmB;AACjG,iEAAiE,gBAAgB;AACjF,SAAS,8BAA8B;AACvC;AACO,kCAAkC;AACzC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAS;AAC5B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB,mEAAU;AACjC;AACA;AACA;AACA,wFAAwF,iBAAiB;AACzG;AACA,uCAAuC,0CAA0C;AACjF,qGAAqG,gBAAgB;AACrH,uGAAuG,oCAAoC;AAC3I;AACA;AACA,4FAA4F,iBAAiB;AAC7G;AACA;AACA;AACA;AACA,mCAAmC,0CAA0C;AAC7E,4EAA4E,gBAAgB;AAC5F,8EAA8E,oCAAoC;AAClH;AACA;AACA;AACA,eAAe,0DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB,mEAAU;AACjC;AACA;AACA;AACA;AACA,uCAAuC,0CAA0C;AACjF,qGAAqG,gBAAgB;AACrH,uGAAuG,oCAAoC;AAC3I;AACA;AACA,4FAA4F,iBAAiB;AAC7G;AACA;AACA;AACA;AACA,mCAAmC,0CAA0C;AAC7E,4EAA4E,gBAAgB;AAC5F,8EAA8E,oCAAoC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClGwC;AACL;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAS,qBAAqB,cAAc;AAClE;AACA;AACO;AACP;AACA,sBAAsB,qDAAS;AAC/B;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,gBAAgB,mDAAO;AACvB;AACA;AACA;;;;;;;;;;;;;;;ACxBA,iEAAe;AACf;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;;;;ACL8C;AACkB;AACA;AACO;AACxB;AACP;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,wDAAS,mBAAmB,MAAM,YAAY,MAAM;AACtE;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,qDAAS;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,qDAAS;AACnC;AACA;AACA,SAAS;AACT,6BAA6B,qDAAS;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,qDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA,kBAAkB,wDAAS,mBAAmB,QAAQ,YAAY,MAAM;AACxE;AACA;AACA,WAAW,0DAAgB;AAC3B;AACA,QAAQ,2DAAiB;AACzB,QAAQ,2DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS,mBAAmB,MAAM,YAAY,MAAM;AACtE;AACA;AACA,SAAS,0DAAgB;AACzB,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,OAAO,+DAAkB;AACzB,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;AC/FsD;AACtD;AACA,oCAAoC;AACpC;AACqD;AACE;AAChD;AACP;AACA,0BAA0B,0DAAE;AAC5B,sBAAsB,0DAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,0DAAE;AACb;AACO;AACP,WAAW,0DAAE;AACb;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnD8C;AACQ;AACE;AACN;AACc;AACzB;AACA;AACE;AACR;AAC1B;AACP;AACA;AACA,mCAAmC,wDAAsB;AACzD;AACA;AACA,eAAe,sDAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAa;AAC5B,kBAAkB,6CAAW;AAC7B;AACA,SAAS;AACT;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,kBAAkB,4DAAM;AACxB,YAAY,mDAAS;AACrB,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAuB;AAC1D,+CAA+C,wDAAsB;AACrE;AACA;AACA,eAAe,oDAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAc;AAC7B,kBAAkB,6CAAW;AAC7B;AACA,SAAS;AACT;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,kBAAkB,4DAAM;AACxB;AACA,YAAY,mDAAS;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,yBAAyB,kEAAQ;AACjC,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAQ;AAC3B;AACA;AACA,sBAAsB,wDAAS,mBAAmB,OAAO;AACzD;AACA;AACA;AACO;AACP;AACA,uBAAuB,yDAAuB;AAC9C,iCAAiC,yDAAuB,GAAG,wDAAsB;AACjF,kDAAkD,yDAAuB;AACzE,8CAA8C,yDAAuB;AACrE;AACA;AACA,6BAA6B,yDAAuB;AACpD,8CAA8C,yDAAuB;AACrE,0CAA0C,wDAAsB;AAChE;AACA;AACO;AACP,6BAA6B,wDAAsB;AACnD;AACA;AACO;AACP,YAAY,wBAAwB,EAAE,oDAAkB;AACxD;AACA;AACO;AACP,YAAY,wBAAwB,EAAE,4DAA0B;AAChE;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS,uCAAuC,OAAO,QAAQ,WAAW;AAC5F;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpIoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,6DAAuB,EAAC;AACvC;;;;;;;;;;;;;;;;;ACRmD;AACF;AACjD;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,uDAAc;AACjC;AACA,WAAW,6DAAM;AACjB;AACA;;;;;;;;;;;;;;;;;ACZmD;AACF;AACjD;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,6DAAM;AAC/B,mBAAmB,uDAAc;AACjC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA,QAAQ,sBAAsB,GAAG,uBAAuB,OAAO,yBAAyB;AACxF;AACA;AACA;AACA;AACA;AAC8C;AACA;AACa;AAClB;AACS;AACb;AACC;AACS;AACG;AAC1B;AACY;AACjB;AAC4D;AACN;AACM;AACxE;AACP,SAAS,0CAAG;AACZ,aAAa,8CAAO;AACpB,eAAe,gDAAS;AACxB;AACA;AACA;AACA,eAAe,wDAAS,oCAAoC,KAAK,YAAY,UAAU;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,wDAAS;AAC3B;AACA,WAAW,sEAA+B;AAC1C;AACA;AACA;AACA;AACO;AACP,oBAAoB,+CAAiB;AACrC;AACA;AACA,aAAa,6CAAe;AAC5B;AACA,aAAa,6CAAe;AAC5B;AACA,aAAa,6CAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,gDAAkB;AACtC;AACA;AACA,aAAa,6CAAe;AAC5B;AACA,aAAa,6CAAe;AAC5B;AACA,aAAa,6CAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,sDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,WAAW,4DAAa;AACxB;AACA;;;;;;;;;;;;;;;;;;;AC/H8C;AACkB;AACa;AACpC;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,wDAAS,yBAAyB,WAAW,aAAa,QAAQ;AACpF;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA,iBAAiB,mEAAoB;AACrC;AACA,oBAAoB,kDAAW;AAC/B;AACA;AACA;AACA;AACA,iCAAiC,0DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACqF;AAC9E;AACP;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,eAAe,4DAAW;AAC1B;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,gCAAgC;AACjC;;;;;;;;;;;;;;;;;;;;;;;;;;ACzH8C;AAC+B;AAChC;AACL;AACA;AACvB;AACV;AACP,uBAAuB,qDAAS;AAChC;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,qDAAS;AACtC;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AAC0C;AACnC;AACP,6BAA6B,qDAAS;AACtC;AACA,gBAAgB;AAChB,KAAK;AACL,sBAAsB,qDAAS,qBAAqB,2BAA2B;AAC/E;AACA;AACO;AACP,4BAA4B,qDAAS;AACrC;AACA,gBAAgB;AAChB,KAAK;AACL,WAAW,qDAAS,uBAAuB,2BAA2B;AACtE;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA,QAAQ,qDAAS;AACjB,QAAQ,qDAAS;AACjB;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACO;AACP;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,kBAAkB,mEAAoB;AACtC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnF8C;AACI;AACc;AACO;AAChC;AACE;AACR;AACE;AAC5B;AACA;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAoB;AACnC;AACA;AACA,eAAe,8CAAsB;AACrC;AACA;AACA,eAAe,+CAAa;AAC5B,kBAAkB,6CAAW;AAC7B;AACA,SAAS;AACT;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,kBAAkB,4DAAM;AACxB,YAAY,mDAAS;AACrB,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAsB;AACrC;AACA;AACA,eAAe,gDAAkB;AACjC;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA,eAAe,+CAAuB;AACtC;AACA;AACA,eAAe,gDAAc;AAC7B,kBAAkB,6CAAW;AAC7B;AACA,SAAS;AACT;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,kBAAkB,4DAAM;AACxB,YAAY,mDAAS;AACrB,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAwB;AAC3C;AACA;AACA,mBAAmB,sDAAQ;AAC3B;AACA;AACA,sBAAsB,wDAAS,mBAAmB,OAAO;AACzD;AACA;AACA;AACO;AACP,gBAAgB,+CAAuB;AACvC,QAAQ,4CAAc;AACtB,kBAAkB,wDAAS;AAC3B;AACA,uBAAuB,wDAA0B;AACjD;AACA;AACO;AACP,gBAAgB,8CAAsB;AACtC,QAAQ,4CAAc;AACtB,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACO;AACP,QAAQ,4CAAc;AACtB,kBAAkB,wDAAS;AAC3B;AACA,uBAAuB,wDAA0B;AACjD;AACA;AACO;AACP;AACA,kBAAkB,wDAAS;AAC3B;AACA,uBAAuB,gDAAkB;AACzC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtI8C;AACK;AACL;AACb;AAC4C;AACN;AAC1B;AACL;AACgB;AACxD;AACA;AACA;AACO;AACP,YAAY,SAAS,EAAE,2CAAc;AACrC;AACA;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B,YAAY,+DAAkB;AAC9B,YAAY,+DAAkB;AAC9B,YAAY,+DAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,wDAAS;AAC3B;AACA,qBAAqB,4CAAe;AACpC;AACA,gBAAgB,2CAAc,GAAG,UAAU;AAC3C,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE,YAAY,2CAAc,oBAAoB,mEAAoB;AAClE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,SAAS,EAAE,2CAAc;AACrC;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B,WAAW,+DAAkB;AAC7B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,wDAAS;AAC3B;AACA,qBAAqB,4CAAe;AACpC;AACA,gBAAgB,4CAAe;AAC/B;AACA;AACA,wBAAwB,oDAAuB;AAC/C;AACA,qBAAqB;AACrB,wBAAwB,wCAAW;AACnC;AACA,aAAa;AACb;AACA;AACA,gBAAgB,6CAAgB;AAChC,8BAA8B,4CAAe;AAC7C;AACA,wBAAwB,2CAAc,oBAAoB,mEAAoB;AAC9E,wBAAwB,2CAAc,oBAAoB,mEAAoB;AAC9E;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,qDAAS;AAC5B;AACA,2BAA2B,4CAAe;AAC1C;AACA;AACA,gBAAgB,2CAAc,GAAG,UAAU;AAC3C;AACA,gBAAgB,4CAAe;AAC/B;AACA;AACA,wBAAwB,oDAAuB;AAC/C;AACA,qBAAqB;AACrB,wBAAwB,wCAAW;AACnC;AACA,aAAa;AACb;AACA,gBAAgB,+CAAkB;AAClC;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,iBAAiB,4DAAW;AAC5B,gCAAgC,iEAAW,CAAC,wDAAM;AAClD;AACA;AACA,KAAK;AACL,eAAe,4DAAW;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL,6BAA6B,4CAAe;AAC5C;AACA;AACA,gBAAgB,+CAAkB,GAAG,gBAAgB;AACrD;AACA,gBAAgB,2CAAc,GAAG,mBAAmB;AACpD;AACA,gBAAgB,2CAAc,GAAG,iBAAiB;AAClD;AACA,gBAAgB,4CAAe;AAC/B;AACA;AACA,wBAAwB,oDAAuB,GAAG,8BAA8B;AAChF,wBAAwB,wCAAW;AACnC;AACA,aAAa;AACb;AACA,KAAK;AACL,oCAAoC,4CAAe;AACnD;AACA;AACA,gBAAgB,oDAAuB;AACvC;AACA,aAAa;AACb,gBAAgB,4CAAe;AAC/B;AACA;AACA,wBAAwB,4CAAe;AACvC;AACA;AACA,gCAAgC,oDAAuB;AACvD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,4CAAe;AACvC;AACA;AACA,gCAAgC,oDAAuB;AACvD;AACA,6BAA6B;AAC7B;AACA,gCAAgC,+CAAkB;AAClD;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL,6BAA6B,4CAAe;AAC5C;AACA;AACA,gBAAgB,+CAAkB,GAAG,qBAAqB;AAC1D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,+DAAkB,yCAAyC,GAAG;AACzE;AACA;AACA;AACO;AACP,mBAAmB,qDAAS;AAC5B;AACA;AACA,oBAAoB,mEAAoB;AACxC;AACA;AACA;AACA;AACA,gBAAgB,SAAS,EAAE,2CAAc;AACzC,gBAAgB,4CAA4C;AAC5D,oCAAoC,iEAAW,CAAC,wDAAM;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,0BAA0B,EAAE,2CAAc;AAC1D;AACA;AACA;AACA,oBAAoB,mEAAoB;AACxC;AACA;AACA;AACA;AACA,gBAAgB,SAAS,EAAE,2CAAc;AACzC;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,WAAW,qEAAsB;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzU8C;AACc;AACV;AACX;AACvC;AACuD;AAChD;AACP,WAAW,8DAAI;AACf;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAM;AACpB,QAAQ,mDAAS;AACjB,yBAAyB,QAAQ,KAAK,8DAAI;AAC1C;AACA,sBAAsB,wDAAS;AAC/B,SAAS;AACT;AACA;AACA,eAAe,8DAAI;AACnB;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAM;AACpB,QAAQ,mDAAS;AACjB,yBAAyB,QAAQ,KAAK,8DAAI;AAC1C;AACA,sBAAsB,wDAAS;AAC/B,SAAS;AACT;AACA;AACA,eAAe,8DAAI;AACnB;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACO;AACP,kBAAkB,8DAAI;AACtB;AACA;AACO;AACP,kBAAkB,8DAAI;AACtB;AACA;AACO;AACP;AACA,QAAQ,8DAAI;AACZ;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACO;AACP;AACA,QAAQ,8DAAI;AACZ;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACO;AACP;AACA,eAAe,8DAAI;AACnB;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7E8C;AACI;AACc;AACO;AAChC;AACE;AACC;AACD;AAClC;AACP;AACA;AACA,QAAQ,4DAAwB;AAChC;AACA;AACA;AACA,eAAe,wDAAoB;AACnC;AACA;AACA,eAAe,4DAAwB;AACvC;AACA;AACA,eAAe,+CAAsB;AACrC,kBAAkB,6CAAoB;AACtC;AACA,SAAS;AACT;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,kBAAkB,4DAAM;AACxB;AACA,YAAY,mDAAS;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uCAAuC,2DAAuB;AAC9D,QAAQ,6DAAyB;AACjC,QAAQ,4DAAwB;AAChC;AACA;AACA,eAAe,sDAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAuB;AACtC,kBAAkB,6CAAoB;AACtC;AACA,SAAS;AACT;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA,kBAAkB,4DAAM;AACxB,YAAY,mDAAS;AACrB,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAQ;AAC3B;AACA;AACA,sBAAsB,wDAAS,mBAAmB,OAAO;AACzD;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP,4BAA4B,sDAAkB;AAC9C;AACA;AACA;;;;;;;;;;;;;;;;;AC5G8C;AACa;AAC3D;AACA;AACA;AACe;AACf;AACA,kBAAkB,wDAAS;AAC3B;AACA,WAAW,gEAAK;AAChB;AACA;;;;;;;;;;;;;;;;;;ACXgE;AACa;AACtE;AACP,cAAc,mEAAoB;AAClC;AACA;AACA;AACA,cAAc,0DAAgB;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,gCAAgC;AAC7I;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;;;;;;;AChBO,uCAAuC;AACvC,8CAA8C;AAC9C,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACyE;AACR;AACb;AACvB;AACM;AACW;AAC+B;AACN;AACyC;AAClD;AACuB;AAC9E,2BAA2B,uDAAgB;AAClD;AACA;AACA,qCAAqC;AACrC;AACA;AACA,0BAA0B,uBAAuB,oDAAa,gBAAgB,GAAG,8EAAsC,CAAC,GAAG,iFAAyC,CAAC;AACrK;AACA,SAAS;AACT;AACA,+CAA+C,oDAAa;AAC5D,qCAAqC,oDAAa;AAClD;AACA;AACA,gDAAgD,sBAAsB;AACtE,aAAa;AACb;AACA;AACA,KAAK,kEAAmB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,kEAAS;AACzG,+BAA+B,2DAAU;AACzC;AACA;AACA,SAAS;AACT,uCAAuC,gEAAc;AACrD;AACA;AACA,6BAA6B,+DAAkB,sCAAsC,mEAAoB;AACzG,gCAAgC,+DAAkB,yCAAyC,mEAAoB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAe;AACnC;AACA;AACA;AACA;AACA,yBAAyB;AACzB,mCAAmC,4DAAQ;AAC3C;AACA,yBAAyB,KAAK,qDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAK,CAAC,uDAAQ;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAQ;AAC/B;AACA,aAAa,KAAK,qDAAe;AACjC;AACA;AACA,kBAAkB,iEAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1HA;AACoF;AACnC;AACgB;AACb;AACW;AACjB;AACwD;AACxC;AAC0C;AACjG,uBAAuB,uDAAgB;AAC9C,qCAAqC;AACrC;AACA;AACA,0BAA0B,uBAAuB,oDAAa,gBAAgB,GAAG,yEAAiC,CAAC,GAAG,4EAAoC,CAAC;AAC3J;AACA,SAAS;AACT,wCAAwC,oDAAa;AACrD;AACA;AACA;AACA,yDAAyD,0EAA0E;AACnI,aAAa;AACb;AACA;AACA,KAAK,kEAAmB;AACxB;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB,4DAAQ;AAC/B;AACA,aAAa,KAAK,oDAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,gBAAgB,qCAAqC;AACrD;AACA,sBAAsB,wDAAS;AAC/B;AACA,yBAAyB,+DAAc;AACvC;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,kCAAkC,4DAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA,QAAQ,kEAAe;AACvB;AACA;AACA;AACA,+FAA+F,kEAAS;AACxG;AACA;AACA,uCAAuC,4DAAU;AACjD;AACA;AACA,iBAAiB;AACjB,uCAAuC,gEAAc;AACrD;AACA;AACA;AACA,iBAAiB,yEAAY;AAC7B;AACA;AACA,uBAAuB,4DAAQ,YAAY,oDAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACuE;AACb;AACnD,2BAA2B;AAClC,+BAA+B,kDAAa;AAC5C;AACO,+BAA+B;AACtC,+BAA+B,2DAAiB;AAChD;AACA;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACwE;AACjE;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjG8C;AACG;AACgB;AACb;AACyB;AACkC;AACN;AAClG;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAyB;AAC7C;AACA;AACA;AACA,iBAAiB,4DAAoB;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,kEAAS;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sBAAsB,cAAc,GAAG,iBAAiB;AACxD;AACA,QAAQ,8CAAM,IAAI,sDAAc;AAChC,sCAAsC,2BAA2B;AACjE;AACA,aAAa,iDAAS,IAAI,mDAAW,IAAI,0DAAkB,IAAI,qDAAa;AAC5E,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAS;AAChC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAc;AAC3C;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAc,oCAAoC,2DAAU;AAC3F,yBAAyB,2DAAU;AACnC;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAc;AAC3D,qCAAqC,2DAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAoB;AACxD;AACA;AACA,uCAAuC,mEAAoB;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kEAAS;AAC7D,iEAAiE,kEAAS;AAC1E;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAoD,GAAG,iEAAyB,CAAC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAoB;AAClD,iCAAiC,mEAAoB;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxNO;AACA;AACP;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACP;;;;;;;;;;;;;;;;;ACrE8C;AAC9C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;ACxDA;AACO;AACP;;;;;;;;;;;;;;;;ACFgE;AAChE;AACO;AACP;AACA,QAAQ,uDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AAC+B;AACU;AACJ;AACD;AACX;AACG;AACO;AACP;AACE;AACG;AACF;AACD;AACH;AACA;AACQ;AACF;AACJ;AACC;AACT;AACM;AACN;AACG;AAC/B;;;;;;;;;;;;;;;;;ACrDO;AACA;AACA;AACP;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;ACpBO;AACA;AACP;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;ACpBO;AACP;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;;;;;;;;;;;;;;;;;ACnCO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AC7CO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnC8C;AACA;AACrB;AACU;AACJ;AACiC;AACxB;AACQ;AACiB;AACb;AACG;AACU;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAuE;AACvF;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA,oBAAoB,wDAAY;AAChC,cAAc,mEAAY;AAC1B;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,yBAAyB,0DAAe;AACxC,qBAAqB,cAAc;AACnC;AACA,gBAAgB,0DAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAiB;AACnD,iEAAiE,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA,gFAAgF,0DAAgB,qBAAqB,wDAAY;AACjI;AACA;AACA;AACA;AACA;AACA,sBAAsB,iEAAe,GAAG,iBAAiB,wDAAS,sDAAsD;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,uBAAuB,0DAAe;AACtC;AACA,sBAAsB,4DAAiB;AACvC,2CAA2C,iBAAiB;AAC5D;AACA;AACA,eAAe,6CAAI,yCAAyC,wBAAwB,eAAe,kDAAG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0DAAgB,wBAAwB,wDAAY;AACzG,oCAAoC,iEAAe,GAAG,gCAAgC,wDAAS,sDAAsD;AACrJ;AACA;AACA;AACA;AACA,SAAS,eAAe,uDAAQ;AAChC;AACA,yBAAyB,iDAAK;AAC9B,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,kBAAkB,4DAAU;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,iDAAiD,cAAc;AAC/D,oFAAoF,QAAQ;AAC5F;AACA;AACA,0BAA0B,4DAAU,GAAG,uCAAuC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjMmD;AAC1B;AACU;AACJ;AACS;AACQ;AACG;AACoC;AAChF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAyE;AACzF;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA,gBAAgB,+DAAY;AAC5B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAe,GAAG,iCAAiC;AACnF;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAI,gEAAgE,kDAAG,yDAAyD,uDAAQ;AACvJ;AACA,yBAAyB,gDAAK;AAC9B,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mEAAiB,GAAG,2CAA2C,wDAAW,2BAA2B;AACvH,kBAAkB,+DAAa,GAAG,yCAAyC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8BAA8B,6DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAa,GAAG,2CAA2C;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,eAAe;AAC3B,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAuC;AACnD,YAAY,eAAe;AAC3B,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD,YAAY,eAAe;AAC3B,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACN;AAC2D;AAClD;AACgC;AACxF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACuB;AACvB;AACA;AACA;AACA;AACO,yBAAyB;AAChC,+BAA+B,+CAAW;AAC1C;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GmM;AACtK;AACA;AACa;AACoB;AACsB;AAC7C;AACoC;AAChC;AACO;AACN;AACyB;AACG;AAChB;AACS;AAC5B;AACqB;AACmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,cAAc,oDAAK;AACnB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACO,qBAAqB,gEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,gBAAgB,wLAAwL;AACxM;AACA;AACA;AACA;AACA,oCAAoC,mDAAQ;AAC5C;AACA;AACA;AACA;AACA,qDAAqD,mEAA4B;AACjF,gCAAgC,iEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,oDAAS,gCAAgC;AACtE;AACA,eAAe,6DAAgB;AAC/B;AACA;AACA;AACA,eAAe,2DAAe;AAC9B;AACA;AACA,2BAA2B,gDAAO;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,oDAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,gEAAiB;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC,wEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kCAAkC,sEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uCAAuC,2EAAmB;AAC1D;AACA;AACA;AACA,SAAS;AACT,uBAAuB,+CAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oCAAoC,oEAAgB;AACpD;AACA;AACA,SAAS;AACT,6BAA6B,sDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,0DAAW;AAC9C;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,KAAK,4DAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,KAAK,mEAAmB;AACxB;AACA;AACA;AACA;AACA,KAAK,mEAAmB;AACxB;AACA;AACA,SAAS,oEAAoB;AAC7B;AACA;AACA,SAAS,iEAAiB;AAC1B;AACA;AACA,SAAS,mEAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAI;AAClB;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtXA;AACA;AACA;AACA;AACA;AACqF;AACxB;AACtD;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,wBAAwB;AAClB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA,eAAe,4DAAW;AAC1B;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA,eAAe,4DAAW;AAC1B;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wBAAwB,wDAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,0BAA0B;AAC3B;;;;;;;;;;;;;;;;;;AC1RkD;AACE;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,gEAAe;AAC3B,uDAAuD,kEAAS;AAChE;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnBsD;AACR;AACmB;AACnB;AACF;AACD;AACS;AACkD;AACtG;AACA;AACA;AACO,sBAAsB,gEAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,qDAAqD,eAAe;AACpE;AACA;AACA,2BAA2B,2EAAe;AAC1C,kCAAkC;AAClC;AACA,2BAA2B,oCAAoC;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAS;AAC/B;AACA;AACA,cAAc,+DAAa,GAAG,UAAU;AACxC,cAAc,gEAAc,GAAG,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,kBAAkB,mEAAiB;AACnC;AACA;AACA,4CAA4C,6DAAc;AAC1D,kDAAkD,6DAAc;AAChE,8DAA8D,wDAAY;AAC1E,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,iEAAe,GAAG,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAS;AAC/B;AACA;AACA,cAAc,+DAAa,GAAG,UAAU;AACxC,cAAc,gEAAc,GAAG,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,kBAAkB,mEAAiB,GAAG,6BAA6B;AACnE;AACA;AACA;AACA,kBAAkB,iEAAe,GAAG,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAQ;AAC3B,4BAA4B,oDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAQ;AAC3B,4BAA4B,oDAAO;AACnC,sCAAsC,oDAAO;AAC7C;AACA;AACA;AACA;AACA,wBAAwB,iEAAc;AACtC,aAAa;AACb,SAAS;AACT;AACA;AACA,wBAAwB,iEAAc;AACtC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3KuD;AACsB;AACjC;AAC5C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAa;AACnC;AACA;AACA,0CAA0C,mEAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAa;AAC1C,0BAA0B,oDAAa;AACvC;AACA,eAAe,mEAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/EsC;AACQ;AACG;AACH;AACyB;AACvB;AACsB;AACW;AAC1B;AAClB;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAA6D;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,sBAAsB,sDAAqB;AAC3C;AACA;AACA;AACA,sCAAsC,+DAAc,CAAC,4DAAqB,GAAG,2BAA2B;AACxG;AACA;AACA,8BAA8B,wDAAS;AACvC;AACA;AACA,8BAA8B,wDAAS;AACvC;AACA,sBAAsB,4DAAU,GAAG,sCAAsC;AACzE;AACA;AACA,kBAAkB,wDAAS,6CAA6C,gBAAgB;AACxF;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAc;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qDAAqD,cAAc;AACnE;AACA,0BAA0B,wDAAW;AACrC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAc,GAAG,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAe,GAAG,8BAA8B,wDAAS,gCAAgC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,4BAA4B,oDAAmB;AAC/C;AACA,2BAA2B;AAC3B,0BAA0B,8EAAgB;AAC1C,2DAA2D,kBAAkB,0BAA0B,IAAI;AAC3G,uDAAuD,cAAc;AACrE,qDAAqD,+DAAkB;AACvE;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAc;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAe,GAAG,6BAA6B,wDAAS,gCAAgC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA,cAAc,mEAAY,sBAAsB,wDAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9PmD;AACvB;AACkB;AAClB;AACW;AACgC;AACwD;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,gBAAgB,8CAA8C;AAC9D;AACA;AACA,kDAAkD,qEAA0B;AAC5E,kDAAkD,6DAAkB;AACpE,qBAAqB,oCAAK,cAAc,mEAAwB;AAChE,6BAA6B,+CAAK,GAAG,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ,8DAAmB,EAAE;AAC9E;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAgB;AACvC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+DAAkB;AACrE,cAAc,8DAAmB,CAAC,GAAG,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAG;AACvB,mBAAmB,gDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAa;AACjC;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3NoD;AACb;AACR;AACA;AACJ;AACE;AACI;AACwE;AACzG;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAsE;AACtF;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA,8BAA8B,4CAAC;AAC/B,oCAAoC,8DAAmB;AACvD,uDAAuD,sEAA2B;AAClF,4CAA4C,6DAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAM;AACtC;AACA;AACA;AACA,2BAA2B,qDAAS;AACpC;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA;AACA,0BAA0B,+CAAM;AAChC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oCAAoC,6CAAI;AACxC;AACA;AACA,iBAAiB,eAAe,mDAAI,wCAAwC,qDAAM;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvHgD;AACzC,4CAA4C;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,+BAA+B,eAAe;AACtF;AACA;AACO,+CAA+C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,kCAAkC,eAAe;AACzF;AACA;AACO,4CAA4C;AACnD;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,+BAA+B,eAAe;AACtF;AACA;AACO,6CAA6C;AACpD;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,gCAAgC,eAAe;AACvF;AACA;AACO,2CAA2C;AAClD;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,6BAA6B,eAAe;AACpF;AACA;AACO,wCAAwC;AAC/C;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,0BAA0B,eAAe;AACjF;AACA;AACO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,6BAA6B,eAAe;AACpF;AACA;AACO,2CAA2C;AAClD;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW,8BAA8B,eAAe;AACrF;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9EoD;AACD;AACZ;AACV;AACY;AAC8B;AACL;AACtB;AACA;AAC5C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB,4CAAC,UAAU,gDAAK,cAAc;AAC9D;AACA,8CAA8C,4CAAC;AAC/C;AACA,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,+BAA+B;AACpG,gEAAgE,+BAA+B;AAC/F;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gEAAqB;AACpE;AACA;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB,gDAAgD,eAAe,WAAW,+DAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAU;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAO;AACzC;AACA;AACA,uBAAuB,yDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,sCAAsC,oDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChL+D;AACnB;AACL;AACgB;AACsB;AAClB;AACb;AAC9C;AACA;AACA;AACA;AACO;AACP,YAAY,+HAA+H;AAC3I;AACA;AACA,sBAAsB,sDAAK;AAC3B;AACA,wBAAwB,mEAAoB;AAC5C,KAAK;AACL;AACA,wBAAwB,wDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAa;AACrC;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAS;AAC5C;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,gGAAgG;AAChG;AACA;AACA;AACA,0DAA0D,wDAAa;AACvE,kDAAkD,oDAAa;AAC/D;AACA,gCAAgC,mEAAoB,mCAAmC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,2BAA2B,2DAAe;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,kCAAkC,wDAAa;AAC/C;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnH8C;AACyB;AACvE;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,iBAAiB,+DAAkB;AACnC;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA,wEAAwE,SAAS;AACjF,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrC8C;AACI;AACc;AACO;AACvE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,+DAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS;AACxE,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,mBAAmB,+DAAkB;AACrC;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA,gCAAgC,4DAAM;AACtC,SAAS,0DAAgB;AACzB,kBAAkB,wDAAS;AAC3B;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACrDA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClgCiE;AACd;AACE;AACP;AACW;AACpB;AACiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACO,2BAA2B,gEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAS;AACtC;AACA,2BAA2B,oCAAoC;AAC/D;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,4EAA4E,oCAAoC;AAChH,sFAAsF,oCAAoC;AAC1H,iGAAiG,oCAAoC;AACrI,yFAAyF,oCAAoC;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAO;AACjC;AACA,6BAA6B,oDAAmB;AAChD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC,oDAAmB;AACpD,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAO;AAClC,+BAA+B,+CAAc;AAC7C,mCAAmC,6DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,iDAAiD,2BAA2B;AAC5E,SAAS;AACT;AACA;AACA,oDAAoD,2BAA2B;AAC/E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAQ;AACvC;AACA,8BAA8B,wDAAW;AACzC,qBAAqB,EAAE,oDAAO;AAC9B,mDAAmD,oDAAO;AAC1D;AACA,0CAA0C,wDAAW;AACrD,kCAAkC,wDAAS,uDAAuD,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAmB;AAC/C,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1SsD;AAC7B;AAC8C;AAChB;AACe;AAC5B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB,gEAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,kCAAkC;AACnD;AACA;AACA,yBAAyB,8EAAgB;AACzC;AACA,+BAA+B,iCAAiC;AAChE;AACA,eAAe,kDAAG;AAClB;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,gBAAgB,YAAY;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA,6BAA6B,+DAAkB,CAAC,oDAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,YAAY;AAC7B;AACA;AACA,0BAA0B,+DAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpQ6C;AACO;AACF;AACnB;AACmB;AACK;AAC+B;AAC1B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAA6E;AAC7F,qDAAqD,UAAU;AAC/D;AACA;AACA,kDAAkD,iEAAsB;AACxE,0DAA0D,sEAA2B;AACrF;AACA;AACA;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D,mCAAmC,wDAAwD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB,4BAA4B,qDAAM;AAClC;AACA,SAAS;AACT,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAW;AACtC;AACA;AACA,eAAe,gEAAe;AAC9B;AACA;AACA;AACA,6FAA6F,yBAAyB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAkB;AAC5C;AACA;AACA,4BAA4B,4DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,6BAA6B,oDAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/M8C;AACI;AACE;AACb;AAChC;AACP;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,iDAAG;AACrB;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,kEAAS;AAC9G,kDAAkD,gEAAe;AACjE,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3C8C;AACM;AACK;AACN;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,YAAY,mDAAgB;AAC5B;AACA;AACA,4FAA4F,kEAAS;AACrG,aAAa;AACb;AACA;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnD8C;AACP;AACY;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA,kBAAkB,iDAAG;AACrB;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI;AACnE;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClF8C;AACA;AACM;AACD;AACkC;AAC9E;AACP;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAc;AAC1B;AACA,8BAA8B,2DAAgB;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,wDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAY;AACnC;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA,yDAAyD,yDAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxGO;AACP;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACV8C;AACA;AACY;AACP;AAC5C;AACP;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB;AACnE;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,uCAAuC,wDAAY;AACnD,kBAAkB,mEAAY;AAC9B;AACA,8BAA8B,4DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACpCyC;AACV;AAC0B;AACO;AACN;AACQ;AACR;AACT;AACS;AACnD;AACP;AACA;AACA;AACA;AACA,gBAAgB,gEAAgE;AAChF,qDAAqD,UAAU;AAC/D;AACA;AACA,aAAa,wDAAW,4BAA4B,mEAAe,eAAe,wBAAwB;AAC1G,aAAa,wDAAW,4BAA4B,mEAAe,eAAe,uBAAuB;AACzG,aAAa,wDAAW,4BAA4B,mEAAe,eAAe,wCAAwC;AAC1H,aAAa,wDAAW,+BAA+B,yEAAkB,eAAe,sBAAsB;AAC9G,aAAa,wDAAW,gCAAgC,2EAAmB,eAAe,mDAAmD;AAC7I,aAAa,wDAAW,uBAAuB,0DAAW,eAAe,WAAW;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,kBAAkB,6CAAI,qBAAqB,sDAAS;AACpD;AACA;AACA,uCAAuC,oDAAO;AAC9C;AACA;AACA;AACA;AACA,8BAA8B,oDAAO;AACrC;AACA;AACA,aAAa,cAAc,sDAAS;AACpC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;AC5EmE;AACnE;AACA;AACA;AACO,+BAA+B,gEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAW;AAClD;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDkD;AACJ;AACS;AACT;AACI;AACc;AACa;AACN;AACpB;AACnD;AACA,kBAAkB,mEAAoB;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAW;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAW;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,4DAAM;AAClC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,eAAe,wDAAG,OAAO,+DAAkB;AAC3C;AACA;AACA;AACA;AACO;AACP,eAAe,wDAAG,IAAI,4DAAiB,CAAC,GAAG,+DAAkB,gBAAgB;AAC7E;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA;AACO;AACP,WAAW,+DAAkB;AAC7B;AACO;AACP,WAAW,+DAAkB;AAC7B;AACO;AACP,WAAW,gEAAe;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,wDAAY;AAChC;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAW,IAAI,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtJiC;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS,6BAA6B;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,GAAG,WAAW;AAClB;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,kBAAkB,qDAAQ,eAAe,8BAA8B;AACvE;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,QAAQ,6BAA6B;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU,SAAS;;AAEnB,YAAY,mBAAmB;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,SAAS;AACnB,YAAY,6BAA6B;AACzC;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,SAAS;AACnB,YAAY,kBAAkB;AAC9B,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,GAAG,WAAW;AACjB;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB;AACpC,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEuC;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7SvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACG;AACH;AACzB;AACkB;AAC5C;AACA,6CAAK;AACL,qCAAqC,gEAAS;AAC9C;AACA;AACA,6CAAK;AACL,qCAAqC,6DAAM;AAC3C;AACA;AACA,6CAAK;AACL,qCAAqC,6DAAM;AAC3C;AACA;AACA,6CAAK;AACL;AACA;AACA;AACA,6CAAK;AACL;AACA;AACA;AACA,6CAAK;AACL;AACA;AACA;AACA,6CAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wCAAwC;AAC/C,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6BAA6B,OAAO,GAAG,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,KAAK;AAC7C;AACA,QAAQ,6CAAK,YAAY,KAAK,YAAY,6CAAK;AAC/C,gBAAgB,iDAAK,IAAI,KAAK;AAC9B;AACA,yBAAyB,iDAAK;AAC9B,eAAe,iDAAK,IAAI,KAAK;AAC7B;AACA,KAAK;AACL;AACO;AACP,IAAI,6CAAK;AACT;AACO;AACP,IAAI,6CAAK;AACT;AACO;AACP,WAAW,6CAAK;AAChB;AACA;;;;;;;;;;;;;;;AClLO,4CAA4C;AACnD;AACA;AACA;AACA,cAAc,wCAAwC,GAAG,gFAAgF;AACzI;AACA;;;;;;;;;;;;;;;;;;;ACNgD;AACoB;AAC7D,8BAA8B;AAC9B,oCAAoC;AACpC;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,+BAA+B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAY,wBAAwB,2DAAY,+BAA+B,2DAAY;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,6BAA6B;AAC7C;AACA;AACA,YAAY,+DAAgB;AAC5B,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA,wEAAwE,yBAAyB;AACjG;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClGuC;AACS;AACA;AACE;AAClD;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAa;AACrB,kBAAkB,wDAAqB;AACvC,0BAA0B,2DAAY,4BAA4B,2DAAY,mCAAmC,2DAAY;AAC7H,YAAY,gDAAa;AACzB,sBAAsB,wDAAqB;AAC3C;AACA;AACA,YAAY,gDAAa;AACzB,sBAAsB,wDAAqB;AAC3C;AACA;AACA;AACA,yBAAyB,8DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAY,4BAA4B,2DAAY,mCAAmC,2DAAY;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yBAAyB,0DAAc;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACV;AAC9C;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,KAAK,kEAAmB;AACxB;AACA;AACA,+BAA+B;AAC/B,mBAAmB,uDAAgB;AACnC;AACA;AACA,SAAS;AACT;AACA;AACO,wBAAwB;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;ACxDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;AC9B8C;AACW;AACA;AAC1B;AACQ;AACsB;AACvB;AACD;AAC+B;AACzB;AAC3C;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAgB,YAAY,GAAG,SAAS;AACzD;AACA,qBAAqB,2DAAY;AACjC,sBAAsB,qDAAkB;AACxC;AACA,qBAAqB,2DAAY,mCAAmC,2DAAY;AAChF,sBAAsB,qDAAkB;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,6CAAI,yBAAyB,kDAAM;AACzD;AACA;AACA;AACA;AACA,+BAA+B,mEAAW;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,iCAAiC,sCAAsC;AACvE;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,+BAA+B,MAAM,SAAS,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAY,GAAG,qFAAqF;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAW;AAC3B;AACA;AACA;AACA,oCAAoC,+CAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,6BAA6B,2DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAY;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU,qDAAkB,+EAA+E;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,+DAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAY;AACjC,qBAAqB,2DAAY;AACjC;AACA;AACA;AACA;AACA,2CAA2C,2DAAY,qBAAqB,2DAAY,kBAAkB,2DAAY;AACtH,yBAAyB;AACzB;AACA,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA;AACA,qBAAqB,2DAAY;AACjC,qBAAqB,2DAAY;AACjC;AACA;AACA;AACA,qBAAqB,2DAAY;AACjC,qBAAqB,2DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3S+D;AACf;AAC6B;AAClC;AACsC;AAC1E,0BAA0B,yEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oEAAqB,GAAG,mEAAoB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB,oEAAqB,uBAAuB,0DAAc,CAAC,mEAAoB,cAAc;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,2CAA2C;AACrE;AACA;AACA,0BAA0B,2CAA2C;AACrE;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,wDAAwD,oDAAY,GAAG;AACnF;AACA,wCAAwC,GAAG,SAAS,GAAG;AACvD;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,gEAAgE,KAAK,GAAG,GAAG;AAC3E,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACzDO;AACP;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;ACJ4C;AACS;AACL;AAC6B;AACX;AAClB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA,eAAe,mEAAQ;AACvB;AACA,uBAAuB,8DAAmB;AAC1C;AACA,KAAK;AACL;AACA;AACA,+BAA+B,uDAAsB;AACrD;AACA,yBAAyB,sDAAW;AACpC,oEAAoE,sDAAW;AAC/E,kBAAkB,kDAAiB,KAAK,mEAAoB,IAAI,sDAAW,CAAC;AAC5E,sEAAsE,sDAAW;AACjF;AACA;AACA;AACA;AACA,kBAAkB,kDAAiB,KAAK,mEAAoB,IAAI,SAAS;AACzE;AACA,qBAAqB;AACrB;AACA;AACA;AACA,+BAA+B,0DAAc,uBAAuB,sDAAM,QAAQ,mEAAoB,IAAI,EAAE,QAAQ,mEAAoB;AACxI;AACA,kBAAkB,kDAAiB;AACnC;AACA;AACA;AACA;AACA,cAAc,kDAAiB,KAAK,mEAAoB;AACxD;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzF8C;AACd;AAC6C;AACN;AACvE,gBAAgB,mEAAoB;AACpC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,+DAAkB;AAC7B;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnC8C;AACO;AACxB;AACY;AACF;AACS;AAC6B;AACxB;AACL;AACP;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,mEAAQ;AACvB;AACA,uBAAuB,8DAAmB;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA,oDAAoD,sDAAW;AAC/D,eAAe,mEAAoB,IAAI,sDAAW,CAAC;AACnD,eAAe,mEAAoB,IAAI,SAAS;AAChD,UAAU,qDAAoB;AAC9B;AACA,yBAAyB,uDAAsB;AAC/C;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA,yBAAyB,uDAAsB;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAc,kDAAiB,KAAK,mEAAoB,IAAI,SAAS;AACrE;AACA,+BAA+B,uDAAsB;AACrD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc,wDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAM;AAClC;AACA;AACA,gCAAgC,mDAAM;AACtC;AACA;AACA,gCAAgC,mDAAM;AACtC,eAAe,mEAAQ;AACvB;AACA;AACA,KAAK;AACL;AACA,uBAAuB,8DAAmB;AAC1C,KAAK;AACL;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,sDAAW;AACrG,8CAA8C,SAAS;AACvD;AACA,8BAA8B,0DAAc;AAC5C,oBAAoB,mEAAoB,IAAI,sDAAW,CAAC,MAAM,gDAAa,yBAAyB,mEAAoB;AACxH,0FAA0F,sDAAW;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,sDAAW;AAC3F;AACA,gBAAgB,mEAAoB,IAAI,sDAAW,CAAC;AACpD,gBAAgB,mEAAoB,IAAI,SAAS;AACjD;AACA,gFAAgF,sDAAW;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAsB;AACvD;AACA,6BAA6B,sDAAW;AACxC,iCAAiC,uDAAsB;AACvD;AACA;AACA;AACA,0BAA0B,wDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxSmD;AACX;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAW;AAC1B,oBAAoB,iEAAgB;AACpC,SAAS;AACT;AACA;AACA;AACA,sBAAsB,iEAAgB;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAW;AAC1B,mBAAmB,iEAAgB;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;ACxEmD;AACX;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAW;AAC1B,2BAA2B,iEAAgB;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,iEAAgB;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAW;AAC1B,mBAAmB,iEAAgB;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;AChGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoI;AAClE;AACW;AACpC;AAClC;AACP,sBAAsB,oEAAe;AACrC;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACO;AACP,sBAAsB,oEAAe;AACrC;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACO;AACP,sBAAsB,oEAAe;AACrC;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACO;AACP,WAAW,+DAAc,CAAC,qEAAgB;AAC1C;AACO;AACP,WAAW,+DAAc,CAAC,qEAAgB,qBAAqB,sEAAiB;AAChF;AACO;AACP,WAAW,kDAAW;AACtB;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,YAAY,sBAAsB,EAAE,kDAAW;AAC/C;AACA;AACO;AACP,2BAA2B,mEAAoB,6CAA6C,mEAAoB,6DAA6D,mEAAoB;AACjM;AACA;AACA;AACA,0BAA0B,wEAAmB;AAC7C;AACA;AACA;AACA,oBAAoB,uEAAkB;AACtC;AACA;AACA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACwE;AACjE;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,kCAAkC;AACnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AAC8C;AACG;AACK;AACV;AACL;AACc;AACG;AACN;AACc;AACa;AACN;AACvE;AACA;AACA,YAAY,sDAAK;AACjB;AACA;AACA,yCAAyC,sDAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA,KAAK,2DAAY;AACjB;AACA;AACA,0BAA0B,gEAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAQ,QAAQ,mEAAoB;AAC7D;AACA;AACA,yBAAyB,SAAS;AAClC;AACA,KAAK,2DAAY;AACjB;AACA;AACA;AACA;AACA,eAAe,iDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAkB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAS;AACvB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAS;AACvB;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,8DAAa,CAAC,gEAAS,YAAY,IAAI;AACjE;AACA,2CAA2C,WAAW;AACtD;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,8DAAa;AACvC,+BAA+B,kEAAQ;AACvC;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA,+BAA+B,4DAAM;AACrC,uCAAuC,WAAW;AAClD;AACA;AACA;AACA,6BAA6B,iDAAG;AAChC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,+DAAkB;AACtC;AACA;AACA;AACA,2BAA2B,4DAAM;AACjC,mCAAmC,0BAA0B;AAC7D;AACA,gCAAgC,kEAAQ;AACxC;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uCAAuC,WAAW,8DAAa,CAAC,kEAAQ,+BAA+B;AACvG;AACA;AACA,yCAAyC,WAAW,8DAAa,CAAC,kEAAQ,+BAA+B;AACzG;AACA,+BAA+B,iBAAiB,4DAAM,2CAA2C;AACjG;AACA;;;;;;;;;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACwE;AACjE;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,4BAA4B;AAC7B;;;;;;;;;;;;;;;;;;;;;;;;AC1E8E;AAChC;AACG;AACV;AACS;AACgB;AACc;AACzC;AACgB;AAC9C;AACP;AACA;AACA;AACA;AACA,6BAA6B,kDAAQ;AACrC,6BAA6B,+DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,yDAAyD,6CAAK;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAQ;AACrC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAqB;AAClD,yBAAyB,gDAAa;AACtC,8BAA8B,gDAAa;AAC3C,0BAA0B,gDAAa;AACvC,eAAe,0DAAc;AAC7B;AACA;;;;;;;;;;;;;;;AC5HO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACHA;AACO;AACP;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;ACNkD;AACO;AACL;AACyC;AACnC;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2BAA2B,uDAAQ;AACnC,uBAAuB,gEAAe;AACtC,mEAAmE,kEAAS;AAC5E;AACA,gCAAgC,+BAA+B;AAC/D;AACA,oBAAoB,mEAA2B;AAC/C,mBAAmB,yEAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACwE;AACjE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAO,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA,KAAK,sEAAsE;AAC3E;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,gCAAgC;AACjC;;;;;;;;;;;;;;;AChHO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACiE;AACxC;AACoB;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,yBAAyB,sDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAc,qBAAqB,2DAAU;AAC5E;AACA;AACA;AACA;AACA,2BAA2B,2DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAc;AACvD,iCAAiC,2DAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gBAAgB;AAChF;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACwE;AACjE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAO,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA,KAAK,+EAA+E;AACpF;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAO,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA;AACA,mBAAmB,8DAAa;AAChC;AACA,KAAK,mEAAmE;AACxE;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,oBAAoB;AACd;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,kBAAkB;AACnB;;;;;;;;;;;;;;;;;;;;;;;;;;ACjT8C;AACK;AACD;AAChB;AACiB;AACa;AAC5B;AACU;AACS;AACsC;AAC5C;AACjD;AACA,gBAAgB;AAChB;AACA,gBAAgB,6DAAM;AACtB,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA;AACA,iBAAiB,oEAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gFAAgB;AAChC,oDAAoD,YAAY;AAChE;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,oBAAoB,mDAAO;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,wFAAoB;AACtD;AACA;AACA;AACA,sBAAsB,wDAAS,4BAA4B,6CAAK;AAChE;AACA,oCAAoC,wFAAoB;AACxD;AACA;AACA,6CAA6C,wFAAoB;AACjE,eAAe,oEAAW;AAC1B;AACA;AACA,gBAAgB,4BAA4B;AAC5C,6BAA6B,8DAAQ;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,6BAA6B,8DAAQ;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,6BAA6B,8DAAQ;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,6DAAO;AACrC,2BAA2B,aAAa,4CAA4C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wFAAoB;AAC7E,iCAAiC,oEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAM;AAC1B,mCAAmC,0DAAgB;AACnD;AACA,sBAAsB,oEAAW;AACjC;AACA;AACA;AACA;AACA,iCAAiC,wFAAoB;AACrD;AACA,kBAAkB,oEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpImD;AACC;AACL;AACxC;AACP,iBAAiB,6CAAM;AACvB;AACA,iBAAiB,iEAAgB;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA,2BAA2B,kEAAS;AACpC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClC8C;AACmB;AAC5B;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAS;AACtC;AACA,aAAa,oEAAW;AACxB,sBAAsB,wDAAS,0BAA0B,6CAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,wBAAwB;AACxC;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;ACxC8C;AACD;AACC;AACT;AAC9B;AACA;AACP,SAAS,2DAAQ;AACjB,kBAAkB,wDAAS,mBAAmB,6CAAK;AACnD;AACA;AACA,eAAe,wDAAG,IAAI,iBAAiB,EAAE,OAAO;AAChD;AACA;;;;;;;;;;;;;;;;;;;ACZ8C;AACkB;AAC3B;AACgC;AAC9D;AACP;AACA,kBAAkB,wDAAS,qBAAqB,6CAAK;AACrD;AACA,+DAA+D,0DAAgB;AAC/E,kBAAkB,wDAAS,yDAAyD,6CAAK;AACzF;AACA;AACA;AACA,kBAAkB,wDAAS,2CAA2C,6CAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kFAA4B;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAS,kCAAkC,6CAAK;AAClE;AACA;AACA,kBAAkB,wDAAS,wCAAwC,6CAAK;AACxE;AACA;AACA;AACA;AACA,kBAAkB,wDAAS,8BAA8B,6CAAK;AAC9D;AACA;AACA,wBAAwB,UAAU;AAClC,sBAAsB,wDAAS,iCAAiC,6CAAK;AACrE;AACA;AACA,sBAAsB,wDAAS,oCAAoC,6CAAK;AACxE;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,sBAAsB,wDAAS,+BAA+B,6CAAK;AACnE;AACA;AACA,sBAAsB,wDAAS,2CAA2C,6CAAK;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACD;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACwE;AACX;AACtD;AACP;AACA;AACA;AACA;AACA,qBAAqB,wDAAO,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA,yBAAyB,wDAAe;AACxC,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA,eAAe,8DAAa;AAC5B;AACA,CAAC,wBAAwB;AACzB;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK,GAAG,MAAM,GAAG,IAAI,GAAG,KAAK,GAAG,OAAO,GAAG,QAAQ,GAAG,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE;AAC9B;AACA,cAAc,EAAE,OAAO,EAAE,OAAO,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxC8C;AACP;AACP;AACH;AACY;AACO;AACA;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAK;AAC5B,sBAAsB,mDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,2BAA2B,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,4DAA4D,0DAAc;AAC1E;AACA;AACA,2CAA2C,mDAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAU;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,uDAAU;AAChC;AACA;AACA;AACA;AACA,kBAAkB,uDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrVoD;AACb;AACa;AAC7C;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,2BAA2B,6DAAa;AACxC,2BAA2B,6DAAa;AACxC,wBAAwB,6DAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACJ;AACtD;AACA;AACA;AACA;AACO;AACP,uBAAuB,mEAAS;AAChC,uBAAuB,mEAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,oEAAO;AAC9B,uBAAuB,oEAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9B2C;AACC;AACrC;AACP,gBAAgB,yDAAW;AAC3B,QAAQ,yDAAS;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChD+C;AACL;AACnC;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAW;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,wDAAW;AAChD;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAW;AAChD;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAW;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpD6E;AACxC;AACgC;AACjC;AACM;AAC1C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAK;AACtC,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA,mBAAmB,mEAAoB;AACvC;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA,kCAAkC,8CAAM;AACxC;AACA;AACA,kCAAkC,8CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAY;AACjC;AACA,kCAAkC,8CAAM;AACxC;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8CAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAoB;AACvC;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAoB;AACvC;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,iEAAoB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrI6D;AACG;AACzD;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAe;AAClC,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjC4C;AACF;AACmC;AACtE;AACP;AACA,eAAe,wDAAO;AACtB,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,+DAAS;AAC/B;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,IAAI;AACtB;AACA,WAAW,mEAAoB;AAC/B;AACA;;;;;;;;;;;;;;;;;;;;AC5B6E;AACjB;AACxB;AACM;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAK;AACtC,iCAAiC,uDAAY;AAC7C;AACA,gBAAgB,2DAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,mEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,2DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAoB;AACvC;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAoB;AACvC;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA,WAAW,2DAAQ;AACnB,yBAAyB;AACzB,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACtFO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1C+C;AAC/C;AACA;AACA;AACO;AACP;AACA,gBAAgB,UAAU;AAC1B,uBAAuB,2DAAW;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACbyC;AACzC;AACA;AACA;AACO,wBAAwB,kDAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACdyC;AAClC,4BAA4B,kDAAK;AACxC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;ACjBkD;AAChB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4CAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,eAAe,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAsC,GAAG,mCAAmC,GAAG,sCAAsC,GAAG,mCAAmC;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,UAAU,IAAI,UAAU,IAAI,UAAU,IAAI;AACxE,4BAA4B,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI;AAC5F,6BAA6B,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI;AACrI,yCAAyC,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI;AACjJ,gCAAgC,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI;AACxI,4BAA4B,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB,IAAI;AACxJ,6BAA6B,IAAI;AACjC;AACA,yBAAyB,IAAI;AAC7B;AACO;AACP,QAAQ,wDAAM;AACd;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAM;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxF6E;AACtC;AACA;AACR;AAC/B;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,gEAAiB;AAC5C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE,gDAAgD,UAAU,eAAe;AACzE;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D,gDAAgD,UAAU,mBAAmB;AAC7E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAU;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAS;AACvB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAQ;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7PgE;AACvB;AACK;AAC9C;AACA;AACA;AACA;AACA,cAAc,uDAAuD,EAAE,WAAW;AAClF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,yDAAU;AAChD;AACA;AACA;AACA,2BAA2B;AAC3B,8BAA8B,uDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAU;AAC3C,sCAAsC;AACtC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;ACjF+C;AAClB;AACtB;AACP;AACA;AACA;AACA;AACA,wBAAwB,mDAAM;AAC9B;AACA;AACA;AACA;AACA,wDAAwD,yDAAU;AAClE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClB8C;AACpB;AACnB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAK;AACvB;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe,GAAG,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gBAAgB;AAC5B;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrCA;AACO;AACA;AACA;AACA;AACA;AACP;AACO;AACP;;;;;;;;;;;;;;;;;;;;ACR6C;AACwC;AAC9E;AACP;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA,0CAA0C,mDAAQ;AAClD,eAAe,2DAAgB;AAC/B,YAAY,iEAAsB;AAClC,KAAK;AACL;AACO;AACP;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA,0CAA0C,mDAAQ;AAClD,eAAe,iEAAsB;AACrC,KAAK;AACL;AACO;AACP;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA,0CAA0C,mDAAQ;AAClD,eAAe,iEAAsB;AACrC,YAAY,oDAAS,gCAAgC,mDAAQ,kBAAkB,mDAAQ;AACvF,KAAK;AACL;AACO;AACP;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA,0CAA0C,mDAAQ;AAClD;AACA,YAAY,2DAAgB;AAC5B,mBAAmB,oDAAS,gCAAgC,mDAAQ,kBAAkB,kDAAO;AAC7F;AACA;AACA,eAAe,iEAAsB;AACrC,YAAY,oDAAS,gCAAgC,mDAAQ,kBAAkB,mDAAQ;AACvF,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,aAAa;AACzB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACoF;AACX;AAClC;AACV;AACyB;AACb;AACW;AACZ;AACO;AACM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK,8DAAe;AACpB;AACA,KAAK,kEAAmB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAc;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAM;AACnC,0BAA0B,qDAAO,CAAC,8EAAK;AACvC;AACA;AACA;AACA;AACA,4BAA4B,wDAAS,yBAAyB,cAAc;AAC5E;AACA,mDAAmD,aAAa;AAChE;AACA,SAAS;AACT;AACA,qCAAqC,gEAAmB;AACxD,kBAAkB,uDAAU;AAC5B;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAc;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAS,IAAI,mDAAW;AACpC,mBAAmB,6CAAW;AAC9B;AACA,eAAe,6CAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrLO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACH8C;AACC;AAC/C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,kBAAkB;AACtC,gCAAgC;AAChC;AACA;AACA,mDAAmD,wDAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,aAAa,eAAe;AACjE;AACA;AACA;AACA,6BAA6B,IAAI,aAAa,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,YAAY;AACrB;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFsD;AACG;AAChB;AACO;AAChD;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,sDAAK;AAC1B,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,sEAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,sBAAsB,6DAAQ;AAC9B;AACA;AACA,qCAAqC,gEAAmB,gBAAgB,gBAAgB;AACxF;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAmB,gBAAgB,aAAa;AACzF;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ,EAAE,OAAO;AAC3E;AACA;AACA;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AAC2C;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACO;AACA,sBAAsB;AAC7B,eAAe,wCAAQ;AACvB;AACA;;;;;;;;;;;;;;;;ACrG4D;AACrD;AACP;AACA,QAAQ,yEAAgB;AACxB,QAAQ,yEAAgB;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACPA;AAC6B;AACyB;AACb;AACQ;AACW;AAC5D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wCAAwC;AAC/C,0BAA0B,+CAAM;AAChC;AACA,KAAK;AACL,oCAAoC;AACpC;AACA;AACA,QAAQ,6DAAQ;AAChB;AACA,wCAAwC,iDAAU;AAClD,SAAS;AACT,iCAAiC,gEAAmB,gBAAgB,cAAc;AAClF;AACA;AACA,uCAAuC,IAAI,GAAG,aAAa;AAC3D;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,2DAA2D,YAAY,IAAI,eAAe;AAC1F;AACA,6BAA6B,wEAAa;AAC1C,qCAAqC,gEAAmB,mBAAmB,kBAAkB;AAC7F;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9D8B;AACW;AACyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAa,GAAG,SAAS;AAC5C;AACA;AACA;AACA,uBAAuB,qBAAqB,GAAG,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB,gBAAgB;AACxC;AACA;AACA,sBAAsB,iDAAU;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB,GAAG,YAAY;AAC3D;AACA;AACA,kDAAkD,4DAAW;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,qBAAqB,GAAG,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACzEyC;AAClC;AACP;AACA,QAAQ,iDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBuE;AAC9B;AACzC;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAU;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,iDAAU;AAChC;AACA,0DAA0D,+DAAkB;AAC5E;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BoD;AACpD;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACO;AACA;AACA;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACO;AACA;AACP,4KAA4K;AACrK;AACP;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kEAAS;AAC1B;AACA,sBAAsB;AACtB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,UAAU,wBAAwB,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,UAAU,wBAAwB,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kEAAS;AAC1B;AACA,sBAAsB;AACtB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACT;AACa;AACA;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAS,YAAY,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAS;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,wCAAwC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,oDAAM;AAC5C,sCAAsC,oDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;ACvgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AAC+D;AAC/D;AACA,IAAI,kEAAS;AACb,IAAI,kEAAS;AACb,IAAI,kEAAS;AACb,IAAI,kEAAS;AACb,IAAI,kEAAS;AACb;AACA;AACA;AACA;AACA,uBAAuB,kEAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kEAAS;AACtD;AACA;AACA,qCAAqC,kEAAS;AAC9C;AACA,oDAAoD,kEAAS,qBAAqB;AAClF;AACA;AACA,0BAA0B,kEAAS;AACnC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAwD,GAAG,MAAM;AACzF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAwD,GAAG,MAAM;AACzF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD,QAAQ,MAAM;AACxF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD,OAAO,MAAM;AACvF,KAAK;AACL;AACA;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,EAAE,QAAQ;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,GAAG,aAAa;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,EAAE,QAAQ;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E;AACA;AACO;AACP,eAAe,kEAAS;AACxB;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAS;AAC9B;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClPuC;AACyB;AACO;AACR;AACZ;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,sBAAsB,gEAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAc;AACnD;AACA;AACA;AACA,sBAAsB,2DAAc;AACpC;AACA,uCAAuC,4DAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAa;AAClC,kBAAkB,wDAAqB;AACvC,kBAAkB,gEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,8DAA8D,+DAAkB;AAChF;AACA;AACA;AACA,2BAA2B,4DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAW;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,0DAAgB;AAC3B,sBAAsB,gEAAW;AACjC,kCAAkC,gDAAa;AAC/C;AACA,kBAAkB,0DAAgB,iBAAiB;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAa;AAClC,sBAAsB,wDAAqB;AAC3C;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB,gDAAa;AAClC,kBAAkB,wDAAqB;AACvC,kBAAkB,gEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8DAA8D,+DAAkB;AAChF;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AAC2C;AACQ;AACG;AACV;AACL;AACc;AACd;AACyB;AACa;AACN;AACzC;AACqB;AACnD,oBAAoB,iEAAW;AAC/B,oBAAoB,iEAAW;AAC/B,uBAAuB,iEAAW;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,iEAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAkB,iBAAiB;AACtD;AACA;AACO;AACP,qBAAqB,iEAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAoB,iBAAiB;AACxD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,qDAAK;AACpB;AACA,+BAA+B,sDAAK;AACpC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,SAAS,yCAAO;AAChB;AACA;AACA,WAAW,4CAAU;AACrB;AACA;AACA,qBAAqB,6CAAW;AAChC;AACA;AACA;AACA,SAAS,yCAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAoB;AACpC,iCAAiC,gDAAa;AAC9C,WAAW,0DAAgB;AAC3B;AACA;AACA,iBAAiB,gDAAa;AAC9B,oBAAoB,wDAAqB;AACzC;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B;AACA;AACA;AACA;AACA,aAAa,8DAAa,CAAC,gEAAS,YAAY,KAAK;AACrD;AACA;AACA,aAAa,iDAAG;AAChB;AACA;AACA,iCAAiC,gDAAa;AAC9C,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA,iCAAiC,gDAAa;AAC9C,WAAW,0DAAgB;AAC3B;AACA;AACA,iBAAiB,gDAAa;AAC9B,2BAA2B,wDAAqB;AAChD;AACA;AACA;AACA,iBAAiB,+DAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAa;AAC9B,8BAA8B,wDAAqB;AACnD;AACA;AACA;AACA,WAAW,+DAAkB;AAC7B;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA,gBAAgB,6DAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA,gBAAgB,6DAAM,YAAY,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAgB;AAC3B;AACA;AACA;AACA;AACA,iBAAiB,+DAAkB;AACnC;AACA,cAAc,KAAK,GAAG,KAAK;AAC3B;AACA;;;;;;;;;;;;;;;;;AClP+C;AACP;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,oDAAS;AAClC,uBAAuB,2DAAc;AACrC;AACA;AACA;AACA;AACA,kBAAkB,oDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+BAA+B;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,MAAM;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACqE;AAClB;AACnD;AACA,mBAAmB,eAAe;AAClC;AACO;AACwD;AAC/D;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAc;AAC7B;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,2BAA2B,iDAAM;AACjC;AACA;AACA,4BAA4B,sBAAsB,eAAe;AACjE;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACO;AACP,eAAe,oDAAc;AAC7B;AACoC;AACpC;;;;;;;;;;;;;;;;;;;;;ACrMkD;AACqB;AAC/B;AACjC,aAAa,oDAAM;AACnB,aAAa,oDAAM;AAC1B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA,8BAA8B,+DAAkB;AAChD;AACA;AACA,sCAAsC,+DAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AAC8C;AACQ;AACf;AACyB;AACO;AACmB;AAChC;AACK;AAC/D;AACO;AACP;AACA,IAAI,gEAAW;AACf,IAAI,gEAAW;AACf,IAAI,gEAAW;AACf,IAAI,gEAAW;AACf;AACA;AACA,cAAc,iBAAiB,QAAQ;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAqB;AACzC;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA,oBAAoB,iEAAsB;AAC1C;AACA,iBAAiB,sDAAW,UAAU;AACtC,oBAAoB,gEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAW;AAC/B,oBAAoB,gEAAW;AAC/B,oBAAoB,gEAAW;AAC/B,oBAAoB,gEAAW;AAC/B,qBAAqB,gEAAW;AAChC,wBAAwB,gEAAW;AACnC;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY,EAAE,KAAK;AAC7C;AACA;AACA;AACA,4BAA4B,gEAAW;AACvC;AACA;AACA;AACA,4BAA4B,gEAAW;AACvC,0BAA0B,YAAY,EAAE,KAAK;AAC7C;AACA;AACA;AACA;AACA,oEAAoE,8BAA8B,EAAE,QAAQ,EAAE,SAAS,EAAE,KAAK;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,EAAE,gEAAW;AACzE;AACA;AACA;AACA;AACA;AACA,4CAA4C,gEAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB,+BAA+B,gBAAgB;AACvG;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA,qCAAqC,wDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAK;AAClC;AACA;AACA;AACA;AACA,6BAA6B,sDAAK;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAkB,CAAC,gEAAS,YAAY,UAAU;AAC7E;AACA;AACA,uBAAuB,+DAAkB,CAAC,iDAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAS;AAClC;AACA,sBAAsB,wDAAS,8BAA8B,qBAAqB;AAClF;AACA;AACA,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA;AACA,4FAA4F,kBAAkB,2CAA2C,SAAS;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnPA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,QAAQ;AACR;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA,iDAAiD,aAAa;AAC9D;AACA;;;;;;;;;;;;;;;;;;;AC1F8C;AACM;AACZ;AACY;AACpD;AACA,QAAQ,oBAAoB,EAAE,gEAAW;AAClC,uEAAuE;AAC9E;AACA;AACA,kBAAkB,wDAAS;AAC3B;AACA;AACA,qCAAqC,sDAAG;AACxC,oDAAoD,SAAS;AAC7D;AACA;AACA,YAAY,yDAAU;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAS;AAC5B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9C+C;AAC/C;;;;;;;;;;;;;;;;;;;ACDA;AACiF;AACnB;AAC9D;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B;AAC/B,+BAA+B;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAG;AACtB,mBAAmB,8CAAG;AACf;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAG;AACnB;AACA;AACA,4BAA4B,8CAAG;AAC/B,4BAA4B,8CAAG;AAC/B,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,qEAAqE,EAAE,oDAAS,GAAG,0EAA0E;AACzK;AACA;AACA,IAAI,kDAAO;AACX,IAAI,kDAAO;AACX,IAAI,gDAAK;AACT,IAAI,gDAAK;AACT;AACA,QAAQ,iDAAM;AACd,QAAQ,iDAAM;AACd,QAAQ,iDAAM;AACd;AACA;AACA;AACA,QAAQ,iDAAM;AACd,QAAQ,kDAAO;AACf;AACA;AACA;AACA,4CAA4C,cAAc,0BAA0B,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAS;AAC3C,oBAAoB,8CAAG;AACvB;AACA;AACA;AACA;AACA,sCAAsC,8CAAG;AACzC;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAG;AACvB;AACA,QAAQ,gDAAK;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,kBAAkB,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,IAAI;AACrF;AACA;AACqD;AACrD,iBAAiB;AACjB,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;;;ACxCqF;AACzC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO;AACrB,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,QAAQ,gDAAK;AACb;AACA;AACA,QAAQ,kDAAO;AACf,gBAAgB,mBAAmB;AACnC,eAAe,kDAAO;AACtB;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAK;AACb;AACA;AACA,QAAQ,kDAAO;AACf,QAAQ,kDAAO;AACf;AACA,gBAAgB,YAAY;AAC5B,cAAc,MAAM;AACpB;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qDAAqD,kDAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpQA;AAC+C;AACA;AACL;AAC4C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,oBAAoB,YAAY;AAChC;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,QAAQ;AAC5B;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA,cAAc,6CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC,qDAAY;AACxD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,iCAAiC,qDAAY;AACpD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,kCAAkC,qDAAY;AACrD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,gCAAgC,qDAAY;AACnD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,iCAAiC,qDAAY;AACpD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAQ;AACtB;AACA;AACA;AACA;AACA,iBAAiB,qDAAU;AAC3B,IAAI,uDAAY;AAChB,IAAI,uDAAY;AAChB;AACA;AACA,IAAI,gDAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,iDAAM;AACV,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,YAAY,gDAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAU;AAC3B;AACA;AACA,YAAY,gDAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO,yCAAyC,qDAAU,GAAG,+CAA+C;AAC5G;AACA;AACA;AACA;AACA;AACO,0CAA0C,qDAAU,GAAG,+CAA+C;AAC7G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/TA;AACwD;AACxD;AACO;AACA;AACA;AACP;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gDAAgD,WAAW;AAC3D,0DAA0D;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,aAAa,mDAAO;AACpB;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClMA;AAC0C;AACqB;AACP;AACxD;AACO;AACP;AACA;AACA,gCAAgC,wDAAI,YAAY,gEAAW;AAC3D,mBAAmB;AACnB;AACA;AACO;AACP,6BAA6B,qEAAW,GAAG,+BAA+B;AAC1E,2BAA2B,4BAA4B;AACvD;AACA;;;;;;;;;;;;;;;;;;AChBA;AACA;AACsD;AACV;AAC5C;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE,kBAAkB,KAAK;AAC1E;AACA;AACA;AACA,iDAAiD;AACjD,yCAAyC;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP,IAAI,0DAAa;AACjB,IAAI,yDAAc;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,oDAAO;AAClB;AACA,aAAa,mBAAmB;AAChC,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;AC1KA;AACA;AACiD;AACd;AACF;AACyB;AAC1D;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,kCAAkC,kCAAkC;AACpE;AACO;AACP;AACA,YAAY,4FAA4F;AACxG;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT,6EAA6E;AAC7E;AACA;AACA,YAAY,gDAAK;AACjB;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA,QAAQ,+CAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAQ;AACjC,gBAAgB,sBAAsB;AACtC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,KAAK;AACL,4BAA4B,mDAAQ;AACpC,gBAAgB,OAAO;AACvB;AACA,gDAAgD;AAChD;AACA;AACA,gBAAgB,6BAA6B;AAC7C,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,kCAAkC;AAClC,kCAAkC;AAClC,gDAAgD;AAChD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB,oBAAoB,yBAAyB;AAC7C,qCAAqC;AACrC,qCAAqC;AACrC,iDAAiD;AACjD,mCAAmC;AACnC;AACA,uDAAuD;AACvD,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,iCAAiC;AACrD,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,qCAAqC;AACrC,yCAAyC;AACzC,qCAAqC;AACrC,2DAA2D;AAC3D,6BAA6B;AAC7B,6BAA6B;AAC7B,uCAAuC;AACvC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAW,iCAAiC;AACxD,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAW,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,kBAAkB,sDAAW,wBAAwB;AACrD,YAAY,gDAAK;AACjB,wCAAwC;AACxC,2CAA2C;AAC3C,gDAAgD;AAChD,sBAAsB,sDAAkB;AACxC;AACA;AACA;AACA;AACA,YAAY,+CAAW;AACvB;AACA;AACA,oCAAoC;AACpC,sCAAsC;AACtC,wCAAwC;AACxC,kBAAkB,oBAAoB,iBAAiB;AACvD;AACA;AACA,8CAA8C;AAC9C,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,0BAA0B,sDAAkB,eAAe;AAC3D,2DAA2D;AAC3D,0BAA0B;AAC1B;AACA;AACA,mBAAmB,iDAAa,qBAAqB;AACrD;AACA;AACA;AACA,gDAAgD;AAChD,YAAY,mBAAmB;AAC/B,iBAAiB,+CAAI;AACrB;AACA,eAAe,gDAAG;AAClB;AACA;AACA;AACA,oBAAoB,sDAAkB;AACtC;AACA;AACA;AACA;AACA,cAAc,sDAAW;AACzB;AACA;AACA,uBAAuB,sDAAW;AAClC,8DAA8D;AAC9D,mDAAmD;AACnD,sCAAsC;AACtC,0CAA0C;AAC1C,+CAA+C;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAc;AAClC,yCAAyC,sDAAW;AACpD;AACA;AACA,4CAA4C;AAC5C,cAAc,sDAAW;AACzB;AACA,gCAAgC;AAChC,gBAAgB,6BAA6B;AAC7C,oEAAoE;AACpE,8CAA8C;AAC9C,2EAA2E;AAC3E,wCAAwC;AACxC,QAAQ,+CAAW,sCAAsC;AACzD,oBAAoB,kDAAc,IAAI,sDAAkB;AACxD,eAAe,sDAAW,kCAAkC;AAC5D;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,8BAA8B;AAC9B,cAAc,sDAAW,6BAA6B;AACtD,cAAc,sDAAW;AACzB;AACA,YAAY,gDAAK;AACjB;AACA,gCAAgC;AAChC,kBAAkB,sDAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5amC;AAC4D;AAC/F;AACA,cAAc,sDAAe;AAC7B;AACA;AACA;AACA,iDAAiD,OAAO,SAAS,OAAO;AACxE;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV,IAAI,iDAAM;AACV;AACA;AACA;AACA,gBAAgB,sDAAW,CAAC,sDAAW;AACvC,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA,4CAA4C;AAC5C;AACA,kBAAkB,sDAAW;AAC7B,aAAa,sDAAW;AACxB,oBAAoB,UAAU;AAC9B;AACA,iBAAiB,sDAAW;AAC5B;AACA,gCAAgC,sDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,SAAS,sDAAW;AACpD;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAA6E;AACjG;AACA;AACO;AACP,IAAI,yDAAc;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,mCAAmC;AAC/C,IAAI,iDAAM;AACV;AACA,2CAA2C,sDAAW;AACtD;AACA,0CAA0C;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iDAAiD;AACjD,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,wCAAwC;AACtF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,GAAG;AACrF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5KA;AACA;AACuI;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qEAAqE,QAAQ,MAAM,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,kBAAkB,2CAA2C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,mCAAmC;AACnC,8BAA8B;AAC9B;AACA;AACA,gCAAgC;AAChC;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA,iCAAiC;AACjC;AACA;AACA,4DAA4D;AAC5D,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD;AACA,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,sDAAsD;AACtD,sDAAsD;AACtD,0CAA0C;AAC1C,0CAA0C;AAC1C,sDAAsD;AACtD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,yDAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sDAAsD;AAC7D;AACA,yDAAyD,MAAM;AAC/D,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO;AACrB;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAe,eAAe,0DAAe;AAC/E;AACA;AACA,0DAA0D,MAAM,QAAQ,aAAa;AACrF,0BAA0B,0DAAe,UAAU,0DAAe;AAClE,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAW;AACtB;AACA;AACA;AACA,yDAAyD,OAAO,4BAA4B,QAAQ;AACpG,uBAAuB,0DAAe,SAAS,0DAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,4BAA4B,IAAI;AAC3E,uBAAuB,0DAAe,QAAQ,0DAAe;AAC7D;AACA;AACA,kBAAkB,0DAAe,sBAAsB,0DAAe;AACtE;AACA;;;;;;;;;;;;;;;;;ACzaA;AACwC;AAC8D;AACtG;AACA;AACA;AACA,IAAI,yDAAc;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACO;AACP;AACA,YAAY,IAAI;AAChB,wBAAwB,gDAAG;AAC3B;AACA;AACA;AACA;AACA,mDAAmD,gDAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA,0BAA0B;AAC1B,eAAe,0DAAe;AAC9B;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA,wCAAwC,iBAAiB,KAAK,UAAU,aAAa,IAAI;AACzF,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAA8D;AAC/E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,2BAA2B,OAAO,8BAA8B,MAAM;AACtE;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,IAAI;AACpC;AACO;AACP;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,iCAAiC,IAAI,YAAY,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO,WAAW,gBAAgB,aAAa,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM,IAAI,KAAK,SAAS,IAAI,QAAQ,UAAU,EAAE,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACO;AACP;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AACnD,8DAA8D;AACrE;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,GAAG,KAAK,GAAG,WAAW,cAAc,KAAK;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,WAAW,YAAY,IAAI;AACpD,kCAAkC,oBAAoB,IAAI,aAAa,GAAG;AAC1E;AACA,kCAAkC,UAAU,IAAI,SAAS;AACzD,kCAAkC,oBAAoB,IAAI,SAAS;AACnE,kCAAkC,2BAA2B;AAC7D,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5UA;AACA;AACiD;AACb;AACH;AACyB;AAC1D;AACA;AACA,QAAQ,gDAAK;AACb;AACA,QAAQ,gDAAK;AACb;AACA;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,QAAQ,wCAAwC,EAAE,sCAAE;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAA0C;AAC3D,KAAK;AACL;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,QAAQ,6CAAS;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,sBAAsB;AACtC;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,KAAK,SAAS;AAC1B;AACA;AACA;AACA,mBAAmB,kDAAc;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,8BAA8B;AAC9B,kCAAkC;AAClC,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAU;AACzB;AACA;AACA;AACA;AACA,gBAAgB,uEAAuE;AACvF;AACA,gBAAgB,8CAAU;AAC1B,sBAAsB,iDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAkB,CAAC,sDAAW;AACpD;AACA;AACA,mDAAmD,aAAa,4BAA4B,WAAW;AACvG;AACA;AACA,kBAAkB,4CAAO,UAAU;AACnC,QAAQ,+CAAW,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAQ;AACjC,gBAAgB,sBAAsB;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA,4BAA4B,mDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,gCAAgC;AAChC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D,qCAAqC;AACrC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAW;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,YAAY,+CAAW;AACvB,6BAA6B;AAC7B;AACA,wBAAwB,uBAAuB;AAC/C,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA,YAAY,gDAAK;AACjB,mBAAmB,iDAAa;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,+BAA+B,sCAAsC;AACrE;AACO;AACP;AACA,YAAY,qBAAqB;AACjC,wCAAwC;AACxC,8CAA8C;AAC9C;AACA,eAAe,4CAAO;AACtB;AACA;AACA,eAAe,+CAAU;AACzB;AACA,YAAY,2FAA2F;AACvG;AACA;AACA;AACA;AACA,wBAAwB,kDAAc;AACtC,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAkB;AAC5C,qBAAqB,8CAAU;AAC/B;AACA,mDAAmD;AACnD;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mDAAmD,KAAK,wBAAwB,eAAe,sBAAsB,iBAAiB;AACtI;AACA,SAAS;AACT,KAAK;AACL,mCAAmC,iDAAa,CAAC,sDAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO,YAAY,sDAAW;AAClD;AACA;AACA;AACA,YAAY,+CAAW,iCAAiC;AACxD,YAAY,+CAAW,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C,oCAAoC,sDAAW,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,sCAAsC;AACtC,qCAAqC;AACrC,kEAAkE;AAClE;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAoB;AAC/C,mBAAmB,uDAAkB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,wBAAwB,sDAAkB,SAAS;AACnD,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,uBAAuB,8CAAU;AACjC;AACA;AACA;AACA;AACA,QAAQ,+CAAW,YAAY,iBAAiB;AAChD;AACA,eAAe,sDAAkB;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,cAAc,mCAAmC,QAAQ;AACzD;AACA,yBAAyB;AACzB,kBAAkB,sDAAW;AAC7B;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,kEAAkE;AAClE,0BAA0B,sDAAW,sBAAsB;AAC3D;AACA,qBAAqB,kDAAc,eAAe;AAClD,yBAAyB;AACzB;AACA;AACA;AACA,wCAAwC;AACxC;AACA,wBAAwB;AACxB,gCAAgC;AAChC,yDAAyD;AACzD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,oEAAoE;AACpE;AACA;AACA,uCAAuC;AACvC,+BAA+B;AAC/B;AACA,sDAAsD;AACtD;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,mCAAmC;AACjE;AACA,qBAAqB,qDAAiB;AACtC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B,oBAAoB,sDAAW;AAC/B;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,0CAA0C,8CAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,0CAA0C;AAC1C,4BAA4B;AAC5B,iCAAiC;AACjC,iCAAiC;AACjC,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA,kBAAkB;AAClB,2DAA2D;AAC3D;AACA;AACA;AACA,uCAAuC;AACvC,iCAAiC;AACjC,iCAAiC;AACjC,6BAA6B;AAC7B,8BAA8B;AAC9B,4CAA4C;AAC5C;AACA,sBAAsB;AACtB,iCAAiC;AACjC,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,8BAA8B;AAC9B,oCAAoC;AACpC,+BAA+B;AAC/B,wCAAwC;AACxC,+BAA+B;AAC/B,gCAAgC;AAChC,uCAAuC;AACvC,uCAAuC;AACvC;AACA,yBAAyB,SAAS;AAClC,+BAA+B;AAC/B,sCAAsC;AACtC,yCAAyC;AACzC,6CAA6C;AAC7C,oCAAoC;AACpC,oCAAoC;AACpC,qCAAqC;AACrC,yCAAyC;AACzC,0CAA0C;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C;AAC3C,uCAAuC;AACvC;AACA,iCAAiC;AACjC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,kCAAkC;AAClC,uCAAuC;AACvC,+CAA+C,kBAAkB;AACjE,yCAAyC;AACzC,2CAA2C;AAC3C,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,sDAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,mCAAmC;AACnC,2BAA2B;AAC3B,gCAAgC;AAChC,mCAAmC;AACnC,mCAAmC;AACnC,mEAAmE;AACnE,mCAAmC;AACnC,2BAA2B;AAC3B,2BAA2B;AAC3B,mCAAmC;AACnC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,mCAAmC;AACnC,gCAAgC;AAChC,8BAA8B;AAC9B,gBAAgB,iBAAiB,uBAAuB;AACxD,4BAA4B;AAC5B,8BAA8B;AAC9B,sCAAsC;AACtC,wCAAwC;AACxC,gDAAgD;AAChD,uCAAuC;AACvC,4BAA4B;AAC5B,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrjCA;AAC8C;AAC8B;AACrB;AACwB;AACI;AAC7B;AACuD;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gBAAgB,0DAAI,wBAAwB;AAC5C,gBAAgB,0DAAI,uBAAuB;AAC3C,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,uBAAuB,0DAAI;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAG,gBAAgB;AAClC,eAAe,yDAAG,kBAAkB;AACpC;AACA;AACA,YAAY,yDAAG,mBAAmB;AAClC,gBAAgB,yDAAG,gBAAgB;AACnC,qBAAqB;AACrB,kBAAkB,yDAAG,0BAA0B;AAC/C,gCAAgC;AAChC,6BAA6B,yDAAG,SAAS;AACzC,2BAA2B,yDAAG,2BAA2B;AACzD;AACA;AACA;AACA,mBAAmB;AACnB,QAAQ,kEAAY;AACpB,YAAY,yDAAG;AACf,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAK;AACvC;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACO,uCAAuC,oEAAc;AAC5D;AACA;AACA;AACA,WAAW,gEAAW,CAAC,gEAAW;AAClC;AACO,0CAA0C,oEAAc;AAC/D;AACA;AACA,CAAC;AACM,yCAAyC,oEAAc,iBAAiB;AAC/E;AACA,aAAa,wDAAM;AACnB,CAAC;AACM,sCAAsC,mEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,eAAe,yDAAG,CAAC,0DAAI;AACvB,KAAK;AACL;AACA,eAAe;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,IAAI;AAChB;AACA;AACA;AACO,oDAAoD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,gEAAgE;AAChE,mEAAmE;AACnE;AACA;AACA,4CAA4C;AAC5C;AACA,yBAAyB;AACzB,4BAA4B;AAC5B,kCAAkC;AAClC,8BAA8B;AAC9B,0BAA0B;AAC1B,+BAA+B;AAC/B,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,2BAA2B;AAC3B,uBAAuB;AACvB,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,oCAAoC;AACpC,4BAA4B;AAC5B,oCAAoC;AACpC,uBAAuB;AACvB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,gCAAgC;AAChC,8BAA8B;AAC9B,gCAAgC;AAChC,oCAAoC;AACpC,gCAAgC;AAChC,uBAAuB;AACvB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,sBAAsB;AACtB,4BAA4B;AAC5B,+BAA+B;AAC/B,oCAAoC;AACpC,iCAAiC;AACjC,0BAA0B;AAC1B,0CAA0C;AAC1C,aAAa,sCAAsC;AACnD;AACA,+CAA+C,gEAAU,iCAAiC;AAC1F;AACA,YAAY,qBAAqB,yCAAyC;AAC1E;AACA,+BAA+B;AAC/B,sCAAsC;AACtC,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,kCAAkC;AAClC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,0CAA0C;AAC1C,aAAa,gDAAgD;AAC7D;AACA,mCAAmC,wEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,CAAC;AACM;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mEAAe;AAC7E;AACA;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA,sCAAsC;AACtC,gDAAgD;AAChD,wBAAwB;AACxB,6CAA6C;AAC7C,UAAU,gCAAgC,kBAAkB;AAC5D,0BAA0B;AAC1B,SAAS,kEAAY;AACrB;AACA;AACA,gBAAgB;AAChB;AACA,eAAe;AACf,wDAAwD;AACxD;AACA,iCAAiC;AACjC,4CAA4C;AAC5C,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAW;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAU,CAAC,mEAAe,iBAAiB,kEAAY;AACpE;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA,4CAA4C;AAC5C,gBAAgB,oBAAoB,6BAA6B;AACjE,gCAAgC;AAChC,oCAAoC;AACpC,mCAAmC;AACnC,YAAY,kEAAY;AACxB,yBAAyB;AACzB,gCAAgC;AAChC,8BAA8B;AAC9B,wBAAwB,kEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA,iDAAiD;AACjD,+BAA+B;AAC/B;AACA;AACA,gBAAgB,iBAAiB,8BAA8B;AAC/D,sCAAsC;AACtC,sCAAsC;AACtC,uCAAuC;AACvC,eAAe;AACf,YAAY,kEAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY,kEAAY;AACxB,yBAAyB;AACzB,kCAAkC;AAClC,YAAY,kEAAY;AACxB;AACA,eAAe,mEAAe,SAAS;AACvC;AACA;AACA,eAAe,8DAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA,wCAAwC,gEAAW;AACnD,0BAA0B,8EAAkB,eAAe,wDAAM;AACjE;AACA;AACA;AACO,iDAAiD;AACxD;;;;;;;;;;;;;;;;;;;;;;;;;AC1bA;AAC8C;AACI;AACD;AACsB;AACd;AAC4D;AACrD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,gBAAgB,0DAAI;AACpB,gBAAgB,0DAAI;AACpB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,gBAAgB,0DAAI;AACpB,gBAAgB,0DAAI;AACpB,iBAAiB,0DAAI;AACrB;AACA;AACA;AACA;AACA,WAAW,2DAAK,qCAAqC,eAAe;AACpE;AACA;AACA;AACO,kBAAkB,6DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA,qBAAqB,yDAAG;AACxB,qBAAqB,yDAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL,CAAC,EAAE,wDAAM;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAM;AAC3B,eAAe,+DAAW;AAC1B;AACA;AACA,WAAW,4DAAM,CAAC,+DAAW;AAC7B;AACA;AACA;AACA,wBAAwB,mEAAe;AACvC,oBAAoB,yDAAG;AACvB,oBAAoB,yDAAG;AACvB;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,sCAAsC,aAAa;AACnD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAQ,2BAA2B;AACvC;AACA,wCAAwC;AACxC,wBAAwB;AACxB;AACA,sBAAsB;AACtB,oCAAoC;AACpC;AACA;AACA;AACA,YAAY,+DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,oDAAoD,gEAAW;AAC/D,cAAc,+DAAW;AACzB,YAAY,uBAAuB,mCAAmC;AACtE,cAAc,+DAAW,0BAA0B;AACnD,+DAA+D;AAC/D,wDAAwD;AACxD,gCAAgC;AAChC;AACA,mDAAmD;AACnD,YAAY,uBAAuB,2BAA2B;AAC9D,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAW;AAC3B,cAAc,+DAAW;AACzB,gBAAgB,+DAAW;AAC3B;AACA,oCAAoC,wBAAwB;AAC5D,4CAA4C,2BAA2B;AACvE,aAAa,2DAAO;AACpB;AACA,6CAA6C,4BAA4B;AACzE,aAAa,2DAAO;AACpB;AACA,8DAA8D;AAC9D,2CAA2C;AAC3C;AACA,0BAA0B;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA,WAAW;AACX,KAAK;AACL,CAAC;AACD,sCAAsC,sEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA,CAAC;AACD,mCAAmC,wEAAY;AAC/C,YAAY,OAAO;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,CAAC;AACM;AACA;AACP;;;;;;;;;;;;;;;;;;;;;;ACjQA;AACA;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,kBAAkB,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,IAAI;AACrF;AACA;AACqD;AACrD,iBAAiB;AACjB,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;;;;ACzC8C;AACS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACO,qBAAqB,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAU;AAC9B;AACA;AACA,QAAQ,kDAAM;AACd,gBAAgB,yBAAyB;AACzC,eAAe,kDAAO;AACtB;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA,iCAAiC,qDAAU;AAC3C,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAM;AACd,QAAQ,kDAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiL;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,GAAG,EAAC;AACnB;;;;;;;;;;;;;;;AC7DO;AACP;;;;;;;;;;;;;;;;;;ACDgG;AACrD;AAC3C;AACO,mBAAmB,2CAAI;AAC9B;AACA;AACA;AACA;AACA,QAAQ,gDAAU;AAClB,oBAAoB,kDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB,QAAQ,iDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;AC5E4C;AACO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,wBAAwB,QAAQ;AAChC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D,qCAAqC,2CAAG;AACxC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D,iCAAiC,2CAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;AC1HkC;AACN;AACiB;AAC7C;AACA;AACA,sDAAsD,qDAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF;AACA;AACA;AACA,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF;AACA,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS;AAClC,wBAAwB,qDAAS;AACjC;AACA;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,EAAE,mDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAS;AACjC,iBAAiB,qDAAS;AAC1B;AACA;AACA;AACA,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,mCAAmC,0DAAe;AAClD,mCAAmC,0DAAe;AAClD,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACC;AAC/C,YAAY,UAAU;AACtB;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACO;AACP,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AACT;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,wDAAM,WAAW,wDAAM;AAC/B,eAAe,wDAAM;AACrB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1LA;AACA;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,kBAAkB,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,IAAI;AACrF;AACA;AACqD;AACrD,iBAAiB;AACjB,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;;;;ACzC8C;AACS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,qBAAqB,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAU;AAC9B;AACA;AACA,QAAQ,kDAAM;AACd,gBAAgB,yBAAyB;AACzC,eAAe,kDAAO;AACtB;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA,iCAAiC,qDAAU;AAC3C,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAM;AACd,QAAQ,kDAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiL;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,GAAG,EAAC;AACnB;;;;;;;;;;;;;;;AC7DO;AACP;;;;;;;;;;;;;;;;;;;;ACD0E;AACrC;AACJ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,gDAAU;AACd;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,WAAW,8CAAI,OAAO,kDAAO,QAAQ,kDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,gDAAU;AACd,IAAI,kDAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAAI;AACrB;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;ACvEgG;AACrD;AAC3C;AACO,mBAAmB,2CAAI;AAC9B;AACA;AACA;AACA;AACA,QAAQ,gDAAU;AAClB,oBAAoB,kDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB,QAAQ,iDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;AChF0E;AACzC;AACsC;AACvE;AACA;AACA,IAAI,gDAAU;AACd,iBAAiB,oDAAS,GAAG,0BAA0B;AACvD,YAAY,sBAAsB;AAClC,IAAI,kDAAY;AAChB,IAAI,kDAAY;AAChB,IAAI,kDAAY;AAChB;AACA;AACA,qBAAqB,kDAAO;AAC5B,iBAAiB,kDAAO;AACxB;AACA;AACA;AACA,gBAAgB,0CAAI;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACO;AACP,YAAY,6BAA6B;AACzC,cAAc;AACd;AACA,iBAAiB,qDAAU;AAC3B;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,wCAAwC;AACpD,cAAc;AACd;AACA,iBAAiB,qDAAU;AAC3B;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAS;AACvB;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrF4C;AACO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,wBAAwB,QAAQ;AAChC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D,qCAAqC,2CAAG;AACxC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D,iCAAiC,2CAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AACrD;AACA;AACA;AACO,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;;;;AC7HkC;AACN;AACiB;AAC7C;AACA;AACA,sDAAsD,qDAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF;AACA;AACA;AACA,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF;AACA,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS;AAClC,wBAAwB,qDAAS;AACjC;AACA;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,EAAE,mDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAS;AACjC,iBAAiB,qDAAS;AAC1B;AACA;AACA;AACA,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,mCAAmC,0DAAe;AAClD,mCAAmC,0DAAe;AAClD,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACC;AAC/C,YAAY,UAAU;AACtB;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACO;AACP,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AACT;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,wDAAM,WAAW,wDAAM;AAC/B,eAAe,wDAAM;AACrB;AACA;AACA,QAAQ,wDAAM,WAAW,wDAAM;AAC/B,eAAe,wDAAM;AACrB;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9LA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEe,uBAAuB,uBAAuB,IAAI;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;+CCjCA,qJAAAA,mBAAA,YAAAA,oBAAA,WAAAC,CAAA,SAAAC,CAAA,EAAAD,CAAA,OAAAE,CAAA,GAAAC,MAAA,CAAAC,SAAA,EAAAC,CAAA,GAAAH,CAAA,CAAAI,cAAA,EAAAC,CAAA,GAAAJ,MAAA,CAAAK,cAAA,cAAAP,CAAA,EAAAD,CAAA,EAAAE,CAAA,IAAAD,CAAA,CAAAD,CAAA,IAAAE,CAAA,CAAAO,KAAA,KAAAC,CAAA,wBAAAC,MAAA,GAAAA,MAAA,OAAAC,CAAA,GAAAF,CAAA,CAAAG,QAAA,kBAAAC,CAAA,GAAAJ,CAAA,CAAAK,aAAA,uBAAAC,CAAA,GAAAN,CAAA,CAAAO,WAAA,8BAAAC,OAAAjB,CAAA,EAAAD,CAAA,EAAAE,CAAA,WAAAC,MAAA,CAAAK,cAAA,CAAAP,CAAA,EAAAD,CAAA,IAAAS,KAAA,EAAAP,CAAA,EAAAiB,UAAA,MAAAC,YAAA,MAAAC,QAAA,SAAApB,CAAA,CAAAD,CAAA,WAAAkB,MAAA,mBAAAjB,CAAA,IAAAiB,MAAA,YAAAA,OAAAjB,CAAA,EAAAD,CAAA,EAAAE,CAAA,WAAAD,CAAA,CAAAD,CAAA,IAAAE,CAAA,gBAAAoB,KAAArB,CAAA,EAAAD,CAAA,EAAAE,CAAA,EAAAG,CAAA,QAAAK,CAAA,GAAAV,CAAA,IAAAA,CAAA,CAAAI,SAAA,YAAAmB,SAAA,GAAAvB,CAAA,GAAAuB,SAAA,EAAAX,CAAA,GAAAT,MAAA,CAAAqB,MAAA,CAAAd,CAAA,CAAAN,SAAA,GAAAU,CAAA,OAAAW,OAAA,CAAApB,CAAA,gBAAAE,CAAA,CAAAK,CAAA,eAAAH,KAAA,EAAAiB,gBAAA,CAAAzB,CAAA,EAAAC,CAAA,EAAAY,CAAA,MAAAF,CAAA,aAAAe,SAAA1B,CAAA,EAAAD,CAAA,EAAAE,CAAA,mBAAA0B,IAAA,YAAAC,GAAA,EAAA5B,CAAA,CAAA6B,IAAA,CAAA9B,CAAA,EAAAE,CAAA,cAAAD,CAAA,aAAA2B,IAAA,WAAAC,GAAA,EAAA5B,CAAA,QAAAD,CAAA,CAAAsB,IAAA,GAAAA,IAAA,MAAAS,CAAA,qBAAAC,CAAA,qBAAAC,CAAA,gBAAAC,CAAA,gBAAAC,CAAA,gBAAAZ,UAAA,cAAAa,kBAAA,cAAAC,2BAAA,SAAAC,CAAA,OAAApB,MAAA,CAAAoB,CAAA,EAAA1B,CAAA,qCAAA2B,CAAA,GAAApC,MAAA,CAAAqC,cAAA,EAAAC,CAAA,GAAAF,CAAA,IAAAA,CAAA,CAAAA,CAAA,CAAAG,MAAA,QAAAD,CAAA,IAAAA,CAAA,KAAAvC,CAAA,IAAAG,CAAA,CAAAyB,IAAA,CAAAW,CAAA,EAAA7B,CAAA,MAAA0B,CAAA,GAAAG,CAAA,OAAAE,CAAA,GAAAN,0BAAA,CAAAjC,SAAA,GAAAmB,SAAA,CAAAnB,SAAA,GAAAD,MAAA,CAAAqB,MAAA,CAAAc,CAAA,YAAAM,sBAAA3C,CAAA,gCAAA4C,OAAA,WAAA7C,CAAA,IAAAkB,MAAA,CAAAjB,CAAA,EAAAD,CAAA,YAAAC,CAAA,gBAAA6C,OAAA,CAAA9C,CAAA,EAAAC,CAAA,sBAAA8C,cAAA9C,CAAA,EAAAD,CAAA,aAAAgD,OAAA9C,CAAA,EAAAK,CAAA,EAAAG,CAAA,EAAAE,CAAA,QAAAE,CAAA,GAAAa,QAAA,CAAA1B,CAAA,CAAAC,CAAA,GAAAD,CAAA,EAAAM,CAAA,mBAAAO,CAAA,CAAAc,IAAA,QAAAZ,CAAA,GAAAF,CAAA,CAAAe,GAAA,EAAAE,CAAA,GAAAf,CAAA,CAAAP,KAAA,SAAAsB,CAAA,gBAAAkB,OAAA,CAAAlB,CAAA,KAAA1B,CAAA,CAAAyB,IAAA,CAAAC,CAAA,eAAA/B,CAAA,CAAAkD,OAAA,CAAAnB,CAAA,CAAAoB,OAAA,EAAAC,IAAA,WAAAnD,CAAA,IAAA+C,MAAA,SAAA/C,CAAA,EAAAS,CAAA,EAAAE,CAAA,gBAAAX,CAAA,IAAA+C,MAAA,UAAA/C,CAAA,EAAAS,CAAA,EAAAE,CAAA,QAAAZ,CAAA,CAAAkD,OAAA,CAAAnB,CAAA,EAAAqB,IAAA,WAAAnD,CAAA,IAAAe,CAAA,CAAAP,KAAA,GAAAR,CAAA,EAAAS,CAAA,CAAAM,CAAA,gBAAAf,CAAA,WAAA+C,MAAA,UAAA/C,CAAA,EAAAS,CAAA,EAAAE,CAAA,SAAAA,CAAA,CAAAE,CAAA,CAAAe,GAAA,SAAA3B,CAAA,EAAAK,CAAA,oBAAAE,KAAA,WAAAA,MAAAR,CAAA,EAAAI,CAAA,aAAAgD,2BAAA,eAAArD,CAAA,WAAAA,CAAA,EAAAE,CAAA,IAAA8C,MAAA,CAAA/C,CAAA,EAAAI,CAAA,EAAAL,CAAA,EAAAE,CAAA,gBAAAA,CAAA,GAAAA,CAAA,GAAAA,CAAA,CAAAkD,IAAA,CAAAC,0BAAA,EAAAA,0BAAA,IAAAA,0BAAA,qBAAA3B,iBAAA1B,CAAA,EAAAE,CAAA,EAAAG,CAAA,QAAAE,CAAA,GAAAwB,CAAA,mBAAArB,CAAA,EAAAE,CAAA,QAAAL,CAAA,KAAA0B,CAAA,QAAAqB,KAAA,sCAAA/C,CAAA,KAAA2B,CAAA,oBAAAxB,CAAA,QAAAE,CAAA,WAAAH,KAAA,EAAAR,CAAA,EAAAsD,IAAA,eAAAlD,CAAA,CAAAmD,MAAA,GAAA9C,CAAA,EAAAL,CAAA,CAAAwB,GAAA,GAAAjB,CAAA,UAAAE,CAAA,GAAAT,CAAA,CAAAoD,QAAA,MAAA3C,CAAA,QAAAE,CAAA,GAAA0C,mBAAA,CAAA5C,CAAA,EAAAT,CAAA,OAAAW,CAAA,QAAAA,CAAA,KAAAmB,CAAA,mBAAAnB,CAAA,qBAAAX,CAAA,CAAAmD,MAAA,EAAAnD,CAAA,CAAAsD,IAAA,GAAAtD,CAAA,CAAAuD,KAAA,GAAAvD,CAAA,CAAAwB,GAAA,sBAAAxB,CAAA,CAAAmD,MAAA,QAAAjD,CAAA,KAAAwB,CAAA,QAAAxB,CAAA,GAAA2B,CAAA,EAAA7B,CAAA,CAAAwB,GAAA,EAAAxB,CAAA,CAAAwD,iBAAA,CAAAxD,CAAA,CAAAwB,GAAA,uBAAAxB,CAAA,CAAAmD,MAAA,IAAAnD,CAAA,CAAAyD,MAAA,WAAAzD,CAAA,CAAAwB,GAAA,GAAAtB,CAAA,GAAA0B,CAAA,MAAAK,CAAA,GAAAX,QAAA,CAAA3B,CAAA,EAAAE,CAAA,EAAAG,CAAA,oBAAAiC,CAAA,CAAAV,IAAA,QAAArB,CAAA,GAAAF,CAAA,CAAAkD,IAAA,GAAArB,CAAA,GAAAF,CAAA,EAAAM,CAAA,CAAAT,GAAA,KAAAM,CAAA,qBAAA1B,KAAA,EAAA6B,CAAA,CAAAT,GAAA,EAAA0B,IAAA,EAAAlD,CAAA,CAAAkD,IAAA,kBAAAjB,CAAA,CAAAV,IAAA,KAAArB,CAAA,GAAA2B,CAAA,EAAA7B,CAAA,CAAAmD,MAAA,YAAAnD,CAAA,CAAAwB,GAAA,GAAAS,CAAA,CAAAT,GAAA,mBAAA6B,oBAAA1D,CAAA,EAAAE,CAAA,QAAAG,CAAA,GAAAH,CAAA,CAAAsD,MAAA,EAAAjD,CAAA,GAAAP,CAAA,CAAAa,QAAA,CAAAR,CAAA,OAAAE,CAAA,KAAAN,CAAA,SAAAC,CAAA,CAAAuD,QAAA,qBAAApD,CAAA,IAAAL,CAAA,CAAAa,QAAA,eAAAX,CAAA,CAAAsD,MAAA,aAAAtD,CAAA,CAAA2B,GAAA,GAAA5B,CAAA,EAAAyD,mBAAA,CAAA1D,CAAA,EAAAE,CAAA,eAAAA,CAAA,CAAAsD,MAAA,kBAAAnD,CAAA,KAAAH,CAAA,CAAAsD,MAAA,YAAAtD,CAAA,CAAA2B,GAAA,OAAAkC,SAAA,uCAAA1D,CAAA,iBAAA8B,CAAA,MAAAzB,CAAA,GAAAiB,QAAA,CAAApB,CAAA,EAAAP,CAAA,CAAAa,QAAA,EAAAX,CAAA,CAAA2B,GAAA,mBAAAnB,CAAA,CAAAkB,IAAA,SAAA1B,CAAA,CAAAsD,MAAA,YAAAtD,CAAA,CAAA2B,GAAA,GAAAnB,CAAA,CAAAmB,GAAA,EAAA3B,CAAA,CAAAuD,QAAA,SAAAtB,CAAA,MAAAvB,CAAA,GAAAF,CAAA,CAAAmB,GAAA,SAAAjB,CAAA,GAAAA,CAAA,CAAA2C,IAAA,IAAArD,CAAA,CAAAF,CAAA,CAAAgE,UAAA,IAAApD,CAAA,CAAAH,KAAA,EAAAP,CAAA,CAAA+D,IAAA,GAAAjE,CAAA,CAAAkE,OAAA,eAAAhE,CAAA,CAAAsD,MAAA,KAAAtD,CAAA,CAAAsD,MAAA,WAAAtD,CAAA,CAAA2B,GAAA,GAAA5B,CAAA,GAAAC,CAAA,CAAAuD,QAAA,SAAAtB,CAAA,IAAAvB,CAAA,IAAAV,CAAA,CAAAsD,MAAA,YAAAtD,CAAA,CAAA2B,GAAA,OAAAkC,SAAA,sCAAA7D,CAAA,CAAAuD,QAAA,SAAAtB,CAAA,cAAAgC,aAAAlE,CAAA,QAAAD,CAAA,KAAAoE,MAAA,EAAAnE,CAAA,YAAAA,CAAA,KAAAD,CAAA,CAAAqE,QAAA,GAAApE,CAAA,WAAAA,CAAA,KAAAD,CAAA,CAAAsE,UAAA,GAAArE,CAAA,KAAAD,CAAA,CAAAuE,QAAA,GAAAtE,CAAA,WAAAuE,UAAA,CAAAC,IAAA,CAAAzE,CAAA,cAAA0E,cAAAzE,CAAA,QAAAD,CAAA,GAAAC,CAAA,CAAA0E,UAAA,QAAA3E,CAAA,CAAA4B,IAAA,oBAAA5B,CAAA,CAAA6B,GAAA,EAAA5B,CAAA,CAAA0E,UAAA,GAAA3E,CAAA,aAAAyB,QAAAxB,CAAA,SAAAuE,UAAA,MAAAJ,MAAA,aAAAnE,CAAA,CAAA4C,OAAA,CAAAsB,YAAA,cAAAS,KAAA,iBAAAlC,OAAA1C,CAAA,QAAAA,CAAA,WAAAA,CAAA,QAAAE,CAAA,GAAAF,CAAA,CAAAY,CAAA,OAAAV,CAAA,SAAAA,CAAA,CAAA4B,IAAA,CAAA9B,CAAA,4BAAAA,CAAA,CAAAiE,IAAA,SAAAjE,CAAA,OAAA6E,KAAA,CAAA7E,CAAA,CAAA8E,MAAA,SAAAvE,CAAA,OAAAG,CAAA,YAAAuD,KAAA,aAAA1D,CAAA,GAAAP,CAAA,CAAA8E,MAAA,OAAAzE,CAAA,CAAAyB,IAAA,CAAA9B,CAAA,EAAAO,CAAA,UAAA0D,IAAA,CAAAxD,KAAA,GAAAT,CAAA,CAAAO,CAAA,GAAA0D,IAAA,CAAAV,IAAA,OAAAU,IAAA,SAAAA,IAAA,CAAAxD,KAAA,GAAAR,CAAA,EAAAgE,IAAA,CAAAV,IAAA,OAAAU,IAAA,YAAAvD,CAAA,CAAAuD,IAAA,GAAAvD,CAAA,gBAAAqD,SAAA,CAAAd,OAAA,CAAAjD,CAAA,kCAAAoC,iBAAA,CAAAhC,SAAA,GAAAiC,0BAAA,EAAA9B,CAAA,CAAAoC,CAAA,mBAAAlC,KAAA,EAAA4B,0BAAA,EAAAjB,YAAA,SAAAb,CAAA,CAAA8B,0BAAA,mBAAA5B,KAAA,EAAA2B,iBAAA,EAAAhB,YAAA,SAAAgB,iBAAA,CAAA2C,WAAA,GAAA7D,MAAA,CAAAmB,0BAAA,EAAArB,CAAA,wBAAAhB,CAAA,CAAAgF,mBAAA,aAAA/E,CAAA,QAAAD,CAAA,wBAAAC,CAAA,IAAAA,CAAA,CAAAgF,WAAA,WAAAjF,CAAA,KAAAA,CAAA,KAAAoC,iBAAA,6BAAApC,CAAA,CAAA+E,WAAA,IAAA/E,CAAA,CAAAkF,IAAA,OAAAlF,CAAA,CAAAmF,IAAA,aAAAlF,CAAA,WAAAE,MAAA,CAAAiF,cAAA,GAAAjF,MAAA,CAAAiF,cAAA,CAAAnF,CAAA,EAAAoC,0BAAA,KAAApC,CAAA,CAAAoF,SAAA,GAAAhD,0BAAA,EAAAnB,MAAA,CAAAjB,CAAA,EAAAe,CAAA,yBAAAf,CAAA,CAAAG,SAAA,GAAAD,MAAA,CAAAqB,MAAA,CAAAmB,CAAA,GAAA1C,CAAA,KAAAD,CAAA,CAAAsF,KAAA,aAAArF,CAAA,aAAAkD,OAAA,EAAAlD,CAAA,OAAA2C,qBAAA,CAAAG,aAAA,CAAA3C,SAAA,GAAAc,MAAA,CAAA6B,aAAA,CAAA3C,SAAA,EAAAU,CAAA,iCAAAd,CAAA,CAAA+C,aAAA,GAAAA,aAAA,EAAA/C,CAAA,CAAAuF,KAAA,aAAAtF,CAAA,EAAAC,CAAA,EAAAG,CAAA,EAAAE,CAAA,EAAAG,CAAA,eAAAA,CAAA,KAAAA,CAAA,GAAA8E,OAAA,OAAA5E,CAAA,OAAAmC,aAAA,CAAAzB,IAAA,CAAArB,CAAA,EAAAC,CAAA,EAAAG,CAAA,EAAAE,CAAA,GAAAG,CAAA,UAAAV,CAAA,CAAAgF,mBAAA,CAAA9E,CAAA,IAAAU,CAAA,GAAAA,CAAA,CAAAqD,IAAA,GAAAb,IAAA,WAAAnD,CAAA,WAAAA,CAAA,CAAAsD,IAAA,GAAAtD,CAAA,CAAAQ,KAAA,GAAAG,CAAA,CAAAqD,IAAA,WAAArB,qBAAA,CAAAD,CAAA,GAAAzB,MAAA,CAAAyB,CAAA,EAAA3B,CAAA,gBAAAE,MAAA,CAAAyB,CAAA,EAAA/B,CAAA,iCAAAM,MAAA,CAAAyB,CAAA,6DAAA3C,CAAA,CAAAyF,IAAA,aAAAxF,CAAA,QAAAD,CAAA,GAAAG,MAAA,CAAAF,CAAA,GAAAC,CAAA,gBAAAG,CAAA,IAAAL,CAAA,EAAAE,CAAA,CAAAuE,IAAA,CAAApE,CAAA,UAAAH,CAAA,CAAAwF,OAAA,aAAAzB,KAAA,WAAA/D,CAAA,CAAA4E,MAAA,SAAA7E,CAAA,GAAAC,CAAA,CAAAyF,GAAA,QAAA1F,CAAA,IAAAD,CAAA,SAAAiE,IAAA,CAAAxD,KAAA,GAAAR,CAAA,EAAAgE,IAAA,CAAAV,IAAA,OAAAU,IAAA,WAAAA,IAAA,CAAAV,IAAA,OAAAU,IAAA,QAAAjE,CAAA,CAAA0C,MAAA,GAAAA,MAAA,EAAAjB,OAAA,CAAArB,SAAA,KAAA6E,WAAA,EAAAxD,OAAA,EAAAmD,KAAA,WAAAA,MAAA5E,CAAA,aAAA4F,IAAA,WAAA3B,IAAA,WAAAN,IAAA,QAAAC,KAAA,GAAA3D,CAAA,OAAAsD,IAAA,YAAAE,QAAA,cAAAD,MAAA,gBAAA3B,GAAA,GAAA5B,CAAA,OAAAuE,UAAA,CAAA3B,OAAA,CAAA6B,aAAA,IAAA1E,CAAA,WAAAE,CAAA,kBAAAA,CAAA,CAAA2F,MAAA,OAAAxF,CAAA,CAAAyB,IAAA,OAAA5B,CAAA,MAAA2E,KAAA,EAAA3E,CAAA,CAAA4F,KAAA,cAAA5F,CAAA,IAAAD,CAAA,MAAA8F,IAAA,WAAAA,KAAA,SAAAxC,IAAA,WAAAtD,CAAA,QAAAuE,UAAA,IAAAG,UAAA,kBAAA1E,CAAA,CAAA2B,IAAA,QAAA3B,CAAA,CAAA4B,GAAA,cAAAmE,IAAA,KAAAnC,iBAAA,WAAAA,kBAAA7D,CAAA,aAAAuD,IAAA,QAAAvD,CAAA,MAAAE,CAAA,kBAAA+F,OAAA5F,CAAA,EAAAE,CAAA,WAAAK,CAAA,CAAAgB,IAAA,YAAAhB,CAAA,CAAAiB,GAAA,GAAA7B,CAAA,EAAAE,CAAA,CAAA+D,IAAA,GAAA5D,CAAA,EAAAE,CAAA,KAAAL,CAAA,CAAAsD,MAAA,WAAAtD,CAAA,CAAA2B,GAAA,GAAA5B,CAAA,KAAAM,CAAA,aAAAA,CAAA,QAAAiE,UAAA,CAAAM,MAAA,MAAAvE,CAAA,SAAAA,CAAA,QAAAG,CAAA,QAAA8D,UAAA,CAAAjE,CAAA,GAAAK,CAAA,GAAAF,CAAA,CAAAiE,UAAA,iBAAAjE,CAAA,CAAA0D,MAAA,SAAA6B,MAAA,aAAAvF,CAAA,CAAA0D,MAAA,SAAAwB,IAAA,QAAA9E,CAAA,GAAAT,CAAA,CAAAyB,IAAA,CAAApB,CAAA,eAAAM,CAAA,GAAAX,CAAA,CAAAyB,IAAA,CAAApB,CAAA,qBAAAI,CAAA,IAAAE,CAAA,aAAA4E,IAAA,GAAAlF,CAAA,CAAA2D,QAAA,SAAA4B,MAAA,CAAAvF,CAAA,CAAA2D,QAAA,gBAAAuB,IAAA,GAAAlF,CAAA,CAAA4D,UAAA,SAAA2B,MAAA,CAAAvF,CAAA,CAAA4D,UAAA,cAAAxD,CAAA,aAAA8E,IAAA,GAAAlF,CAAA,CAAA2D,QAAA,SAAA4B,MAAA,CAAAvF,CAAA,CAAA2D,QAAA,qBAAArD,CAAA,QAAAsC,KAAA,qDAAAsC,IAAA,GAAAlF,CAAA,CAAA4D,UAAA,SAAA2B,MAAA,CAAAvF,CAAA,CAAA4D,UAAA,YAAAR,MAAA,WAAAA,OAAA7D,CAAA,EAAAD,CAAA,aAAAE,CAAA,QAAAsE,UAAA,CAAAM,MAAA,MAAA5E,CAAA,SAAAA,CAAA,QAAAK,CAAA,QAAAiE,UAAA,CAAAtE,CAAA,OAAAK,CAAA,CAAA6D,MAAA,SAAAwB,IAAA,IAAAvF,CAAA,CAAAyB,IAAA,CAAAvB,CAAA,wBAAAqF,IAAA,GAAArF,CAAA,CAAA+D,UAAA,QAAA5D,CAAA,GAAAH,CAAA,aAAAG,CAAA,iBAAAT,CAAA,mBAAAA,CAAA,KAAAS,CAAA,CAAA0D,MAAA,IAAApE,CAAA,IAAAA,CAAA,IAAAU,CAAA,CAAA4D,UAAA,KAAA5D,CAAA,cAAAE,CAAA,GAAAF,CAAA,GAAAA,CAAA,CAAAiE,UAAA,cAAA/D,CAAA,CAAAgB,IAAA,GAAA3B,CAAA,EAAAW,CAAA,CAAAiB,GAAA,GAAA7B,CAAA,EAAAU,CAAA,SAAA8C,MAAA,gBAAAS,IAAA,GAAAvD,CAAA,CAAA4D,UAAA,EAAAnC,CAAA,SAAA+D,QAAA,CAAAtF,CAAA,MAAAsF,QAAA,WAAAA,SAAAjG,CAAA,EAAAD,CAAA,oBAAAC,CAAA,CAAA2B,IAAA,QAAA3B,CAAA,CAAA4B,GAAA,qBAAA5B,CAAA,CAAA2B,IAAA,mBAAA3B,CAAA,CAAA2B,IAAA,QAAAqC,IAAA,GAAAhE,CAAA,CAAA4B,GAAA,gBAAA5B,CAAA,CAAA2B,IAAA,SAAAoE,IAAA,QAAAnE,GAAA,GAAA5B,CAAA,CAAA4B,GAAA,OAAA2B,MAAA,kBAAAS,IAAA,yBAAAhE,CAAA,CAAA2B,IAAA,IAAA5B,CAAA,UAAAiE,IAAA,GAAAjE,CAAA,GAAAmC,CAAA,KAAAgE,MAAA,WAAAA,OAAAlG,CAAA,aAAAD,CAAA,QAAAwE,UAAA,CAAAM,MAAA,MAAA9E,CAAA,SAAAA,CAAA,QAAAE,CAAA,QAAAsE,UAAA,CAAAxE,CAAA,OAAAE,CAAA,CAAAoE,UAAA,KAAArE,CAAA,cAAAiG,QAAA,CAAAhG,CAAA,CAAAyE,UAAA,EAAAzE,CAAA,CAAAqE,QAAA,GAAAG,aAAA,CAAAxE,CAAA,GAAAiC,CAAA,yBAAAiE,OAAAnG,CAAA,aAAAD,CAAA,QAAAwE,UAAA,CAAAM,MAAA,MAAA9E,CAAA,SAAAA,CAAA,QAAAE,CAAA,QAAAsE,UAAA,CAAAxE,CAAA,OAAAE,CAAA,CAAAkE,MAAA,KAAAnE,CAAA,QAAAI,CAAA,GAAAH,CAAA,CAAAyE,UAAA,kBAAAtE,CAAA,CAAAuB,IAAA,QAAArB,CAAA,GAAAF,CAAA,CAAAwB,GAAA,EAAA6C,aAAA,CAAAxE,CAAA,YAAAK,CAAA,YAAA+C,KAAA,8BAAA+C,aAAA,WAAAA,cAAArG,CAAA,EAAAE,CAAA,EAAAG,CAAA,gBAAAoD,QAAA,KAAA5C,QAAA,EAAA6B,MAAA,CAAA1C,CAAA,GAAAgE,UAAA,EAAA9D,CAAA,EAAAgE,OAAA,EAAA7D,CAAA,oBAAAmD,MAAA,UAAA3B,GAAA,GAAA5B,CAAA,GAAAkC,CAAA,OAAAnC,CAAA;AAAA,SAAAsG,mBAAAjG,CAAA,EAAAJ,CAAA,EAAAD,CAAA,EAAAE,CAAA,EAAAK,CAAA,EAAAK,CAAA,EAAAE,CAAA,cAAAJ,CAAA,GAAAL,CAAA,CAAAO,CAAA,EAAAE,CAAA,GAAAE,CAAA,GAAAN,CAAA,CAAAD,KAAA,WAAAJ,CAAA,gBAAAL,CAAA,CAAAK,CAAA,KAAAK,CAAA,CAAA6C,IAAA,GAAAtD,CAAA,CAAAe,CAAA,IAAAwE,OAAA,CAAAtC,OAAA,CAAAlC,CAAA,EAAAoC,IAAA,CAAAlD,CAAA,EAAAK,CAAA;AAAA,SAAAgG,kBAAAlG,CAAA,6BAAAJ,CAAA,SAAAD,CAAA,GAAAwG,SAAA,aAAAhB,OAAA,WAAAtF,CAAA,EAAAK,CAAA,QAAAK,CAAA,GAAAP,CAAA,CAAAoG,KAAA,CAAAxG,CAAA,EAAAD,CAAA,YAAA0G,MAAArG,CAAA,IAAAiG,kBAAA,CAAA1F,CAAA,EAAAV,CAAA,EAAAK,CAAA,EAAAmG,KAAA,EAAAC,MAAA,UAAAtG,CAAA,cAAAsG,OAAAtG,CAAA,IAAAiG,kBAAA,CAAA1F,CAAA,EAAAV,CAAA,EAAAK,CAAA,EAAAmG,KAAA,EAAAC,MAAA,WAAAtG,CAAA,KAAAqG,KAAA;AAAA,SAAAE,eAAA1G,CAAA,QAAAG,CAAA,EAAAJ,CAAA,EAAAM,CAAA,EAAAP,CAAA,iCAAAW,MAAA,KAAAV,CAAA,GAAAU,MAAA,CAAAI,aAAA,EAAAR,CAAA,GAAAI,MAAA,CAAAE,QAAA,GAAAb,CAAA,WAAAC,CAAA,aAAAI,CAAA,GAAAH,CAAA,CAAAD,CAAA,WAAAI,CAAA,CAAAyB,IAAA,CAAA5B,CAAA,OAAAK,CAAA,aAAAF,CAAA,GAAAH,CAAA,CAAAK,CAAA,eAAAsG,qBAAA,CAAAxG,CAAA,CAAAyB,IAAA,CAAA5B,CAAA,IAAAD,CAAA,sBAAAM,CAAA,6BAAAwD,SAAA;AAAA,SAAA8C,sBAAA3G,CAAA,aAAA4G,kCAAA5G,CAAA,QAAAC,MAAA,CAAAD,CAAA,MAAAA,CAAA,SAAAsF,OAAA,CAAAuB,MAAA,KAAAhD,SAAA,CAAA7D,CAAA,+BAAAG,CAAA,GAAAH,CAAA,CAAAqD,IAAA,SAAAiC,OAAA,CAAAtC,OAAA,CAAAhD,CAAA,CAAAO,KAAA,EAAA2C,IAAA,WAAAlD,CAAA,aAAAO,KAAA,EAAAP,CAAA,EAAAqD,IAAA,EAAAlD,CAAA,iBAAAwG,qBAAA,YAAAA,sBAAA3G,CAAA,SAAAgC,CAAA,GAAAhC,CAAA,OAAAG,CAAA,GAAAH,CAAA,CAAA+D,IAAA,KAAA4C,qBAAA,CAAAzG,SAAA,KAAA8B,CAAA,QAAA7B,CAAA,QAAA4D,IAAA,WAAAA,KAAA,WAAA6C,iCAAA,MAAAzG,CAAA,CAAAoG,KAAA,MAAAvE,CAAA,EAAAsE,SAAA,0BAAAQ,QAAA9G,CAAA,QAAAG,CAAA,QAAA6B,CAAA,8BAAA7B,CAAA,GAAAmF,OAAA,CAAAtC,OAAA,GAAAzC,KAAA,EAAAP,CAAA,EAAAqD,IAAA,UAAAuD,iCAAA,CAAAzG,CAAA,CAAAoG,KAAA,MAAAvE,CAAA,EAAAsE,SAAA,yBAAAG,OAAAzG,CAAA,QAAAG,CAAA,QAAA6B,CAAA,8BAAA7B,CAAA,GAAAmF,OAAA,CAAAuB,MAAA,CAAA7G,CAAA,IAAA4G,iCAAA,CAAAzG,CAAA,CAAAoG,KAAA,MAAAvE,CAAA,EAAAsE,SAAA,aAAAK,qBAAA,CAAA3G,CAAA;AADsC;AACU;AACA;AACV;AACG;AACG;AACb;AACoB;;AAEnD;AACA,IAAMwH,IAAI,GAAG,MAAMT,oDAAY,CAAC;EAC9BU,UAAU,EAAE,CAACT,8DAAU,CAAC,CAAC,CAAC;EAC1BU,oBAAoB,EAAE,CAACT,8DAAK,CAAC,CAAC,CAAC;EAC/BU,YAAY,EAAE,CAACT,oDAAK,CAAC,CAAC,CAAC;EACvBU,QAAQ,EAAE;IACRC,GAAG,EAAEV,uDAAM,CAAC,CAAC;IACbC,QAAQ,EAAEA,0DAAQ,CAAC,CAAC,CAAG;EACzB;AACF,CAAC,CAAC;;AAGF;AACA,MAAMI,IAAI,CAACM,KAAK,CAAC,CAAC;AAClBC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;AAClCD,OAAO,CAACC,GAAG,CAAC,cAAc,EAAER,IAAI,CAACI,QAAQ,CAACC,GAAG,CAAC;;AAE9C;AACAL,IAAI,CAACS,gBAAgB,CAAC,cAAc,EAAE,UAACC,GAAG,EAAK;EAC7C,IAAMC,MAAM,GAAGD,GAAG,CAACE,MAAM;EACzBL,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEG,MAAM,CAACZ,QAAQ,CAAC,CAAC,CAAC;AACjD,CAAC,CAAC;AAEFC,IAAI,CAACS,gBAAgB,CAAC,iBAAiB,EAAE,UAACC,GAAG,EAAK;EAChD,IAAMC,MAAM,GAAGD,GAAG,CAACE,MAAM;EACzBL,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEG,MAAM,CAACZ,QAAQ,CAAC,CAAC,CAAC;AACtD,CAAC,CAAC;;AAEF;AACAc,WAAW,CAAC,YAAM;EAChBN,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAER,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACS,YAAY,CAACC,KAAK,CAAC;AAC3E,CAAC,EAAE,IAAI,CAAC;;AAER;AACA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAA,EAAS;EAC/BT,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAER,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACS,YAAY,CAAC;EACjEP,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAER,IAAI,CAACiB,QAAQ,CAAC,CAAC,CAAC;AAClD,CAAC;AAEDJ,WAAW,CAACG,kBAAkB,EAAE,KAAK,CAAC,CAAC,CAAC;;AAExC,IAAME,aAAa;EAAA,IAAAC,IAAA,GAAAtC,iBAAA,cAAAxG,mBAAA,GAAAoF,IAAA,CAAG,SAAA2D,QAAOC,MAAM;IAAA,IAAAC,OAAA,EAAAC,YAAA;IAAA,OAAAlJ,mBAAA,GAAAuB,IAAA,UAAA4H,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAvD,IAAA,GAAAuD,QAAA,CAAAlF,IAAA;QAAA;UACjCgE,OAAO,CAACC,GAAG,CAAC,cAAc,EAAER,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACqB,OAAO,CAAC;UAChDJ,OAAO,aAAAK,MAAA,CAAaN,MAAM;UAChCd,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAER,IAAI,CAACW,MAAM,CAACZ,QAAQ,CAAC,CAAC,CAAC;UAAC0B,QAAA,CAAAlF,IAAA;UAAA,OACpDyD,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACuB,OAAO,CAACN,OAAO,CAAC;QAAA;UACxCf,OAAO,CAACC,GAAG,SAAAmB,MAAA,CAASN,MAAM,2BAAAM,MAAA,CAAwBL,OAAO,CAAE,CAAC;UAC5Df,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;;UAE3D;UAAAiB,QAAA,CAAAvD,IAAA;UAAAuD,QAAA,CAAAlF,IAAA;UAAA,OAE6ByD,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACwB,eAAe,CAACP,OAAO,CAAC;QAAA;UAA/DC,YAAY,GAAAE,QAAA,CAAAxF,IAAA;UAClBsE,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEe,YAAY,CAAC;UAACE,QAAA,CAAAlF,IAAA;UAAA;QAAA;UAAAkF,QAAA,CAAAvD,IAAA;UAAAuD,QAAA,CAAAK,EAAA,GAAAL,QAAA;UAE5ClB,OAAO,CAACwB,KAAK,CAAC,8BAA8B,EAAAN,QAAA,CAAAK,EAAO,CAAC;QAAC;QAAA;UAAA,OAAAL,QAAA,CAAApD,IAAA;MAAA;IAAA,GAAA+C,OAAA;EAAA,CAExD;EAAA,gBAfKF,aAAaA,CAAAc,EAAA;IAAA,OAAAb,IAAA,CAAApC,KAAA,OAAAD,SAAA;EAAA;AAAA,GAelB;;AAID;AACA,IAAMmD,QAAQ;EAAA,IAAAC,KAAA,GAAArD,iBAAA,cAAAxG,mBAAA,GAAAoF,IAAA,CAAG,SAAA0E,SAAOd,MAAM;IAAA,IAAAC,OAAA,EAAAP,KAAA;IAAA,OAAA1I,mBAAA,GAAAuB,IAAA,UAAAwI,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAnE,IAAA,GAAAmE,SAAA,CAAA9F,IAAA;QAAA;UAC5BgE,OAAO,CAACC,GAAG,CAAC,cAAc,EAAER,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACqB,OAAO,CAAC;UAChDJ,OAAO,aAAAK,MAAA,CAAaN,MAAM;UAChCd,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAER,IAAI,CAACW,MAAM,CAACZ,QAAQ,CAAC,CAAC,CAAC;UACzDQ,OAAO,CAACC,GAAG,+BAAAmB,MAAA,CAA+BL,OAAO,QAAK,CAAC;UAACe,SAAA,CAAA9F,IAAA;UAAA,OAElD,IAAIuB,OAAO,CAAC,UAAAtC,OAAO;YAAA,OAAI8G,UAAU,CAAC;cAAA,OAAM/B,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;YAAA,GAAE,IAAI,CAAC;UAAA,EAAC;QAAA;UAAA6B,SAAA,CAAAnE,IAAA;UAAAmE,SAAA,CAAA9F,IAAA;UAAA,OAGpDyD,IAAI,CAACI,QAAQ,CAACC,GAAG,CAACkC,aAAa,CAACjB,OAAO,CAAC;QAAA;UAAtDP,KAAK,GAAAsB,SAAA,CAAApG,IAAA;UAAA,MACP,CAACuG,KAAK,CAACC,OAAO,CAAC1B,KAAK,CAAC,IAAIA,KAAK,CAAC3D,MAAM,KAAK,CAAC;YAAAiF,SAAA,CAAA9F,IAAA;YAAA;UAAA;UAC7CgE,OAAO,CAACwB,KAAK,4BAAAJ,MAAA,CAA4BN,MAAM,CAAE,CAAC;UAAC,OAAAgB,SAAA,CAAAjG,MAAA,WAC5C,EAAE;QAAA;UAGXmE,OAAO,CAACC,GAAG,UAAAmB,MAAA,CAAUZ,KAAK,CAAC3D,MAAM,sBAAAuE,MAAA,CAAmBN,MAAM,CAAE,CAAC;UAC7DN,KAAK,CAAC5F,OAAO,CAAC,UAAAuH,IAAI,EAAI;YACpBnC,OAAO,CAACC,GAAG,qBAAAmB,MAAA,CAAqBe,IAAI,CAACC,EAAE,CAAC5C,QAAQ,CAAC,CAAC,CAAE,CAAC;UACvD,CAAC,CAAC;UAAC,OAAAsC,SAAA,CAAAjG,MAAA,WAEI2E,KAAK;QAAA;UAAAsB,SAAA,CAAAnE,IAAA;UAAAmE,SAAA,CAAAP,EAAA,GAAAO,SAAA;UAEZ9B,OAAO,CAACwB,KAAK,CAAC,8BAA8B,EAAAM,SAAA,CAAAP,EAAO,CAAC;UAAC,OAAAO,SAAA,CAAAjG,MAAA,WAC9C,EAAE;QAAA;QAAA;UAAA,OAAAiG,SAAA,CAAAhE,IAAA;MAAA;IAAA,GAAA8D,QAAA;EAAA,CAEZ;EAAA,gBAzBKF,QAAQA,CAAAW,GAAA;IAAA,OAAAV,KAAA,CAAAnD,KAAA,OAAAD,SAAA;EAAA;AAAA,GAyBb;;AAED;AACA,IAAM+D,UAAU;EAAA,IAAAC,KAAA,GAAAjE,iBAAA,cAAAxG,mBAAA,GAAAoF,IAAA,CAAG,SAAAsF,SAAAC,KAAA;IAAA,IAAAC,MAAA;IAAA,OAAA5K,mBAAA,GAAAuB,IAAA,UAAAsJ,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAjF,IAAA,GAAAiF,SAAA,CAAA5G,IAAA;QAAA;UAAS0G,MAAM,GAAAD,KAAA,CAANC,MAAM;UAAAE,SAAA,CAAA5G,IAAA;UAAA,OAC1BsD,6CAAI,CACRoD,MAAM,CAACG,MAAM;YAAA,IAAAC,KAAA,GAAAxE,iBAAA,cAAAxG,mBAAA,GAAAoF,IAAA,CACb,SAAA6F,SAAgBF,MAAM;cAAA,IAAAG,yBAAA,EAAAC,iBAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,GAAA,EAAAC,OAAA,EAAAC,EAAA;cAAA,OAAAzL,mBAAA,GAAAuB,IAAA,UAAAmK,UAAAC,SAAA;gBAAA,kBAAAA,SAAA,CAAA9F,IAAA,GAAA8F,SAAA,CAAAzH,IAAA;kBAAA;oBAAAgH,yBAAA;oBAAAC,iBAAA;oBAAAQ,SAAA,CAAA9F,IAAA;oBAAAwF,SAAA,GAAAxE,cAAA,CACIkE,MAAM;kBAAA;oBAAAY,SAAA,CAAAzH,IAAA;oBAAA,OAAAmH,SAAA,CAAAnH,IAAA;kBAAA;oBAAA,MAAAgH,yBAAA,KAAAI,KAAA,GAAAK,SAAA,CAAA/H,IAAA,EAAAJ,IAAA;sBAAAmI,SAAA,CAAAzH,IAAA;sBAAA;oBAAA;oBAAbqH,GAAG,GAAAD,KAAA,CAAA5K,KAAA;oBAClBwH,OAAO,CAACC,GAAG,sBAAAmB,MAAA,CAAsB5B,qDAAQ,CAAC6D,GAAG,CAAC,CAAE,CAAC;oBAC3CC,OAAO,GAAGI,QAAQ,CAACC,cAAc,CAAC,SAAS,CAAC;oBAC5CJ,EAAE,GAAGG,QAAQ,CAACE,aAAa,CAAC,IAAI,CAAC;oBACvCL,EAAE,CAACM,WAAW,YAAAzC,MAAA,CAAY5B,qDAAQ,CAAC6D,GAAG,CAAC,CAAE;oBACzCC,OAAO,CAACQ,WAAW,CAACP,EAAE,CAAC;kBAAC;oBAAAP,yBAAA;oBAAAS,SAAA,CAAAzH,IAAA;oBAAA;kBAAA;oBAAAyH,SAAA,CAAAzH,IAAA;oBAAA;kBAAA;oBAAAyH,SAAA,CAAA9F,IAAA;oBAAA8F,SAAA,CAAAlC,EAAA,GAAAkC,SAAA;oBAAAR,iBAAA;oBAAAC,cAAA,GAAAO,SAAA,CAAAlC,EAAA;kBAAA;oBAAAkC,SAAA,CAAA9F,IAAA;oBAAA8F,SAAA,CAAA9F,IAAA;oBAAA,MAAAqF,yBAAA,IAAAG,SAAA;sBAAAM,SAAA,CAAAzH,IAAA;sBAAA;oBAAA;oBAAAyH,SAAA,CAAAzH,IAAA;oBAAA,OAAAmH,SAAA;kBAAA;oBAAAM,SAAA,CAAA9F,IAAA;oBAAA,KAAAsF,iBAAA;sBAAAQ,SAAA,CAAAzH,IAAA;sBAAA;oBAAA;oBAAA,MAAAkH,cAAA;kBAAA;oBAAA,OAAAO,SAAA,CAAAvF,MAAA;kBAAA;oBAAA,OAAAuF,SAAA,CAAAvF,MAAA;kBAAA;kBAAA;oBAAA,OAAAuF,SAAA,CAAA3F,IAAA;gBAAA;cAAA,GAAAiF,QAAA;YAAA,CAE3B;YAAA,iBAAAgB,GAAA;cAAA,OAAAjB,KAAA,CAAAtE,KAAA,OAAAD,SAAA;YAAA;UAAA,GACH,CAAC;QAAA;QAAA;UAAA,OAAAqE,SAAA,CAAA9E,IAAA;MAAA;IAAA,GAAA0E,QAAA;EAAA,CACF;EAAA,gBAbKF,UAAUA,CAAA0B,GAAA;IAAA,OAAAzB,KAAA,CAAA/D,KAAA,OAAAD,SAAA;EAAA;AAAA,GAaf;;AAED;AACAkB,IAAI,CAACzB,MAAM,CAAC,aAAa,EAAEsE,UAAU,CAAC;;AAEtC;AACA,IAAM2B,iBAAiB;EAAA,IAAAC,KAAA,GAAA5F,iBAAA,cAAAxG,mBAAA,GAAAoF,IAAA,CAAG,SAAAiH,SAAO/D,MAAM,EAAEgE,OAAO;IAAA,IAAAC,qBAAA,EAAA3B,MAAA;IAAA,OAAA5K,mBAAA,GAAAuB,IAAA,UAAAiL,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAA5G,IAAA,GAAA4G,SAAA,CAAAvI,IAAA;QAAA;UAAAuI,SAAA,CAAAvI,IAAA;UAAA,OACrByD,IAAI,CAAC+E,YAAY,CAACpE,MAAM,EAAE,aAAa,CAAC;QAAA;UAAAiE,qBAAA,GAAAE,SAAA,CAAA7I,IAAA;UAAzDgH,MAAM,GAAA2B,qBAAA,CAAN3B,MAAM;UAAA6B,SAAA,CAAAvI,IAAA;UAAA,OACRsD,6CAAI,CAAC,CAACC,uDAAU,CAAC6E,OAAO,CAAC,CAAC,EAAE1B,MAAM,CAAC+B,IAAI,CAAC;QAAA;UAC9CzE,OAAO,CAACC,GAAG,oBAAAmB,MAAA,CAAoBhB,MAAM,CAAE,CAAC;QAAC;QAAA;UAAA,OAAAmE,SAAA,CAAAzG,IAAA;MAAA;IAAA,GAAAqG,QAAA;EAAA,CAC1C;EAAA,gBAJKF,iBAAiBA,CAAAS,GAAA,EAAAC,GAAA;IAAA,OAAAT,KAAA,CAAA1F,KAAA,OAAAD,SAAA;EAAA;AAAA,GAItB;;AAED;AACA,IAAMqG,kBAAkB;EAAA,IAAAC,KAAA,GAAAvG,iBAAA,cAAAxG,mBAAA,GAAAoF,IAAA,CAAG,SAAA4H,SAAOhE,MAAM,EAAEsD,OAAO;IAAA,IAAA5D,KAAA;IAAA,OAAA1I,mBAAA,GAAAuB,IAAA,UAAA0L,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAArH,IAAA,GAAAqH,SAAA,CAAAhJ,IAAA;QAAA;UAAAgJ,SAAA,CAAAhJ,IAAA;UAAA,OAC3B0F,QAAQ,CAACZ,MAAM,CAAC;QAAA;UAA9BN,KAAK,GAAAwE,SAAA,CAAAtJ,IAAA;UAAA,MACP8E,KAAK,CAAC3D,MAAM,GAAG,CAAC;YAAAmI,SAAA,CAAAhJ,IAAA;YAAA;UAAA;UAAAgJ,SAAA,CAAAhJ,IAAA;UAAA,OACZiI,iBAAiB,CAACzD,KAAK,CAAC,CAAC,CAAC,CAAC4B,EAAE,EAAEgC,OAAO,CAAC;QAAA;QAAA;UAAA,OAAAY,SAAA,CAAAlH,IAAA;MAAA;IAAA,GAAAgH,QAAA;EAAA,CAEhD;EAAA,gBALKF,kBAAkBA,CAAAK,GAAA,EAAAC,GAAA;IAAA,OAAAL,KAAA,CAAArG,KAAA,OAAAD,SAAA;EAAA;AAAA,GAKvB;;AAED;AACA4G,MAAM,CAACC,UAAU,GAAG,UAACtE,MAAM,EAAK;EAC9Bd,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAEa,MAAM,CAAC,CAAC,CAAE;EAClDH,aAAa,CAACG,MAAM,CAAC,CAAC,CAAE;AAC1B,CAAC;AAEDqE,MAAM,CAACzD,QAAQ,GAAG,UAACZ,MAAM,EAAK;EAC5Bd,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAEa,MAAM,CAAC,CAAC,CAAE;EAChDY,QAAQ,CAACZ,MAAM,CAAC,CAAC,CAAE;AACrB,CAAC;AAEDqE,MAAM,CAACE,WAAW,GAAG,UAACvE,MAAM,EAAEsD,OAAO,EAAK;EACxCpE,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEa,MAAM,CAAC,CAAC,CAAE;EACnDd,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEmE,OAAO,CAAC,CAAC,CAAE;EACnCQ,kBAAkB,CAAC9D,MAAM,EAAEsD,OAAO,CAAC,CAAC,CAAE;AACxC,CAAC;;;;;;;;;;;;;;;;;;;;;AClJ4B;AACE;AACJ;AACA;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,sBAAsB,oDAAK;AAC3B;AACA,sBAAsB,oDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAM;AACvB;AACA;AACA,6CAA6C,qDAAM;AACnD;AACA;AACA,4CAA4C,mDAAI;AAChD;AACA;AACA;AACA;AACA,iBAAiB,qDAAM;AACvB;AACA;AACA,iBAAiB,mDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAM;AACvB;AACA;AACA,6CAA6C,qDAAM;AACnD;AACA;AACA,4CAA4C,mDAAI;AAChD;AACA;AACA;AACA;AACA,iBAAiB,qDAAM;AACvB;AACA;AACA,iBAAiB,mDAAI;AACrB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClH+B;AACxB;AACP;AACA,WAAW,qCAAO;AAClB;AACO;AACP;AACA,WAAW,qCAAO;AAClB;AACO;AACP;AACA,WAAW,qCAAO;AAClB;AACO;AACP;AACA,WAAW,qCAAO;AAClB;AACO;AACP;AACA,WAAW,qCAAO;AAClB;AACO;AACP;AACA,WAAW,qCAAO;AAClB;AACA;;;;;;;;;;;;;;;;;;ACzB8C;AACJ;AACJ;AAC/B,8BAA8B,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qDAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS,wDAAG;AAChC;AACA;AACA;AACA;AACA,sBAAsB,wDAAG;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrCA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEO,sBAAsB,oDAAoD,IAAI;AACrF;AACA,wBAAwB,eAAe,IAAI;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,qDAAqD,WAAW;AAChE;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA,iEAAe,KAAK,EAAC;;AAEd,wDAAwD;AAC/D;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;;;;;;ACrEqC;;AAEd;AACvB,iEAAe,sCAAY;;;;;;;;;;;;;;;;ACHpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACd6E;AACN;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,SAAS;AACxB;AACA;AACA;AACA,wBAAwB,mEAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,iBAAiB;AACjB;AACA;AACA,eAAe,+DAAkB;AACjC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,GAAG,EAAC;AACnB;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACV;AACC;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,wEAAiB;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,0DAAc;AACjD;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA,kCAAkC,0DAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA,iEAAe,KAAK,EAAC;AACrB;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,uDAAI;AACzB,YAAY,cAAc;AAC1B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACL;AACS;AAC8D;AACvG,mCAAmC;AAC1C,kBAAkB,0DAAU;AAC5B;AACA;AACA;AACA,+BAA+B,wDAAqB;AACpD;AACA,gDAAgD,gDAAa;AAC7D,gDAAgD,gDAAa;AAC7D;AACA;AACA;AACA,qCAAqC,0DAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAyB;AACvD;AACA;AACA,8BAA8B,oEAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAsB;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,0DAAc;AAChD,SAAS;AACT;AACA,6BAA6B,0DAAc;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpFA;AACuC;AACS;AACkF;AACrF;AAC7C;AACO,6BAA6B;AACpC;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA,mBAAmB,gDAAa;AAChC,2BAA2B,wDAAqB;AAChD;AACA;AACA;AACO;AACP,uBAAuB,0DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iEAAyB;AAC3D;AACA;AACA,kCAAkC,8DAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAkB;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAkB;AACxC;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,yBAAyB;AACzB;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC9HuC;AACS;AACA;AACH;AAC7C;AACA,yBAAyB,wDAAqB;AAC9C,sBAAsB,8DAAW;AACjC,IAAI,gDAAa;AACjB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,0DAAc;AAC7B;AACA;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACA;AACrC;;;;;;;;;;;;;;;AC9CO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,uDAAI;AACzB,YAAY,cAAc;AAC1B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,GAAG,EAAC;AACnB;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,qDAAQ;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,iEAAe,KAAK,EAAC;AACrB;;;;;;;;;;;;;;;;ACjFkC;AAClC;AACA;AACA;AACO;AACP,cAAc,+CAAI;AAClB,cAAc,+CAAI;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClB4B;AAC5B;AACA;AACA;AACO;AACP,qBAAqB,mDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACe,6CAA6C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAK;AAC7B,0BAA0B,mDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oCAAoC,mDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;AACxB;;;;;;;;;;;;;;;;;;AC7EuC;AACV;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAQ;AACnC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAK;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACqD;AAC9C;AACP,eAAe,mEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM,UAAU,mBAAmB;AAC5D;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACE;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA;AACA;AACA,gBAAgB,mDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAQ;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA,4BAA4B,YAAY;AACxC;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,+DAA+D,YAAY;AAC3E;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACmC;AACM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAQ;AAChC,wBAAwB,mDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,wBAAwB,mDAAQ;AAChC;AACA;AACA,cAAc,uDAAU;AACxB;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAG;AACjC;AACA,SAAS;AACT;AACA;AACA,oBAAoB,kDAAG;AACvB;AACA,KAAK;AACL;AACA,iEAAe,IAAI,EAAC;AACpB;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,IAAI,EAAC;AACpB;;;;;;;;;;;;;;;;;;ACpEA;AACiC;AACO;AACR;AACzB;AACP;AACA;AACA,gBAAgB,sDAAK;AACrB;AACA,uBAAuB,sDAAS;AAChC,WAAW,sDAAM;AACjB;AACA;;;;;;;;;;;;;;;;;ACZ6B;AACI;AACjC,iEAAe;AACf;AACA,4BAA4B,sDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAI;AAClB;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;AC/CA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,WAAW;AAC/E;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;AC1B+B;AAC/B,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,OAAO;AAClF;AACA;AACA,iBAAiB;AACjB,mCAAmC,iBAAiB;AACpD,aAAa;AACb;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;ACtC+C;AAC8B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,gCAAgC,wDAAwD,WAAW,MAAM;AACzG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,yDAAa,IAAI,kBAAkB;AAChE;AACA;AACA;AACA,2BAA2B,mEAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,yBAAyB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yEAAyE,WAAW;AACpF;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC,EAAC;AACF;;;;;;;;;;;;;;;ACrFA;AACA,iEAAe,SAAS,EAAC;AACzB;;;;;;;;;;;;;;;ACFA,cAAc;AACd;AACA,iEAAe;AACf;AACA,iBAAiB,sCAAsC,EAAE,IAAI;AAC7D;AACA;AACA;AACA;AACA,iEAAiE,cAAc,kBAAkB,cAAc;AAC/G,iBAAiB,MAAM,IAAI,KAAK,EAAE,KAAK,EAAE,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;ACpBmD;AACC;AACd;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAgB;AAC/C;AACA;AACA,gCAAgC,kEAAS,SAAS,kBAAkB;AACpE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAQ;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAS;AACrC;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,4BAA4B,kDAAkD;AAC9E;AACA;AACA;AACA;AACA;AACA,kDAAkD,kEAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,oDAAoD,kEAAS;AAC7D;AACA;AACA;AACA;AACA;AACA,sDAAsD,kEAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;ACxJO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACXwF;AACxC;AACD;AAC/C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAW;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAS,IAAI,MAAM;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAS,aAAa,wBAAwB,yBAAyB,WAAW;AAC5G;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAmB;AACnD,uBAAuB,kEAAmB;AAC1C;AACA;AACA;AACA;AACA,gCAAgC,kEAAmB;AACnD,uBAAuB,kEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvH8D;AACb;AACe;AACI;AAC3B;AACK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,8EAAe;AACpC,SAAS;AACT,uBAAuB,0EAAkB;AACzC,KAAK;AACL;AACA,wBAAwB,6DAAc;AACtC;AACA;AACO;AACP,6BAA6B,yDAAY;AACzC,+GAA+G;AAC/G,kBAAkB,wDAAS,CAAC,gDAAQ,yBAAyB,6CAAK;AAClE;AACA,uDAAuD,+DAAc;AACrE,kBAAkB,wDAAS,uCAAuC,6CAAK;AACvE;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjCuD;AACvD;AACA;AACA;AACA;AACA;AACO,mCAAmC;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,qEAAW,IAAI,aAAa;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1B4D;AACP;AACkB;AACiK;AACxO;AACA,oBAAoB,0DAAe;AACnC,oBAAoB,qEAA0B;AAC9C,yBAAyB,gEAAqB;AAC9C,sBAAsB,6DAAkB;AACxC,sBAAsB,6DAAkB;AACxC,gCAAgC,yEAA8B;AAC9D,qCAAqC,8EAAmC;AACxE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAS;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,6DAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sDAAsD,gEAAqB;AAC3E;AACA;AACA;AACA,sDAAsD,+DAAkB;AACxE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;AC9NmD;AACiB;AACnB;AACjD;AACA,oBAAoB,0DAAe;AACnC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kFAA6B;AAC/C;AACA,aAAa;AACb,SAAS;AACT;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IwC;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACgG;AAC7C;AACa;AACH;AACE;AACK;AACV;AACnB;AACe;AACuB;AACxC;AACW;AACwF;AACzF;AACI;AACnD;AACA,mBAAmB,0EAAkB;AACrC,sBAAsB,6DAAkB;AACxC,wBAAwB,gEAAqB;AAC7C,wBAAwB,iEAAsB;AAC9C,iBAAiB,uDAAY;AAC7B;AACA,iBAAiB,8EAAe;AAChC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mDAAmD,6DAAO;AAC1D;AACA;AACA;AACA,QAAQ,mEAAe;AACvB,sEAAsE;AACtE,YAAY,8DAAS;AACrB;AACA;AACA,yBAAyB,wEAAa;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,mEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,gBAAgB,qBAAqB,EAAE,6DAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,qCAAqC,gEAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAmB;AACxD;AACA;AACA;AACA,sBAAsB,yDAAS;AAC/B;AACA;AACA,iCAAiC,gEAAmB;AACpD;AACA,sCAAsC,gEAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0CAA0C,gEAAmB;AAC7D,mCAAmC,WAAW;AAC9C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAS,0CAA0C,8CAAK;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAqB,GAAG,mEAAoB;AACrF;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAS,cAAc,2DAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAkB,uCAAuC,8CAAK;AACxF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0CAA0C,6DAAqB;AAC/D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAe;AACvB;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,uBAAuB,kEAAS;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,yDAAS,uBAAuB,8CAAK;AAC/D;AACA;AACA,0BAA0B,yDAAS,uDAAuD,8CAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,WAAW;AACzF;AACA;AACA,qCAAqC,8CAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,WAAW;AAC5G;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qCAAqC,8CAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAiB;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAS,4CAA4C,8CAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAS,kEAAkE,8CAAK;AACtG;AACA,+GAA+G,WAAW;AAC1H,6GAA6G,WAAW;AACxH;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAO;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtX0D;AACP;AACa;AACP;AACL;AACgB;AACd;AACjB;AACW;AACN;AACgB;AACqS;AACnT;AACrC;AACP;AACA,oBAAoB,0DAAe;AACnC,oBAAoB,0DAAe;AACnC,gCAAgC,uEAA4B;AAC5D,mCAAmC,2EAAgC;AACnE,yBAAyB,gEAAqB;AAC9C,sBAAsB,6DAAkB;AACxC,4BAA4B,qEAA0B;AACtD,gCAAgC,yEAA8B;AAC9D,qCAAqC,8EAAmC;AACxE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,sBAAsB,wDAAS,0EAA0E,6CAAK;AAC9G;AACA;AACA;AACA;AACA,+BAA+B,6DAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kEAAS;AAC3D,gDAAgD,kEAAS;AACzD;AACA;AACA;AACA,gDAAgD,mEAAW;AAC3D;AACA;AACA,SAAS;AACT;AACA,4BAA4B,mDAAQ;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oCAAoC,oEAAgB;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,6BAA6B,sDAAS;AACtC,iDAAiD,2EAAkB;AACnE,uDAAuD,6DAAkB;AACzE,2DAA2D,gEAAqB;AAChF,2DAA2D,iEAAsB;AACjF,6CAA6C,uDAAY;AACzD;AACA,yBAAyB,8EAAe;AACxC,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB,EAAE,kCAAkC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB,EAAE,kCAAkC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0DAAU;AACvD,qBAAqB;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4DAA4D,+BAA+B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,sBAAsB,wDAAS,gBAAgB,6CAAK;AACpD;AACA;AACA,gBAAgB,SAAS,EAAE,6DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kEAAS;AAC3E;AACA,SAAS;AACT;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5ZoD;AACpD;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,8DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrB6C;AACW;AACS;AACrB;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,4BAA4B,uCAAuC,GAAG,cAAc,GAAG,iBAAiB;AACxG;AACA;AACA,2BAA2B,2EAAe;AAC1C,sCAAsC;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK,kEAAmB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB,mCAAmC,0DAAU;AAC7C;AACA;AACA,qCAAqC,0DAAW;AAChD;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtFiF;AACjF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAA8D;AAC9E,qBAAqB,qDAAqD,EAAE,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe,GAAG,QAAQ;AAC3F;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+DAAgB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;AChJ8C;AACK;AACtB;AACiB;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,sBAAsB,wDAAS,iCAAiC,6CAAK;AACrE;AACA;AACA,yBAAyB,6DAAO;AAChC,iCAAiC,oDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,sBAAsB,wDAAS,iCAAiC,6CAAK;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,CAAC,gDAAQ,kBAAkB,6CAAK;AAC/D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,CAAC,gDAAQ,kBAAkB,6CAAK;AAC/D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACxFO;AACP;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;;;;;;;;;;;;;;;;;;;;ACpEwD;AACL;AACG;AAClB;AACpC;AACA;AACA;AACO;AACP,QAAQ,2DAAQ;AAChB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iEAAgB;AACjE;AACA;AACA,iBAAiB,oEAAW;AAC5B,0BAA0B,wDAAS,sBAAsB,6CAAK;AAC9D;AACA;AACA;AACA;AACA,8BAA8B,wDAAS,iEAAiE,6CAAK;AAC7G;AACA;AACA;AACA,iCAAiC,iEAAgB;AACjD;AACA,8BAA8B,wDAAS,iEAAiE,6CAAK;AAC7G;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA,IAAI;AACJ;AACA;AAC+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wCAAwC;AAC/C,uBAAuB,4DAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjD8E;AAC+E;AAC9G;AACI;AACA;AACW;AACL;AACH;AACE;AACQ;AACa;AACV;AACW;AACf;AAClB;AAC4B;AACb;AACE;AAC1B;AACmB;AACT;AACI;AACe;AACjB;AACZ;AAC7B,yBAAyB,gEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAiB;AAC5C;AACA;AACA;AACA,0DAA0D,0DAAW,aAAa,oBAAoB;AACtG;AACA;AACA;AACA,QAAQ,kEAAe;AACvB;AACA,qCAAqC,6DAAa;AAClD;AACA,+BAA+B;AAC/B;AACA;AACA,6CAA6C,iEAAiB;AAC9D;AACA;AACA;AACA,sBAAsB,6CAAQ;AAC9B,yBAAyB,gDAAW;AACpC,aAAa;AACb;AACA;AACA,6CAA6C,kEAAe;AAC5D,6BAA6B,4EAAe;AAC5C;AACA,SAAS;AACT,kEAAkE,oEAAmB;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kBAAkB;AAC1F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAe;AACtD,wIAAwI,MAAM;AAC9I,0GAA0G,MAAM;AAChH;AACA,SAAS;AACT;AACA,wDAAwD,2EAAuB;AAC/E;AACA,yDAAyD,mFAAwB;AACjF;AACA;AACA,6DAA6D,sEAAiB;AAC9E;AACA;AACA,iDAAiD,4DAAgB;AACjE,sBAAsB;AACtB,sDAAsD,6EAAqB;AAC3E;AACA,+GAA+G,MAAM;AACrH,oGAAoG,iEAAkB;AACtH;AACA,SAAS;AACT;AACA,wHAAwH,MAAM;AAC9H,6GAA6G,wEAAsB;AACnI;AACA,SAAS;AACT;AACA,kDAAkD,wDAAU;AAC5D;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,sFAAsF,MAAM;AAC5F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAoB;AAChD;AACA,gDAAgD,oEAAoB;AACpE;AACA,4BAA4B,iEAAiB;AAC7C;AACA,6CAA6C,iEAAiB;AAC9D;AACA,4BAA4B,mEAAmB;AAC/C;AACA,4BAA4B,mEAAmB;AAC/C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,QAAQ,wEAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAO;AACnC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oDAAoD;AACpD;AACA,sBAAsB,yDAAS,gDAAgD,8CAAK;AACpF;AACA;AACA;AACA,sBAAsB,yDAAS,gDAAgD,8CAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,YAAY,oEAAW;AACvB,mBAAmB,kEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA,wBAAwB,0DAAgB;AACxC,YAAY,mEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA,qCAAqC,8CAAK;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACO,4CAA4C;AACnD,4CAA4C,6EAAmB;AAC/D;AACA,kBAAkB,yDAAS;AAC3B;AACA,iCAAiC,yEAAmB;AACpD,gCAAgC,2DAAc;AAC9C;AACA;;;;;;;;;;;;;;;;;;;;AClV8C;AACqB;AACtC;AACM;AACW;AACvC;AACP;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,8BAA8B,6CAAK;AAClE;AACA;AACA,sBAAsB,wDAAS,gCAAgC,6CAAK;AACpE;AACA;AACA,uBAAuB,oDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,wDAAS,CAAC,gDAAQ,YAAY,6CAAK;AACrD;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,sBAAsB,wDAAS,8BAA8B,6CAAK;AAClE;AACA;AACA,qBAAqB,iFAA0B;AAC/C,iCAAiC,uDAAQ;AACzC,2BAA2B,oDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClG6C;AAC0B;AAChC;AACN;AACM;AACE;AAClC,yBAAyB,gEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA,gCAAgC,mDAAM;AACtC;AACA,oCAAoC,qDAAS;AAC7C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAe;AACvB,uBAAuB,qDAAS;AAChC,QAAQ,kEAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAW;AAC5C;AACA,sFAAsF,QAAQ;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,kCAAkC,uDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrH8C;AACZ;AACE;AAC7B;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,uCAAuC,SAAS,GAAG,6CAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,4CAA4C,SAAS,GAAG,6CAAK;AAC5F;AACA,wBAAwB,qDAAK,QAAQ,uBAAuB;AAC5D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,qBAAqB,6CAAK;AACzD;AACA;AACA,sBAAsB,mCAAmC,EAAE,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,6CAAK;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9L8D;AACP;AACD;AAClB;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,yBAAyB,qEAAU;AACnC;AACA;AACA,SAAS;AACT,qDAAqD,6DAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,oCAAoC,6CAAK;AACxE;AACA;AACA,sBAAsB,wDAAS,8CAA8C,IAAI,GAAG,6CAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,uCAAuC,WAAW,GAAG,6CAAK;AACzF;AACA,kCAAkC,gEAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,6CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,gBAAgB,6CAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,6DAAc;AAC/E,0BAA0B,wDAAS,eAAe,IAAI,8CAA8C,6CAAK;AACzG;AACA;AACA;AACA;AACA;AACA,gFAAgF,0BAA0B;AAC1G,wCAAwC,6DAAc;AACtD,0BAA0B,wDAAS,UAAU,6CAAK;AAClD;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxP4E;AAC1B;AACC;AACG;AACG;AACmB;AACxC;AACuD;AAC3F;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,yBAAyB,6CAAK;AAC9B;AACA;AACA;AACA,WAAW,sEAA2B;AACtC;AACA,kEAAkE;AAClE;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAK;AAC9B;AACA;AACA;AACA,yCAAyC,uEAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,mEAAmE,qFAAuB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAS,iDAAiD,eAAe,GAAG,6CAAK;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,sBAAsB,6CAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAS,4BAA4B,0DAAW;AAC7E;AACA,oDAAoD,YAAY;AAChE,QAAQ,kEAAe;AACvB;AACA;AACA,0BAA0B,wDAAS,kEAAkE,6CAAK;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gEAAmB;AAC9D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAS,mEAAmE,6CAAK;AACnH;AACA,yCAAyC,iEAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gEAAmB;AAC9D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAS,qDAAqD,6CAAK;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,uFAAuF;AACvG;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB,QAAQ,8DAAU;AACrE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wDAAS,oDAAoD,SAAS,YAAY,cAAc,GAAG,6CAAK;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yCAAyC,2CAA2C;AACpF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,sDAAsD;AACtD;AACA,8BAA8B,wDAAS,8BAA8B,6CAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB,QAAQ,8DAAU;AACjE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wCAAwC,wDAAS,qDAAqD,SAAS,MAAM,YAAY,GAAG,cAAc,GAAG,6CAAK;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAS,cAAc,6CAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,wDAAS,kCAAkC,6CAAK;AACtE;AACA;AACA,qBAAqB,sEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,gBAAgB,mBAAmB;AACnC;AACA,sBAAsB,wDAAS;AAC/B;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB,QAAQ,8DAAU;AACzD;AACA,aAAa;AACb;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,cAAc,6CAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB,QAAQ,8DAAU;AACzD;AACA;AACA,aAAa;AACb;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS,cAAc,6CAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB,QAAQ,8DAAU;AACzD;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB,wDAAS,cAAc,6CAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB,QAAQ,8DAAU;AACzD;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB,wDAAS,cAAc,6CAAK;AAClD;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxjBO;AACA;AACP;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;;AAEsC;AACtC,iEAAe,sCAAY,EAAC;;;;;;;;;;;;;;;;;;;ACPiB;AAC8I;AACvJ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,iDAAM;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iEAAe;AACf,8BAA8B;AAC9B;AACA;AACA;AACA,QAAQ,6DAAQ,iFAAiF,mEAAwB,EAAE,mEAAwB,EAAE,iEAAsB;AAC3K,QAAQ,6DAAQ,kFAAkF,oEAAyB,EAAE,oEAAyB,EAAE,kEAAuB;AAC/K;AACA;AACA;AACA;AACA,wDAAwD,mEAAwB,EAAE,iEAAsB,EAAE,mEAAwB;AAClI,yDAAyD,oEAAyB,EAAE,kEAAuB,EAAE,oEAAyB;AACtI;AACA,CAAC,EAAC;AACF;;;;;;;;;;;;;;;;;;;;AClGO;AACA;AACA;AACA;AACA;AACA;AACP;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;AACI;AACJ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,qDAAQ;AACvC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAM,GAAG,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAM;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,iCAAiC;AACjC;AACA,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,YAAY;AAC9F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kFAAkF,YAAY;AAC9F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpNO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACHqC;AACG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,EAAE,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,qBAAqB,IAAI,WAAW,6CAA6C,YAAY;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB,8BAA8B,4BAA4B;AAClJ;AACA;AACA;AACO;AACP;AACA;AACA,+BAA+B,qBAAqB;AACpD,gCAAgC,uBAAuB;AACvD,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gBAAgB,8BAA8B;AACrD;AACA;AACO,iBAAiB,wBAAwB;AAChD,YAAY,iBAAiB,EAAE,6DAAK;AACpC;AACA;AACA;AACA;AACA,0BAA0B,iDAAM;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,qCAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACzMkC;AAC3B,eAAe,+CAAK;AAC3B;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACNoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACboC;AAC7B,cAAc,iDAAO;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACPiC;AACjC;AACA,6DAA6D,UAAU,WAAW;AAClF,6DAA6D,yBAAyB,WAAW;AACjG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACO,qBAAqB,8CAAI;AAChC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;AC3BoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,oBAAoB,iDAAO;AAClC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,uBAAuB,iDAAO;AACrC;AACA;AACA;AACA;AACA,CAAC;AACM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;AACM,0BAA0B,iDAAO;AACxC;AACA;AACA;AACA;AACA,CAAC;AACM,gBAAgB,iDAAO;AAC9B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACvDkC;AAC3B,eAAe,+CAAK;AAC3B;AACA;AACA;AACA,CAAC;AACM,oBAAoB,+CAAK;AAChC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACXkC;AAC3B,kBAAkB,+CAAK;AAC9B;AACA;AACA;AACA,CAAC;AACM,qBAAqB,+CAAK;AACjC;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;ACXoC;AAC7B,eAAe,iDAAO;AAC7B;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,kBAAkB,iDAAO;AAChC;AACA;AACA;AACA;AACA,CAAC;AACM,qBAAqB,iDAAO;AACnC;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACzBoC;AAC7B,cAAc,iDAAO;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;ACPmD;AAClB;AAC1B,iBAAiB,8CAAI;AAC5B;AACA;AACA,qBAAqB,mDAAQ;AAC7B,qBAAqB,qDAAU;AAC/B,CAAC;AACD;;;;;;;;;;;;ACRA;AACA;AACU;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACH4C;AACA;AACF;AACc;AACZ;AACA;AACA;AACA;AACF;AACU;AACX;AACF;AACU;AACR;AACuB;AACzD,gBAAgB,GAAG,+CAAY,KAAK,4CAAK,KAAK,4CAAK,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,6CAAM,KAAK,mDAAY;AACtI,iBAAiB,GAAG,6CAAI,KAAK,iDAAQ;AACrC,iBAAiB,GAAG,oDAAM;AACa;AAC9C;;;;;;;;;;;;ACnBU;AACV;;;;;;;;;;;;;;;;;;;;;;ACDO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxC2C;AACG;AACV;AACS;AACP;AACtC;AACoC;AAC7B;AACP,YAAY,iBAAiB;AAC7B;AACA;AACA,8DAA8D,uDAAS;AACvE;AACA,+DAA+D,oDAAM;AACrE;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,kCAAkC,qDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAa;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA,2BAA2B,qDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA,sCAAsC;AACtC,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAS;AAC7C;AACA,gBAAgB,uDAAS;AACzB,kCAAkC,uDAAS,QAAQ,EAAE,OAAO;AAC5D;AACA;AACA,aAAa,uDAAS;AACtB,oCAAoC,uDAAS;AAC7C,oBAAoB,uDAAS;AAC7B;AACA,aAAa,oDAAM;AACnB,oCAAoC,oDAAM;AAC1C,oBAAoB,oDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,mBAAmB,uDAAS;AAC5B,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAqB;AAC5C,oCAAoC,sDAAqB;AACzD;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrXU;AACV;;;;;;;;;;;;;;;;;;ACDA;AACA;AACO;AACA;AACA;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVqC;AAC9B;AACA;AACA;AACP,WAAW,iDAAM;AACjB;AACO;AACP,WAAW,iDAAM;AACjB;AACA;;;;;;;;;;;;;;;;;;;;ACT2D;AACpB;AACvC;AACA;AACA;AACO;AACP;AACA,uBAAuB,sDAAqB;AAC5C,sCAAsC,sDAAqB;AAC3D;AACA,IAAI,gDAAe;AACnB,IAAI,gDAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,iDAAM;AACxB,+BAA+B,8CAAa;AAC5C,iCAAiC,8CAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3DsC;AAC/B,gBAAgB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAa;AAC/B;AACA,wCAAwC,8CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/BqC;AACC;AACtC;AACA;AACA,eAAe,6CAAM;AACrB;AACA,WAAW,8CAAa;AACxB;AACO,mBAAmB;AAC1B;;;;;;;;;;;;ACTA;AACU;AACV;;;;;;;;;;;;;;;;;ACFA;AACmC;AACnC;AACA;AACA;AACO,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;AACM,eAAe,gDAAI;AAC1B;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,YAAY,SAAS;AACrB;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,mBAAmB;AACnB;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA,gCAAgC,mDAAmD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA,mBAAmB;AACnB,sCAAsC,sBAAsB;AAC5D,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACL;AACc;AACA;AACP;AACtC;AAC+B;AACe;AAC9C;;;;;;;;;;;;;;;;;ACjNqC;AACC;AACA;AACF;AACC;AACrC;;;;;;;;;;;;ACLA;AACA;AACU;AACV;;;;;;;;;;;;;;;;;;ACHwC;AACjC;AACP,iBAAiB,yDAAM;AACvB,kBAAkB,yDAAM;AACxB;AACO;AACP,IAAI,yDAAM;AACV;AACA;AACO;AACP,WAAW,yDAAM;AACjB;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,kDAAkD;AAClD;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,+BAA+B,EAAC;AAC/C;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;AAC5B;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;AAC1B;;;;;;;;;;;;;;;AC/Be;AACf;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;;;;;;;;;;;;;;;;;;ACT6C;AACM;AACH;AAChD;AACA;AACA;AACe,qBAAqB,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAa;AACrC;AACA;AACA;AACA,gGAAgG,sCAAsC,MAAM,2BAA2B;AACvK;AACA;AACA,2FAA2F,mCAAmC,MAAM,wBAAwB;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,eAAe,MAAM,sBAAsB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,YAAY;AAC7B,SAAS;AACT;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wBAAwB;AACxE;AACA,oCAAoC,qDAAQ,+BAA+B,+BAA+B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrTA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjB0C;AAC3B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C,GAAG;;AAEH;;AAEA;AACA;AACA,mFAAmF,aAAa;AAChG;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,iEAAiE,cAAc;AAC/E;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACfA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClBuD;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sDAAW,SAAS,kDAAW;AAC1C;AACA;;;;;;;;;;;;;;;;ACrBuD;AAChD;AACP,WAAW,sDAAW,YAAY,kDAAW;AAC7C;AACA;;;;;;;;;;;;;;;;ACJiD;AAC1C;AACP,mBAAmB,8DAAY;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;ACLiD;AAC1C;AACP,cAAc,8DAAY;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACA;AACG;AACD;AACa;AACA;AAC3D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8CAA8C;AAC9C,4BAA4B;AAC5B;AACA;;;;;;;;;;;;;;;;AC7KgD;AAChD;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzBgE;AACT;AACd;AACP;AAClC;AACA;AACA,6CAA6C,YAAY,IAAI,kBAAkB,IAAI,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU,YAAY,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA,uCAAuC;AACvC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAgB;AACtC,oBAAoB,4DAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;AC5WA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY;AACZ,YAAY;AACZ,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjGgE;AAChB;AAC6B;AACpB;AAChB;AACZ;AACK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAgB,EAAE,4DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAY;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,0BAA0B,oDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAW;AAC/B;AACA,qCAAqC,2CAAU;AAC/C;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B,IAAI,4BAA4B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAoB;AACpC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,8DAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACX;AACA;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,eAAe,0DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA,eAAe,0DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C,iBAAiB,0DAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5jBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACO;AACP,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpBqC;AACc;AACnD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,mDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,WAAW,iEAAY;AACvB;AACA;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,sDAAK;AACtB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,kCAAkC,YAAY,EAAE,OAAO,IAAI;AAC3D;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACN;AACI;AACF;AACS;AACJ;AACwB;AAC9D;;;;;;;;;;;;;;;;AC3KwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,sDAAK;AACtB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;ACP4C;AACP;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA,gBAAgB,mDAAW;AAC3B,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,SAAS,sDAAK;AACd;AACA;AACA;AACA,OAAO,sDAAK;AACZ;AACA,iEAAe,KAAK,EAAC;AACrB;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjBqC;AACc;AACnD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,mDAAW;AAC9B,oBAAoB,cAAc;AAClC;AACA;AACA,WAAW,iEAAY;AACvB;AACA;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,sDAAK,GAAG,0EAA0E,CAAC,EAAC;AACnG;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACX;AACf;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0CAAQ;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;AAC9B,iEAAe,gDAAK,EAAC;AACrB;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc,UAAU,sBAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA,iEAAe,EAAE,EAAC;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,cAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB,EAAE,KAAK,EAAE,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrIwC;;AAEjC;AACA,mBAAmB,wCAAc;;AAExC;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACA;AACO;;AAEP;AACO;AACA;;;;;;;UClBP;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack:///./node_modules/asn1js/build/index.es.js","webpack:///./node_modules/err-code/index.js","webpack:///./node_modules/event-iterator/lib/dom.js","webpack:///./node_modules/event-iterator/lib/event-iterator.js","webpack:///./node_modules/eventemitter3/index.js","webpack:///./node_modules/hashlru/index.js","webpack:///./node_modules/is-electron/index.js","webpack:///./node_modules/is-plain-obj/index.js","webpack:///./node_modules/merge-options/index.js","webpack:///./node_modules/murmurhash3js-revisited/index.js","webpack:///./node_modules/murmurhash3js-revisited/lib/murmurHash3js.js","webpack:///./node_modules/netmask/lib/netmask.js","webpack:///./node_modules/pvtsutils/build/index.js","webpack:///./node_modules/pvutils/build/utils.es.js","webpack:///./node_modules/@chainsafe/is-ip/lib/is-ip.js","webpack:///./node_modules/@chainsafe/is-ip/lib/parse.js","webpack:///./node_modules/@chainsafe/is-ip/lib/parser.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/constants.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/errors.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/index.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/logger.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/noise.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/streaming.js","webpack:///./node_modules/@chainsafe/libp2p-noise/dist/src/utils.js","webpack:///./node_modules/@chainsafe/netmask/dist/src/cidr.js","webpack:///./node_modules/@chainsafe/netmask/dist/src/index.js","webpack:///./node_modules/@chainsafe/netmask/dist/src/ip.js","webpack:///./node_modules/@chainsafe/netmask/dist/src/ipnet.js","webpack:///./node_modules/@chainsafe/netmask/dist/src/util.js","webpack:///./node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js","webpack:///./node_modules/@libp2p/crypto/dist/src/hmac/index-browser.js","webpack:///./node_modules/@libp2p/crypto/dist/src/hmac/lengths.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/ephemeral-keys.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/exporter.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/importer.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/index.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/keys.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-browser.js","webpack:///./node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js","webpack:///./node_modules/@libp2p/crypto/dist/src/random-bytes.js","webpack:///./node_modules/@libp2p/crypto/dist/src/util.js","webpack:///./node_modules/@libp2p/crypto/dist/src/webcrypto-browser.js","webpack:///./node_modules/@libp2p/identify/dist/src/consts.js","webpack:///./node_modules/@libp2p/identify/dist/src/identify-push.js","webpack:///./node_modules/@libp2p/identify/dist/src/identify.js","webpack:///./node_modules/@libp2p/identify/dist/src/index.js","webpack:///./node_modules/@libp2p/identify/dist/src/pb/message.js","webpack:///./node_modules/@libp2p/identify/dist/src/utils.js","webpack:///./node_modules/@libp2p/interface/dist/src/connection/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/content-routing/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/errors.js","webpack:///./node_modules/@libp2p/interface/dist/src/event-target.js","webpack:///./node_modules/@libp2p/interface/dist/src/events.browser.js","webpack:///./node_modules/@libp2p/interface/dist/src/events.js","webpack:///./node_modules/@libp2p/interface/dist/src/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/keys/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/peer-discovery/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/peer-id/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/peer-routing/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/peer-store/tags.js","webpack:///./node_modules/@libp2p/interface/dist/src/pubsub/index.js","webpack:///./node_modules/@libp2p/interface/dist/src/startable.js","webpack:///./node_modules/@libp2p/interface/dist/src/transport/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/constants.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/kad-dht.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/message/dht.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/message/utils.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/network.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/providers.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/query-self.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/query/events.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/query/manager.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/query/query-path.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/record/selectors.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/record/validators.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/rpc/index.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/topology-listener.js","webpack:///./node_modules/@libp2p/kad-dht/dist/src/utils.js","webpack:///./node_modules/@libp2p/kad-dht/node_modules/p-event/index.js","webpack:///./node_modules/@libp2p/logger/dist/src/index.js","webpack:///./node_modules/@libp2p/logger/dist/src/utils.js","webpack:///./node_modules/@libp2p/mplex/dist/src/decode.js","webpack:///./node_modules/@libp2p/mplex/dist/src/encode.js","webpack:///./node_modules/@libp2p/mplex/dist/src/index.js","webpack:///./node_modules/@libp2p/mplex/dist/src/message-types.js","webpack:///./node_modules/@libp2p/mplex/dist/src/mplex.js","webpack:///./node_modules/@libp2p/mplex/dist/src/stream.js","webpack:///./node_modules/@libp2p/multistream-select/dist/src/constants.js","webpack:///./node_modules/@libp2p/multistream-select/dist/src/handle.js","webpack:///./node_modules/@libp2p/multistream-select/dist/src/multistream.js","webpack:///./node_modules/@libp2p/multistream-select/dist/src/select.js","webpack:///./node_modules/@libp2p/peer-collections/dist/src/map.js","webpack:///./node_modules/@libp2p/peer-collections/dist/src/set.js","webpack:///./node_modules/@libp2p/peer-collections/dist/src/util.js","webpack:///./node_modules/@libp2p/peer-id-factory/dist/src/index.js","webpack:///./node_modules/@libp2p/peer-id-factory/dist/src/proto.js","webpack:///./node_modules/@libp2p/peer-id/dist/src/index.js","webpack:///./node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js","webpack:///./node_modules/@libp2p/peer-record/dist/src/envelope/index.js","webpack:///./node_modules/@libp2p/peer-record/dist/src/errors.js","webpack:///./node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js","webpack:///./node_modules/@libp2p/peer-record/dist/src/peer-record/index.js","webpack:///./node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/errors.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/index.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/pb/peer.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/store.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js","webpack:///./node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js","webpack:///./node_modules/@libp2p/record/dist/src/index.js","webpack:///./node_modules/@libp2p/record/dist/src/record.js","webpack:///./node_modules/@libp2p/record/dist/src/utils.js","webpack:///./node_modules/@libp2p/utils/dist/src/abstract-stream.js","webpack:///./node_modules/@libp2p/utils/dist/src/adaptive-timeout.js","webpack:///./node_modules/@libp2p/utils/dist/src/address-sort.js","webpack:///./node_modules/@libp2p/utils/dist/src/array-equals.js","webpack:///./node_modules/@libp2p/utils/dist/src/close-source.js","webpack:///./node_modules/@libp2p/utils/dist/src/close.js","webpack:///./node_modules/@libp2p/utils/dist/src/filters/bucket.js","webpack:///./node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js","webpack:///./node_modules/@libp2p/utils/dist/src/filters/fingerprint.js","webpack:///./node_modules/@libp2p/utils/dist/src/filters/hashes.js","webpack:///./node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js","webpack:///./node_modules/@libp2p/utils/dist/src/filters/utils.js","webpack:///./node_modules/@libp2p/utils/dist/src/is-promise.js","webpack:///./node_modules/@libp2p/utils/dist/src/moving-average.js","webpack:///./node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js","webpack:///./node_modules/@libp2p/utils/dist/src/peer-queue.js","webpack:///./node_modules/@libp2p/utils/dist/src/priority-queue.js","webpack:///./node_modules/@libp2p/utils/dist/src/private-ip.js","webpack:///./node_modules/@libp2p/utils/dist/src/queue/index.js","webpack:///./node_modules/@libp2p/utils/dist/src/queue/job.js","webpack:///./node_modules/@libp2p/utils/dist/src/queue/recipient.js","webpack:///./node_modules/@libp2p/utils/dist/src/rate-limiter.js","webpack:///./node_modules/@libp2p/utils/dist/src/tracked-map.js","webpack:///./node_modules/@libp2p/websockets/dist/src/constants.js","webpack:///./node_modules/@libp2p/websockets/dist/src/filters.js","webpack:///./node_modules/@libp2p/websockets/dist/src/index.js","webpack:///./node_modules/@libp2p/websockets/dist/src/listener.browser.js","webpack:///./node_modules/@libp2p/websockets/dist/src/socket-to-conn.js","webpack:///./node_modules/@multiformats/dns/dist/src/dns.js","webpack:///./node_modules/@multiformats/dns/dist/src/index.js","webpack:///./node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js","webpack:///./node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js","webpack:///./node_modules/@multiformats/dns/dist/src/utils/cache.js","webpack:///./node_modules/@multiformats/dns/dist/src/utils/get-types.js","webpack:///./node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js","webpack:///./node_modules/@multiformats/mafmt/dist/src/index.js","webpack:///./node_modules/@multiformats/multiaddr-matcher/dist/src/index.js","webpack:///./node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/codec.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/index.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/ip.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js","webpack:///./node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js","webpack:///./node_modules/@noble/ciphers/esm/_arx.js","webpack:///./node_modules/@noble/ciphers/esm/_assert.js","webpack:///./node_modules/@noble/ciphers/esm/_poly1305.js","webpack:///./node_modules/@noble/ciphers/esm/chacha.js","webpack:///./node_modules/@noble/ciphers/esm/utils.js","webpack:///./node_modules/@noble/curves/esm/_shortw_utils.js","webpack:///./node_modules/@noble/curves/esm/abstract/curve.js","webpack:///./node_modules/@noble/curves/esm/abstract/edwards.js","webpack:///./node_modules/@noble/curves/esm/abstract/hash-to-curve.js","webpack:///./node_modules/@noble/curves/esm/abstract/modular.js","webpack:///./node_modules/@noble/curves/esm/abstract/montgomery.js","webpack:///./node_modules/@noble/curves/esm/abstract/utils.js","webpack:///./node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack:///./node_modules/@noble/curves/esm/ed25519.js","webpack:///./node_modules/@noble/curves/esm/secp256k1.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js","webpack:///./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js","webpack:///./node_modules/@noble/hashes/esm/_assert.js","webpack:///./node_modules/@noble/hashes/esm/_md.js","webpack:///./node_modules/@noble/hashes/esm/_u64.js","webpack:///./node_modules/@noble/hashes/esm/crypto.js","webpack:///./node_modules/@noble/hashes/esm/hkdf.js","webpack:///./node_modules/@noble/hashes/esm/hmac.js","webpack:///./node_modules/@noble/hashes/esm/pbkdf2.js","webpack:///./node_modules/@noble/hashes/esm/sha256.js","webpack:///./node_modules/@noble/hashes/esm/sha512.js","webpack:///./node_modules/@noble/hashes/esm/utils.js","webpack:///./node_modules/@sindresorhus/fnv1a/index.js","webpack:///./node_modules/any-signal/dist/src/index.js","webpack:///./src/libp2pNode.js","webpack:///./node_modules/datastore-core/dist/src/base.js","webpack:///./node_modules/datastore-core/dist/src/errors.js","webpack:///./node_modules/datastore-core/dist/src/memory.js","webpack:///./node_modules/delay/index.js","webpack:///./node_modules/eventemitter3/index.mjs","webpack:///./node_modules/get-iterator/dist/src/index.js","webpack:///./node_modules/interface-datastore/dist/src/key.js","webpack:///./node_modules/it-all/dist/src/index.js","webpack:///./node_modules/it-byte-stream/dist/src/errors.js","webpack:///./node_modules/it-byte-stream/dist/src/index.js","webpack:///./node_modules/it-drain/dist/src/index.js","webpack:///./node_modules/it-filter/dist/src/index.js","webpack:///./node_modules/it-length-prefixed-stream/dist/src/errors.js","webpack:///./node_modules/it-length-prefixed-stream/dist/src/index.js","webpack:///./node_modules/it-length-prefixed/dist/src/decode.js","webpack:///./node_modules/it-length-prefixed/dist/src/encode.js","webpack:///./node_modules/it-length-prefixed/dist/src/errors.js","webpack:///./node_modules/it-length-prefixed/dist/src/index.js","webpack:///./node_modules/it-length-prefixed/dist/src/utils.js","webpack:///./node_modules/it-length/dist/src/index.js","webpack:///./node_modules/it-map/dist/src/index.js","webpack:///./node_modules/it-merge/dist/src/index.js","webpack:///./node_modules/it-pair/dist/src/duplex.js","webpack:///./node_modules/it-pair/dist/src/index.js","webpack:///./node_modules/it-parallel/dist/src/index.js","webpack:///./node_modules/it-peekable/dist/src/index.js","webpack:///./node_modules/it-pipe/dist/src/index.js","webpack:///./node_modules/it-protobuf-stream/dist/src/index.js","webpack:///./node_modules/it-pushable/dist/src/fifo.js","webpack:///./node_modules/it-pushable/dist/src/index.js","webpack:///./node_modules/it-queueless-pushable/dist/src/index.js","webpack:///./node_modules/it-sort/dist/src/index.js","webpack:///./node_modules/it-take/dist/src/index.js","webpack:///./node_modules/it-ws/dist/src/client.js","webpack:///./node_modules/it-ws/dist/src/duplex.js","webpack:///./node_modules/it-ws/dist/src/ready.js","webpack:///./node_modules/it-ws/dist/src/sink.js","webpack:///./node_modules/it-ws/dist/src/source.js","webpack:///./node_modules/it-ws/dist/src/web-socket.browser.js","webpack:///./node_modules/it-ws/dist/src/ws-url.js","webpack:///./node_modules/libp2p/dist/src/address-manager/index.js","webpack:///./node_modules/libp2p/dist/src/address-manager/utils.js","webpack:///./node_modules/libp2p/dist/src/components.js","webpack:///./node_modules/libp2p/dist/src/config.js","webpack:///./node_modules/libp2p/dist/src/config/connection-gater.browser.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/auto-dial.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/connection-pruner.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/constants.browser.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/constants.defaults.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/dial-queue.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/index.js","webpack:///./node_modules/libp2p/dist/src/connection-manager/utils.js","webpack:///./node_modules/libp2p/dist/src/connection-monitor.js","webpack:///./node_modules/libp2p/dist/src/connection/index.js","webpack:///./node_modules/libp2p/dist/src/content-routing.js","webpack:///./node_modules/libp2p/dist/src/errors.js","webpack:///./node_modules/libp2p/dist/src/get-peer.js","webpack:///./node_modules/libp2p/dist/src/index.js","webpack:///./node_modules/libp2p/dist/src/libp2p.js","webpack:///./node_modules/libp2p/dist/src/peer-routing.js","webpack:///./node_modules/libp2p/dist/src/random-walk.js","webpack:///./node_modules/libp2p/dist/src/registrar.js","webpack:///./node_modules/libp2p/dist/src/transport-manager.js","webpack:///./node_modules/libp2p/dist/src/upgrader.js","webpack:///./node_modules/libp2p/dist/src/version.js","webpack:///./node_modules/merge-options/index.mjs","webpack:///./node_modules/mortice/dist/src/browser.js","webpack:///./node_modules/mortice/dist/src/constants.js","webpack:///./node_modules/mortice/dist/src/index.js","webpack:///./node_modules/mortice/dist/src/utils.js","webpack:///./node_modules/multiformats/dist/src/bases/base.js","webpack:///./node_modules/multiformats/dist/src/bases/base10.js","webpack:///./node_modules/multiformats/dist/src/bases/base16.js","webpack:///./node_modules/multiformats/dist/src/bases/base2.js","webpack:///./node_modules/multiformats/dist/src/bases/base256emoji.js","webpack:///./node_modules/multiformats/dist/src/bases/base32.js","webpack:///./node_modules/multiformats/dist/src/bases/base36.js","webpack:///./node_modules/multiformats/dist/src/bases/base58.js","webpack:///./node_modules/multiformats/dist/src/bases/base64.js","webpack:///./node_modules/multiformats/dist/src/bases/base8.js","webpack:///./node_modules/multiformats/dist/src/bases/identity.js","webpack:///./node_modules/multiformats/dist/src/bases/interface.js","webpack:///./node_modules/multiformats/dist/src/basics.js","webpack:///./node_modules/multiformats/dist/src/block/interface.js","webpack:///./node_modules/multiformats/dist/src/bytes.js","webpack:///./node_modules/multiformats/dist/src/cid.js","webpack:///./node_modules/multiformats/dist/src/codecs/interface.js","webpack:///./node_modules/multiformats/dist/src/codecs/json.js","webpack:///./node_modules/multiformats/dist/src/codecs/raw.js","webpack:///./node_modules/multiformats/dist/src/hashes/digest.js","webpack:///./node_modules/multiformats/dist/src/hashes/hasher.js","webpack:///./node_modules/multiformats/dist/src/hashes/identity.js","webpack:///./node_modules/multiformats/dist/src/hashes/interface.js","webpack:///./node_modules/multiformats/dist/src/hashes/sha2-browser.js","webpack:///./node_modules/multiformats/dist/src/index.js","webpack:///./node_modules/multiformats/dist/src/interface.js","webpack:///./node_modules/multiformats/dist/src/link/interface.js","webpack:///./node_modules/multiformats/dist/src/varint.js","webpack:///./node_modules/multiformats/dist/src/vendor/base-x.js","webpack:///./node_modules/multiformats/dist/src/vendor/varint.js","webpack:///./node_modules/observable-webworkers/dist/src/index.js","webpack:///./node_modules/p-defer/index.js","webpack:///./node_modules/p-queue/dist/index.js","webpack:///./node_modules/p-queue/dist/lower-bound.js","webpack:///./node_modules/p-queue/dist/priority-queue.js","webpack:///./node_modules/p-timeout/index.js","webpack:///./node_modules/progress-events/dist/src/index.js","webpack:///./node_modules/protons-runtime/dist/src/codec.js","webpack:///./node_modules/protons-runtime/dist/src/codecs/enum.js","webpack:///./node_modules/protons-runtime/dist/src/codecs/message.js","webpack:///./node_modules/protons-runtime/dist/src/decode.js","webpack:///./node_modules/protons-runtime/dist/src/encode.js","webpack:///./node_modules/protons-runtime/dist/src/index.js","webpack:///./node_modules/protons-runtime/dist/src/utils/float.js","webpack:///./node_modules/protons-runtime/dist/src/utils/longbits.js","webpack:///./node_modules/protons-runtime/dist/src/utils/pool.js","webpack:///./node_modules/protons-runtime/dist/src/utils/reader.js","webpack:///./node_modules/protons-runtime/dist/src/utils/utf8.js","webpack:///./node_modules/protons-runtime/dist/src/utils/writer.js","webpack:///./node_modules/race-event/dist/src/index.js","webpack:///./node_modules/race-signal/dist/src/index.js","webpack:///./node_modules/uint8-varint/dist/src/index.js","webpack:///./node_modules/uint8arraylist/dist/src/index.js","webpack:///./node_modules/uint8arrays/dist/src/alloc.js","webpack:///./node_modules/uint8arrays/dist/src/compare.js","webpack:///./node_modules/uint8arrays/dist/src/concat.js","webpack:///./node_modules/uint8arrays/dist/src/equals.js","webpack:///./node_modules/uint8arrays/dist/src/from-string.js","webpack:///./node_modules/uint8arrays/dist/src/index.js","webpack:///./node_modules/uint8arrays/dist/src/to-string.js","webpack:///./node_modules/uint8arrays/dist/src/util/as-uint8array.js","webpack:///./node_modules/uint8arrays/dist/src/util/bases.js","webpack:///./node_modules/uint8arrays/dist/src/xor-compare.js","webpack:///./node_modules/uint8arrays/dist/src/xor.js","webpack:///./node_modules/weald/dist/src/browser.js","webpack:///./node_modules/weald/dist/src/common.js","webpack:///./node_modules/weald/dist/src/index.js","webpack:///./node_modules/weald/node_modules/ms/dist/index.mjs","webpack:///./node_modules/wherearewe/src/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/async module","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/before-startup","webpack:///webpack/startup","webpack:///webpack/after-startup"],"sourcesContent":["/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\n\nimport * as pvtsutils from 'pvtsutils';\nimport * as pvutils from 'pvutils';\n\nfunction assertBigInt() {\r\n    if (typeof BigInt === \"undefined\") {\r\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\r\n    }\r\n}\r\nfunction concat(buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retView = new Uint8Array(outputLength);\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retView.buffer;\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof Uint8Array)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nclass ViewWriter {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n    write(buf) {\r\n        this.items.push(buf);\r\n    }\r\n    final() {\r\n        return concat(this.items);\r\n    }\r\n}\n\nconst powers2 = [new Uint8Array([1])];\r\nconst digitsString = \"0123456789\";\r\nconst NAME = \"name\";\r\nconst VALUE_HEX_VIEW = \"valueHexView\";\r\nconst IS_HEX_ONLY = \"isHexOnly\";\r\nconst ID_BLOCK = \"idBlock\";\r\nconst TAG_CLASS = \"tagClass\";\r\nconst TAG_NUMBER = \"tagNumber\";\r\nconst IS_CONSTRUCTED = \"isConstructed\";\r\nconst FROM_BER = \"fromBER\";\r\nconst TO_BER = \"toBER\";\r\nconst LOCAL = \"local\";\r\nconst EMPTY_STRING = \"\";\r\nconst EMPTY_BUFFER = new ArrayBuffer(0);\r\nconst EMPTY_VIEW = new Uint8Array(0);\r\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\r\nconst OCTET_STRING_NAME = \"OCTET STRING\";\r\nconst BIT_STRING_NAME = \"BIT STRING\";\n\nfunction HexBlock(BaseClass) {\r\n    var _a;\r\n    return _a = class Some extends BaseClass {\r\n            constructor(...args) {\r\n                var _a;\r\n                super(...args);\r\n                const params = args[0] || {};\r\n                this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n                this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\r\n            }\r\n            get valueHex() {\r\n                return this.valueHexView.slice().buffer;\r\n            }\r\n            set valueHex(value) {\r\n                this.valueHexView = new Uint8Array(value);\r\n            }\r\n            fromBER(inputBuffer, inputOffset, inputLength) {\r\n                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n                if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n                    return -1;\r\n                }\r\n                const endLength = inputOffset + inputLength;\r\n                this.valueHexView = view.subarray(inputOffset, endLength);\r\n                if (!this.valueHexView.length) {\r\n                    this.warnings.push(\"Zero buffer length\");\r\n                    return inputOffset;\r\n                }\r\n                this.blockLength = inputLength;\r\n                return endLength;\r\n            }\r\n            toBER(sizeOnly = false) {\r\n                if (!this.isHexOnly) {\r\n                    this.error = \"Flag 'isHexOnly' is not set, abort\";\r\n                    return EMPTY_BUFFER;\r\n                }\r\n                if (sizeOnly) {\r\n                    return new ArrayBuffer(this.valueHexView.byteLength);\r\n                }\r\n                return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)\r\n                    ? this.valueHexView.buffer\r\n                    : this.valueHexView.slice().buffer;\r\n            }\r\n            toJSON() {\r\n                return {\r\n                    ...super.toJSON(),\r\n                    isHexOnly: this.isHexOnly,\r\n                    valueHex: pvtsutils.Convert.ToHex(this.valueHexView),\r\n                };\r\n            }\r\n        },\r\n        _a.NAME = \"hexBlock\",\r\n        _a;\r\n}\n\nclass LocalBaseBlock {\r\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {\r\n        this.blockLength = blockLength;\r\n        this.error = error;\r\n        this.warnings = warnings;\r\n        this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);\r\n    }\r\n    static blockName() {\r\n        return this.NAME;\r\n    }\r\n    get valueBeforeDecode() {\r\n        return this.valueBeforeDecodeView.slice().buffer;\r\n    }\r\n    set valueBeforeDecode(value) {\r\n        this.valueBeforeDecodeView = new Uint8Array(value);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            blockName: this.constructor.NAME,\r\n            blockLength: this.blockLength,\r\n            error: this.error,\r\n            warnings: this.warnings,\r\n            valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView),\r\n        };\r\n    }\r\n}\r\nLocalBaseBlock.NAME = \"baseBlock\";\n\nclass ValueBlock extends LocalBaseBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n}\r\nValueBlock.NAME = \"valueBlock\";\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ idBlock = {}, } = {}) {\r\n        var _a, _b, _c, _d;\r\n        super();\r\n        if (idBlock) {\r\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n            this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\r\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\r\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\r\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\r\n        }\r\n        else {\r\n            this.tagClass = -1;\r\n            this.tagNumber = -1;\r\n            this.isConstructed = false;\r\n        }\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let firstOctet = 0;\r\n        switch (this.tagClass) {\r\n            case 1:\r\n                firstOctet |= 0x00;\r\n                break;\r\n            case 2:\r\n                firstOctet |= 0x40;\r\n                break;\r\n            case 3:\r\n                firstOctet |= 0x80;\r\n                break;\r\n            case 4:\r\n                firstOctet |= 0xC0;\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return EMPTY_BUFFER;\r\n        }\r\n        if (this.isConstructed)\r\n            firstOctet |= 0x20;\r\n        if (this.tagNumber < 31 && !this.isHexOnly) {\r\n            const retView = new Uint8Array(1);\r\n            if (!sizeOnly) {\r\n                let number = this.tagNumber;\r\n                number &= 0x1F;\r\n                firstOctet |= number;\r\n                retView[0] = firstOctet;\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        if (!this.isHexOnly) {\r\n            const encodedBuf = pvutils.utilToBase(this.tagNumber, 7);\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const size = encodedBuf.byteLength;\r\n            const retView = new Uint8Array(size + 1);\r\n            retView[0] = (firstOctet | 0x1F);\r\n            if (!sizeOnly) {\r\n                for (let i = 0; i < (size - 1); i++)\r\n                    retView[i + 1] = encodedView[i] | 0x80;\r\n                retView[size] = encodedView[size - 1];\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\r\n        retView[0] = (firstOctet | 0x1F);\r\n        if (!sizeOnly) {\r\n            const curView = this.valueHexView;\r\n            for (let i = 0; i < (curView.length - 1); i++)\r\n                retView[i + 1] = curView[i] | 0x80;\r\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        const tagClassMask = intBuffer[0] & 0xC0;\r\n        switch (tagClassMask) {\r\n            case 0x00:\r\n                this.tagClass = (1);\r\n                break;\r\n            case 0x40:\r\n                this.tagClass = (2);\r\n                break;\r\n            case 0x80:\r\n                this.tagClass = (3);\r\n                break;\r\n            case 0xC0:\r\n                this.tagClass = (4);\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return -1;\r\n        }\r\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\r\n        this.isHexOnly = false;\r\n        const tagNumberMask = intBuffer[0] & 0x1F;\r\n        if (tagNumberMask !== 0x1F) {\r\n            this.tagNumber = (tagNumberMask);\r\n            this.blockLength = 1;\r\n        }\r\n        else {\r\n            let count = 1;\r\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\r\n            let tagNumberBufferMaxLength = 255;\r\n            while (intBuffer[count] & 0x80) {\r\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n                count++;\r\n                if (count >= intBuffer.length) {\r\n                    this.error = \"End of input reached before message was fully decoded\";\r\n                    return -1;\r\n                }\r\n                if (count === tagNumberBufferMaxLength) {\r\n                    tagNumberBufferMaxLength += 255;\r\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\r\n                    for (let i = 0; i < intTagNumberBuffer.length; i++)\r\n                        tempBufferView[i] = intTagNumberBuffer[i];\r\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\r\n                }\r\n            }\r\n            this.blockLength = (count + 1);\r\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n            const tempBufferView = new Uint8Array(count);\r\n            for (let i = 0; i < count; i++)\r\n                tempBufferView[i] = intTagNumberBuffer[i];\r\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\r\n            intTagNumberBuffer.set(tempBufferView);\r\n            if (this.blockLength <= 9)\r\n                this.tagNumber = pvutils.utilFromBase(intTagNumberBuffer, 7);\r\n            else {\r\n                this.isHexOnly = true;\r\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\r\n            }\r\n        }\r\n        if (((this.tagClass === 1)) &&\r\n            (this.isConstructed)) {\r\n            switch (this.tagNumber) {\r\n                case 1:\r\n                case 2:\r\n                case 5:\r\n                case 6:\r\n                case 9:\r\n                case 13:\r\n                case 14:\r\n                case 23:\r\n                case 24:\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                case 34:\r\n                    this.error = \"Constructed encoding used for primitive type\";\r\n                    return -1;\r\n            }\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            tagClass: this.tagClass,\r\n            tagNumber: this.tagNumber,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalIdentificationBlock.NAME = \"identificationBlock\";\n\nclass LocalLengthBlock extends LocalBaseBlock {\r\n    constructor({ lenBlock = {}, } = {}) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\r\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\r\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        if (intBuffer[0] === 0xFF) {\r\n            this.error = \"Length block 0xFF is reserved by standard\";\r\n            return -1;\r\n        }\r\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\r\n        if (this.isIndefiniteForm) {\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\r\n        if (this.longFormUsed === false) {\r\n            this.length = (intBuffer[0]);\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        const count = intBuffer[0] & 0x7F;\r\n        if (count > 8) {\r\n            this.error = \"Too big integer\";\r\n            return -1;\r\n        }\r\n        if ((count + 1) > intBuffer.length) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        const lenOffset = inputOffset + 1;\r\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\r\n        if (lengthBufferView[count - 1] === 0x00)\r\n            this.warnings.push(\"Needlessly long encoded length\");\r\n        this.length = pvutils.utilFromBase(lengthBufferView, 8);\r\n        if (this.longFormUsed && (this.length <= 127))\r\n            this.warnings.push(\"Unnecessary usage of long length form\");\r\n        this.blockLength = count + 1;\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let retBuf;\r\n        let retView;\r\n        if (this.length > 127)\r\n            this.longFormUsed = true;\r\n        if (this.isIndefiniteForm) {\r\n            retBuf = new ArrayBuffer(1);\r\n            if (sizeOnly === false) {\r\n                retView = new Uint8Array(retBuf);\r\n                retView[0] = 0x80;\r\n            }\r\n            return retBuf;\r\n        }\r\n        if (this.longFormUsed) {\r\n            const encodedBuf = pvutils.utilToBase(this.length, 8);\r\n            if (encodedBuf.byteLength > 127) {\r\n                this.error = \"Too big length\";\r\n                return (EMPTY_BUFFER);\r\n            }\r\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\r\n            if (sizeOnly)\r\n                return retBuf;\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = encodedBuf.byteLength | 0x80;\r\n            for (let i = 0; i < encodedBuf.byteLength; i++)\r\n                retView[i + 1] = encodedView[i];\r\n            return retBuf;\r\n        }\r\n        retBuf = new ArrayBuffer(1);\r\n        if (sizeOnly === false) {\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = this.length;\r\n        }\r\n        return retBuf;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            longFormUsed: this.longFormUsed,\r\n            length: this.length,\r\n        };\r\n    }\r\n}\r\nLocalLengthBlock.NAME = \"lengthBlock\";\n\nconst typeStore = {};\n\nclass BaseBlock extends LocalBaseBlock {\r\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {\r\n        super(parameters);\r\n        this.name = name;\r\n        this.optional = optional;\r\n        if (primitiveSchema) {\r\n            this.primitiveSchema = primitiveSchema;\r\n        }\r\n        this.idBlock = new LocalIdentificationBlock(parameters);\r\n        this.lenBlock = new LocalLengthBlock(parameters);\r\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        if (!writer) {\r\n            prepareIndefiniteForm(this);\r\n        }\r\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\r\n        _writer.write(idBlockBuf);\r\n        if (this.lenBlock.isIndefiniteForm) {\r\n            _writer.write(new Uint8Array([0x80]).buffer);\r\n            this.valueBlock.toBER(sizeOnly, _writer);\r\n            _writer.write(new ArrayBuffer(2));\r\n        }\r\n        else {\r\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\r\n            this.lenBlock.length = valueBlockBuf.byteLength;\r\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\r\n            _writer.write(lenBlockBuf);\r\n            _writer.write(valueBlockBuf);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            idBlock: this.idBlock.toJSON(),\r\n            lenBlock: this.lenBlock.toJSON(),\r\n            valueBlock: this.valueBlock.toJSON(),\r\n            name: this.name,\r\n            optional: this.optional,\r\n        };\r\n        if (this.primitiveSchema)\r\n            object.primitiveSchema = this.primitiveSchema.toJSON();\r\n        return object;\r\n    }\r\n    toString(encoding = \"ascii\") {\r\n        if (encoding === \"ascii\") {\r\n            return this.onAsciiEncoding();\r\n        }\r\n        return pvtsutils.Convert.ToHex(this.toBER());\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\r\n    }\r\n    isEqual(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof this.constructor)) {\r\n            return false;\r\n        }\r\n        const thisRaw = this.toBER();\r\n        const otherRaw = other.toBER();\r\n        return pvutils.isEqualBuffer(thisRaw, otherRaw);\r\n    }\r\n}\r\nBaseBlock.NAME = \"BaseBlock\";\r\nfunction prepareIndefiniteForm(baseBlock) {\r\n    if (baseBlock instanceof typeStore.Constructed) {\r\n        for (const value of baseBlock.valueBlock.value) {\r\n            if (prepareIndefiniteForm(value)) {\r\n                baseBlock.lenBlock.isIndefiniteForm = true;\r\n            }\r\n        }\r\n    }\r\n    return !!baseBlock.lenBlock.isIndefiniteForm;\r\n}\n\nclass BaseStringBlock extends BaseBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {\r\n        super(parameters, stringValueBlockType);\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        this.fromBuffer(this.valueBlock.valueHexView);\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\r\n    }\r\n}\r\nBaseStringBlock.NAME = \"BaseStringBlock\";\n\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ isHexOnly = true, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = isHexOnly;\r\n    }\r\n}\r\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\n\nvar _a$w;\r\nclass Primitive extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalPrimitiveValueBlock);\r\n        this.idBlock.isConstructed = false;\r\n    }\r\n}\r\n_a$w = Primitive;\r\n(() => {\r\n    typeStore.Primitive = _a$w;\r\n})();\r\nPrimitive.NAME = \"PRIMITIVE\";\n\nfunction localChangeType(inputObject, newType) {\r\n    if (inputObject instanceof newType) {\r\n        return inputObject;\r\n    }\r\n    const newObject = new newType();\r\n    newObject.idBlock = inputObject.idBlock;\r\n    newObject.lenBlock = inputObject.lenBlock;\r\n    newObject.warnings = inputObject.warnings;\r\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\r\n    return newObject;\r\n}\r\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\r\n    const incomingOffset = inputOffset;\r\n    let returnObject = new BaseBlock({}, ValueBlock);\r\n    const baseBlock = new LocalBaseBlock();\r\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\r\n        returnObject.error = baseBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\r\n    if (!intBuffer.length) {\r\n        returnObject.error = \"Zero buffer length\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.idBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.idBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.idBlock.blockLength;\r\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.lenBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.lenBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.lenBlock.blockLength;\r\n    if (!returnObject.idBlock.isConstructed &&\r\n        returnObject.lenBlock.isIndefiniteForm) {\r\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let newASN1Type = BaseBlock;\r\n    switch (returnObject.idBlock.tagClass) {\r\n        case 1:\r\n            if ((returnObject.idBlock.tagNumber >= 37) &&\r\n                (returnObject.idBlock.isHexOnly === false)) {\r\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\r\n                return {\r\n                    offset: -1,\r\n                    result: returnObject\r\n                };\r\n            }\r\n            switch (returnObject.idBlock.tagNumber) {\r\n                case 0:\r\n                    if ((returnObject.idBlock.isConstructed) &&\r\n                        (returnObject.lenBlock.length > 0)) {\r\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\r\n                        return {\r\n                            offset: -1,\r\n                            result: returnObject\r\n                        };\r\n                    }\r\n                    newASN1Type = typeStore.EndOfContent;\r\n                    break;\r\n                case 1:\r\n                    newASN1Type = typeStore.Boolean;\r\n                    break;\r\n                case 2:\r\n                    newASN1Type = typeStore.Integer;\r\n                    break;\r\n                case 3:\r\n                    newASN1Type = typeStore.BitString;\r\n                    break;\r\n                case 4:\r\n                    newASN1Type = typeStore.OctetString;\r\n                    break;\r\n                case 5:\r\n                    newASN1Type = typeStore.Null;\r\n                    break;\r\n                case 6:\r\n                    newASN1Type = typeStore.ObjectIdentifier;\r\n                    break;\r\n                case 10:\r\n                    newASN1Type = typeStore.Enumerated;\r\n                    break;\r\n                case 12:\r\n                    newASN1Type = typeStore.Utf8String;\r\n                    break;\r\n                case 13:\r\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\r\n                    break;\r\n                case 14:\r\n                    newASN1Type = typeStore.TIME;\r\n                    break;\r\n                case 15:\r\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\r\n                    return {\r\n                        offset: -1,\r\n                        result: returnObject\r\n                    };\r\n                case 16:\r\n                    newASN1Type = typeStore.Sequence;\r\n                    break;\r\n                case 17:\r\n                    newASN1Type = typeStore.Set;\r\n                    break;\r\n                case 18:\r\n                    newASN1Type = typeStore.NumericString;\r\n                    break;\r\n                case 19:\r\n                    newASN1Type = typeStore.PrintableString;\r\n                    break;\r\n                case 20:\r\n                    newASN1Type = typeStore.TeletexString;\r\n                    break;\r\n                case 21:\r\n                    newASN1Type = typeStore.VideotexString;\r\n                    break;\r\n                case 22:\r\n                    newASN1Type = typeStore.IA5String;\r\n                    break;\r\n                case 23:\r\n                    newASN1Type = typeStore.UTCTime;\r\n                    break;\r\n                case 24:\r\n                    newASN1Type = typeStore.GeneralizedTime;\r\n                    break;\r\n                case 25:\r\n                    newASN1Type = typeStore.GraphicString;\r\n                    break;\r\n                case 26:\r\n                    newASN1Type = typeStore.VisibleString;\r\n                    break;\r\n                case 27:\r\n                    newASN1Type = typeStore.GeneralString;\r\n                    break;\r\n                case 28:\r\n                    newASN1Type = typeStore.UniversalString;\r\n                    break;\r\n                case 29:\r\n                    newASN1Type = typeStore.CharacterString;\r\n                    break;\r\n                case 30:\r\n                    newASN1Type = typeStore.BmpString;\r\n                    break;\r\n                case 31:\r\n                    newASN1Type = typeStore.DATE;\r\n                    break;\r\n                case 32:\r\n                    newASN1Type = typeStore.TimeOfDay;\r\n                    break;\r\n                case 33:\r\n                    newASN1Type = typeStore.DateTime;\r\n                    break;\r\n                case 34:\r\n                    newASN1Type = typeStore.Duration;\r\n                    break;\r\n                default: {\r\n                    const newObject = returnObject.idBlock.isConstructed\r\n                        ? new typeStore.Constructed()\r\n                        : new typeStore.Primitive();\r\n                    newObject.idBlock = returnObject.idBlock;\r\n                    newObject.lenBlock = returnObject.lenBlock;\r\n                    newObject.warnings = returnObject.warnings;\r\n                    returnObject = newObject;\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        default: {\r\n            newASN1Type = returnObject.idBlock.isConstructed\r\n                ? typeStore.Constructed\r\n                : typeStore.Primitive;\r\n        }\r\n    }\r\n    returnObject = localChangeType(returnObject, newASN1Type);\r\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\r\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\r\n    return {\r\n        offset: resultOffset,\r\n        result: returnObject\r\n    };\r\n}\r\nfunction fromBER(inputBuffer) {\r\n    if (!inputBuffer.byteLength) {\r\n        const result = new BaseBlock({}, ValueBlock);\r\n        result.error = \"Input buffer has zero length\";\r\n        return {\r\n            offset: -1,\r\n            result\r\n        };\r\n    }\r\n    return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\r\n}\n\nfunction checkLen(indefiniteLength, length) {\r\n    if (indefiniteLength) {\r\n        return 1;\r\n    }\r\n    return length;\r\n}\r\nclass LocalConstructedValueBlock extends ValueBlock {\r\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.isIndefiniteForm = isIndefiniteForm;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (this.valueBeforeDecodeView.length === 0) {\r\n            this.warnings.push(\"Zero buffer length\");\r\n            return inputOffset;\r\n        }\r\n        let currentOffset = inputOffset;\r\n        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\r\n            const returnObject = localFromBER(view, currentOffset, inputLength);\r\n            if (returnObject.offset === -1) {\r\n                this.error = returnObject.result.error;\r\n                this.warnings.concat(returnObject.result.warnings);\r\n                return -1;\r\n            }\r\n            currentOffset = returnObject.offset;\r\n            this.blockLength += returnObject.result.blockLength;\r\n            inputLength -= returnObject.result.blockLength;\r\n            this.value.push(returnObject.result);\r\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\r\n                break;\r\n            }\r\n        }\r\n        if (this.isIndefiniteForm) {\r\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\r\n                this.value.pop();\r\n            }\r\n            else {\r\n                this.warnings.push(\"No EndOfContent block encoded\");\r\n            }\r\n        }\r\n        return currentOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            this.value[i].toBER(sizeOnly, _writer);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            value: [],\r\n        };\r\n        for (const value of this.value) {\r\n            object.value.push(value.toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\n\nvar _a$v;\r\nclass Constructed extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalConstructedValueBlock);\r\n        this.idBlock.isConstructed = true;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        const values = [];\r\n        for (const value of this.valueBlock.value) {\r\n            values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\r\n        }\r\n        const blockName = this.idBlock.tagClass === 3\r\n            ? `[${this.idBlock.tagNumber}]`\r\n            : this.constructor.NAME;\r\n        return values.length\r\n            ? `${blockName} :\\n${values.join(\"\\n\")}`\r\n            : `${blockName} :`;\r\n    }\r\n}\r\n_a$v = Constructed;\r\n(() => {\r\n    typeStore.Constructed = _a$v;\r\n})();\r\nConstructed.NAME = \"CONSTRUCTED\";\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        return inputOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return EMPTY_BUFFER;\r\n    }\r\n}\r\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\n\nvar _a$u;\r\nclass EndOfContent extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalEndOfContentValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 0;\r\n    }\r\n}\r\n_a$u = EndOfContent;\r\n(() => {\r\n    typeStore.EndOfContent = _a$u;\r\n})();\r\nEndOfContent.NAME = END_OF_CONTENT_NAME;\n\nvar _a$t;\r\nclass Null extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, ValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 5;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (this.lenBlock.length > 0)\r\n            this.warnings.push(\"Non-zero length of value block for Null type\");\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        this.blockLength += inputLength;\r\n        if ((inputOffset + inputLength) > inputBuffer.byteLength) {\r\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n            return -1;\r\n        }\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuf = new ArrayBuffer(2);\r\n        if (!sizeOnly) {\r\n            const retView = new Uint8Array(retBuf);\r\n            retView[0] = 0x05;\r\n            retView[1] = 0x00;\r\n        }\r\n        if (writer) {\r\n            writer.write(retBuf);\r\n        }\r\n        return retBuf;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME}`;\r\n    }\r\n}\r\n_a$t = Null;\r\n(() => {\r\n    typeStore.Null = _a$t;\r\n})();\r\nNull.NAME = \"NULL\";\n\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        if (parameters.valueHex) {\r\n            this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);\r\n        }\r\n        else {\r\n            this.valueHexView = new Uint8Array(1);\r\n        }\r\n        if (value) {\r\n            this.value = value;\r\n        }\r\n    }\r\n    get value() {\r\n        for (const octet of this.valueHexView) {\r\n            if (octet > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    set value(value) {\r\n        this.valueHexView[0] = value ? 0xFF : 0x00;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (inputLength > 1)\r\n            this.warnings.push(\"Boolean value encoded in more then 1 octet\");\r\n        this.isHexOnly = true;\r\n        pvutils.utilDecodeTC.call(this);\r\n        this.blockLength = inputLength;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER() {\r\n        return this.valueHexView.slice();\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\n\nvar _a$s;\r\nclass Boolean extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalBooleanValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 1;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.getValue}`;\r\n    }\r\n}\r\n_a$s = Boolean;\r\n(() => {\r\n    typeStore.Boolean = _a$s;\r\n})();\r\nBoolean.NAME = \"BOOLEAN\";\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isConstructed = isConstructed;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = 0;\r\n        if (this.isConstructed) {\r\n            this.isHexOnly = false;\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (let i = 0; i < this.value.length; i++) {\r\n                const currentBlockName = this.value[i].constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== OCTET_STRING_NAME) {\r\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\r\n                    return -1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.isHexOnly = true;\r\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n            this.blockLength = inputLength;\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed)\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.byteLength)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\n\nvar _a$r;\r\nclass OctetString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalOctetStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 4;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        if (inputLength === 0) {\r\n            if (this.idBlock.error.length === 0)\r\n                this.blockLength += this.idBlock.blockLength;\r\n            if (this.lenBlock.error.length === 0)\r\n                this.blockLength += this.lenBlock.blockLength;\r\n            return inputOffset;\r\n        }\r\n        if (!this.valueBlock.isConstructed) {\r\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\r\n                        this.valueBlock.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;\r\n    }\r\n    getValue() {\r\n        if (!this.idBlock.isConstructed) {\r\n            return this.valueBlock.valueHexView.slice().buffer;\r\n        }\r\n        const array = [];\r\n        for (const content of this.valueBlock.value) {\r\n            if (content instanceof OctetString) {\r\n                array.push(content.valueBlock.valueHexView);\r\n            }\r\n        }\r\n        return pvtsutils.BufferSourceConverter.concat(array);\r\n    }\r\n}\r\n_a$r = OctetString;\r\n(() => {\r\n    typeStore.OctetString = _a$r;\r\n})();\r\nOctetString.NAME = OCTET_STRING_NAME;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.unusedBits = unusedBits;\r\n        this.isConstructed = isConstructed;\r\n        this.blockLength = this.valueHexView.byteLength;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        let resultOffset = -1;\r\n        if (this.isConstructed) {\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (const value of this.value) {\r\n                const currentBlockName = value.constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== BIT_STRING_NAME) {\r\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\r\n                    return -1;\r\n                }\r\n                const valueBlock = value.valueBlock;\r\n                if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {\r\n                    this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\r\n                    return -1;\r\n                }\r\n                this.unusedBits = valueBlock.unusedBits;\r\n            }\r\n            return resultOffset;\r\n        }\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.unusedBits = intBuffer[0];\r\n        if (this.unusedBits > 7) {\r\n            this.error = \"Unused bits for BitString must be in range 0-7\";\r\n            return -1;\r\n        }\r\n        if (!this.unusedBits) {\r\n            const buf = intBuffer.subarray(1);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\r\n                        this.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        this.valueHexView = intBuffer.subarray(1);\r\n        this.blockLength = intBuffer.length;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed) {\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        }\r\n        if (sizeOnly) {\r\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\r\n        }\r\n        if (!this.valueHexView.byteLength) {\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.length + 1);\r\n        retView[0] = this.unusedBits;\r\n        retView.set(this.valueHexView, 1);\r\n        return retView.buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            unusedBits: this.unusedBits,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\n\nvar _a$q;\r\nclass BitString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalBitStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 3;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        else {\r\n            const bits = [];\r\n            const valueHex = this.valueBlock.valueHexView;\r\n            for (const byte of valueHex) {\r\n                bits.push(byte.toString(2).padStart(8, \"0\"));\r\n            }\r\n            const bitsStr = bits.join(\"\");\r\n            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\r\n        }\r\n    }\r\n}\r\n_a$q = BitString;\r\n(() => {\r\n    typeStore.BitString = _a$q;\r\n})();\r\nBitString.NAME = BIT_STRING_NAME;\n\nvar _a$p;\r\nfunction viewAdd(first, second) {\r\n    const c = new Uint8Array([0]);\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    let firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value = 0;\r\n    const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\r\n    let counter = 0;\r\n    for (let i = max; i >= 0; i--, counter++) {\r\n        switch (true) {\r\n            case (counter < secondViewCopy.length):\r\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\r\n                break;\r\n            default:\r\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\r\n        }\r\n        c[0] = value / 10;\r\n        switch (true) {\r\n            case (counter >= firstViewCopy.length):\r\n                firstViewCopy = pvutils.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\r\n                break;\r\n            default:\r\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\r\n        }\r\n    }\r\n    if (c[0] > 0)\r\n        firstViewCopy = pvutils.utilConcatView(c, firstViewCopy);\r\n    return firstViewCopy;\r\n}\r\nfunction power2(n) {\r\n    if (n >= powers2.length) {\r\n        for (let p = powers2.length; p <= n; p++) {\r\n            const c = new Uint8Array([0]);\r\n            let digits = (powers2[p - 1]).slice(0);\r\n            for (let i = (digits.length - 1); i >= 0; i--) {\r\n                const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\r\n                c[0] = newValue[0] / 10;\r\n                digits[i] = newValue[0] % 10;\r\n            }\r\n            if (c[0] > 0)\r\n                digits = pvutils.utilConcatView(c, digits);\r\n            powers2.push(digits);\r\n        }\r\n    }\r\n    return powers2[n];\r\n}\r\nfunction viewSub(first, second) {\r\n    let b = 0;\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    const firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value;\r\n    let counter = 0;\r\n    for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\r\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\r\n        switch (true) {\r\n            case (value < 0):\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n                break;\r\n            default:\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n        }\r\n    }\r\n    if (b > 0) {\r\n        for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {\r\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\r\n            if (value < 0) {\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n            }\r\n            else {\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return firstViewCopy.slice();\r\n}\r\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        this._valueDec = 0;\r\n        if (parameters.valueHex) {\r\n            this.setValueHex();\r\n        }\r\n        if (value !== undefined) {\r\n            this.valueDec = value;\r\n        }\r\n    }\r\n    setValueHex() {\r\n        if (this.valueHexView.length >= 4) {\r\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\r\n            this.isHexOnly = true;\r\n            this._valueDec = 0;\r\n        }\r\n        else {\r\n            this.isHexOnly = false;\r\n            if (this.valueHexView.length > 0) {\r\n                this._valueDec = pvutils.utilDecodeTC.call(this);\r\n            }\r\n        }\r\n    }\r\n    set valueDec(v) {\r\n        this._valueDec = v;\r\n        this.isHexOnly = false;\r\n        this.valueHexView = new Uint8Array(pvutils.utilEncodeTC(v));\r\n    }\r\n    get valueDec() {\r\n        return this._valueDec;\r\n    }\r\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\r\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (offset === -1)\r\n            return offset;\r\n        const view = this.valueHexView;\r\n        if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {\r\n            this.valueHexView = view.subarray(1);\r\n        }\r\n        else {\r\n            if (expectedLength !== 0) {\r\n                if (view.length < expectedLength) {\r\n                    if ((expectedLength - view.length) > 1)\r\n                        expectedLength = view.length + 1;\r\n                    this.valueHexView = view.subarray(expectedLength - view.length);\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n    toDER(sizeOnly = false) {\r\n        const view = this.valueHexView;\r\n        switch (true) {\r\n            case ((view[0] & 0x80) !== 0):\r\n                {\r\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\r\n                    updatedView[0] = 0x00;\r\n                    updatedView.set(view, 1);\r\n                    this.valueHexView = updatedView;\r\n                }\r\n                break;\r\n            case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\r\n                {\r\n                    this.valueHexView = this.valueHexView.subarray(1);\r\n                }\r\n                break;\r\n        }\r\n        return this.toBER(sizeOnly);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (resultOffset === -1) {\r\n            return resultOffset;\r\n        }\r\n        this.setValueHex();\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.length)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n    toString() {\r\n        const firstBit = (this.valueHexView.length * 8) - 1;\r\n        let digits = new Uint8Array((this.valueHexView.length * 8) / 3);\r\n        let bitNumber = 0;\r\n        let currentByte;\r\n        const asn1View = this.valueHexView;\r\n        let result = \"\";\r\n        let flag = false;\r\n        for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {\r\n            currentByte = asn1View[byteNumber];\r\n            for (let i = 0; i < 8; i++) {\r\n                if ((currentByte & 1) === 1) {\r\n                    switch (bitNumber) {\r\n                        case firstBit:\r\n                            digits = viewSub(power2(bitNumber), digits);\r\n                            result = \"-\";\r\n                            break;\r\n                        default:\r\n                            digits = viewAdd(digits, power2(bitNumber));\r\n                    }\r\n                }\r\n                bitNumber++;\r\n                currentByte >>= 1;\r\n            }\r\n        }\r\n        for (let i = 0; i < digits.length; i++) {\r\n            if (digits[i])\r\n                flag = true;\r\n            if (flag)\r\n                result += digitsString.charAt(digits[i]);\r\n        }\r\n        if (flag === false)\r\n            result += digitsString.charAt(0);\r\n        return result;\r\n    }\r\n}\r\n_a$p = LocalIntegerValueBlock;\r\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\r\n(() => {\r\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\r\n        set: function (v) {\r\n            this.valueHexView = new Uint8Array(v);\r\n            this.setValueHex();\r\n        },\r\n        get: function () {\r\n            return this.valueHexView.slice().buffer;\r\n        },\r\n    });\r\n})();\n\nvar _a$o;\r\nclass Integer extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalIntegerValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 2;\r\n    }\r\n    toBigInt() {\r\n        assertBigInt();\r\n        return BigInt(this.valueBlock.toString());\r\n    }\r\n    static fromBigInt(value) {\r\n        assertBigInt();\r\n        const bigIntValue = BigInt(value);\r\n        const writer = new ViewWriter();\r\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\r\n        const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));\r\n        if (bigIntValue < 0) {\r\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\r\n            first[0] |= 0x80;\r\n            const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first)}`);\r\n            const secondInt = firstInt + bigIntValue;\r\n            const second = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));\r\n            second[0] |= 0x80;\r\n            writer.write(second);\r\n        }\r\n        else {\r\n            if (view[0] & 0x80) {\r\n                writer.write(new Uint8Array([0]));\r\n            }\r\n            writer.write(view);\r\n        }\r\n        const res = new Integer({\r\n            valueHex: writer.final(),\r\n        });\r\n        return res;\r\n    }\r\n    convertToDER() {\r\n        const integer = new Integer({ valueHex: this.valueBlock.valueHexView });\r\n        integer.valueBlock.toDER();\r\n        return integer;\r\n    }\r\n    convertFromDER() {\r\n        return new Integer({\r\n            valueHex: this.valueBlock.valueHexView[0] === 0\r\n                ? this.valueBlock.valueHexView.subarray(1)\r\n                : this.valueBlock.valueHexView,\r\n        });\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\r\n    }\r\n}\r\n_a$o = Integer;\r\n(() => {\r\n    typeStore.Integer = _a$o;\r\n})();\r\nInteger.NAME = \"INTEGER\";\n\nvar _a$n;\r\nclass Enumerated extends Integer {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 10;\r\n    }\r\n}\r\n_a$n = Enumerated;\r\n(() => {\r\n    typeStore.Enumerated = _a$n;\r\n})();\r\nEnumerated.NAME = \"ENUMERATED\";\n\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n        this.isFirstSid = isFirstSid;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++) {\r\n            tempView[i] = this.valueHexView[i];\r\n        }\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    set valueBigInt(value) {\r\n        assertBigInt();\r\n        let bits = BigInt(value).toString(2);\r\n        while (bits.length % 7) {\r\n            bits = \"0\" + bits;\r\n        }\r\n        const bytes = new Uint8Array(bits.length / 7);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\r\n        }\r\n        this.fromBER(bytes.buffer, 0, bytes.length);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            if (this.isFirstSid) {\r\n                let sidValue = this.valueDec;\r\n                if (this.valueDec <= 39)\r\n                    result = \"0.\";\r\n                else {\r\n                    if (this.valueDec <= 79) {\r\n                        result = \"1.\";\r\n                        sidValue -= 40;\r\n                    }\r\n                    else {\r\n                        result = \"2.\";\r\n                        sidValue -= 80;\r\n                    }\r\n                }\r\n                result += sidValue.toString();\r\n            }\r\n            else\r\n                result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n            isFirstSid: this.isFirstSid,\r\n        };\r\n    }\r\n}\r\nLocalSidValueBlock.NAME = \"sidBlock\";\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            if (this.value.length === 0)\r\n                sidBlock.isFirstSid = true;\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        let flag = false;\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            if (flag) {\r\n                const sidBlock = this.value[0];\r\n                let plus = 0;\r\n                switch (sidBlock.valueDec) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        plus = 40;\r\n                        break;\r\n                    case 2:\r\n                        plus = 80;\r\n                        break;\r\n                    default:\r\n                        this.value = [];\r\n                        return;\r\n                }\r\n                const parsedSID = parseInt(sid, 10);\r\n                if (isNaN(parsedSID))\r\n                    return;\r\n                sidBlock.valueDec = parsedSID + plus;\r\n                flag = false;\r\n            }\r\n            else {\r\n                const sidBlock = new LocalSidValueBlock();\r\n                if (sid > Number.MAX_SAFE_INTEGER) {\r\n                    assertBigInt();\r\n                    const sidValue = BigInt(sid);\r\n                    sidBlock.valueBigInt = sidValue;\r\n                }\r\n                else {\r\n                    sidBlock.valueDec = parseInt(sid, 10);\r\n                    if (isNaN(sidBlock.valueDec))\r\n                        return;\r\n                }\r\n                if (!this.value.length) {\r\n                    sidBlock.isFirstSid = true;\r\n                    flag = true;\r\n                }\r\n                this.value.push(sidBlock);\r\n            }\r\n        } while (pos2 !== -1);\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                if (this.value[i].isFirstSid)\r\n                    result = `2.{${sidStr} - 80}`;\r\n                else\r\n                    result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\n\nvar _a$m;\r\nclass ObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 6;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$m = ObjectIdentifier;\r\n(() => {\r\n    typeStore.ObjectIdentifier = _a$m;\r\n})();\r\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ valueDec = 0, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (inputLength === 0)\r\n            return inputOffset;\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength))\r\n            return -1;\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++)\r\n            tempView[i] = this.valueHexView[i];\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n}\r\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            sidBlock.valueDec = parseInt(sid, 10);\r\n            if (isNaN(sidBlock.valueDec))\r\n                return true;\r\n            this.value.push(sidBlock);\r\n        } while (pos2 !== -1);\r\n        return true;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++)\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        return object;\r\n    }\r\n}\r\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\n\nvar _a$l;\r\nclass RelativeObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 13;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$l = RelativeObjectIdentifier;\r\n(() => {\r\n    typeStore.RelativeObjectIdentifier = _a$l;\r\n})();\r\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\n\nvar _a$k;\r\nclass Sequence extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 16;\r\n    }\r\n}\r\n_a$k = Sequence;\r\n(() => {\r\n    typeStore.Sequence = _a$k;\r\n})();\r\nSequence.NAME = \"SEQUENCE\";\n\nvar _a$j;\r\nclass Set extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 17;\r\n    }\r\n}\r\n_a$j = Set;\r\n(() => {\r\n    typeStore.Set = _a$j;\r\n})();\r\nSet.NAME = \"SET\";\n\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = true;\r\n        this.value = EMPTY_STRING;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalStringValueBlock.NAME = \"StringValueBlock\";\n\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\r\n}\r\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\n\nclass LocalSimpleStringBlock extends BaseStringBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters, LocalSimpleStringValueBlock);\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLen = inputString.length;\r\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\r\n        for (let i = 0; i < strLen; i++)\r\n            view[i] = inputString.charCodeAt(i);\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\n\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        try {\r\n            this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);\r\n        }\r\n        catch (ex) {\r\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\r\n            this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);\r\n        }\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\n\nvar _a$i;\r\nclass Utf8String extends LocalUtf8StringValueBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 12;\r\n    }\r\n}\r\n_a$i = Utf8String;\r\n(() => {\r\n    typeStore.Utf8String = _a$i;\r\n})();\r\nUtf8String.NAME = \"UTF8String\";\n\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);\r\n        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.value = inputString;\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));\r\n    }\r\n}\r\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\n\nvar _a$h;\r\nclass BmpString extends LocalBmpStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 30;\r\n    }\r\n}\r\n_a$h = BmpString;\r\n(() => {\r\n    typeStore.BmpString = _a$h;\r\n})();\r\nBmpString.NAME = \"BMPString\";\n\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\r\n        const valueView = new Uint8Array(copyBuffer);\r\n        for (let i = 0; i < valueView.length; i += 4) {\r\n            valueView[i] = valueView[i + 3];\r\n            valueView[i + 1] = valueView[i + 2];\r\n            valueView[i + 2] = 0x00;\r\n            valueView[i + 3] = 0x00;\r\n        }\r\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLength = inputString.length;\r\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\r\n        for (let i = 0; i < strLength; i++) {\r\n            const codeBuf = pvutils.utilToBase(inputString.charCodeAt(i), 8);\r\n            const codeView = new Uint8Array(codeBuf);\r\n            if (codeView.length > 4)\r\n                continue;\r\n            const dif = 4 - codeView.length;\r\n            for (let j = (codeView.length - 1); j >= 0; j--)\r\n                valueHexView[i * 4 + j + dif] = codeView[j];\r\n        }\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\n\nvar _a$g;\r\nclass UniversalString extends LocalUniversalStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 28;\r\n    }\r\n}\r\n_a$g = UniversalString;\r\n(() => {\r\n    typeStore.UniversalString = _a$g;\r\n})();\r\nUniversalString.NAME = \"UniversalString\";\n\nvar _a$f;\r\nclass NumericString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 18;\r\n    }\r\n}\r\n_a$f = NumericString;\r\n(() => {\r\n    typeStore.NumericString = _a$f;\r\n})();\r\nNumericString.NAME = \"NumericString\";\n\nvar _a$e;\r\nclass PrintableString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 19;\r\n    }\r\n}\r\n_a$e = PrintableString;\r\n(() => {\r\n    typeStore.PrintableString = _a$e;\r\n})();\r\nPrintableString.NAME = \"PrintableString\";\n\nvar _a$d;\r\nclass TeletexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 20;\r\n    }\r\n}\r\n_a$d = TeletexString;\r\n(() => {\r\n    typeStore.TeletexString = _a$d;\r\n})();\r\nTeletexString.NAME = \"TeletexString\";\n\nvar _a$c;\r\nclass VideotexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 21;\r\n    }\r\n}\r\n_a$c = VideotexString;\r\n(() => {\r\n    typeStore.VideotexString = _a$c;\r\n})();\r\nVideotexString.NAME = \"VideotexString\";\n\nvar _a$b;\r\nclass IA5String extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 22;\r\n    }\r\n}\r\n_a$b = IA5String;\r\n(() => {\r\n    typeStore.IA5String = _a$b;\r\n})();\r\nIA5String.NAME = \"IA5String\";\n\nvar _a$a;\r\nclass GraphicString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 25;\r\n    }\r\n}\r\n_a$a = GraphicString;\r\n(() => {\r\n    typeStore.GraphicString = _a$a;\r\n})();\r\nGraphicString.NAME = \"GraphicString\";\n\nvar _a$9;\r\nclass VisibleString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 26;\r\n    }\r\n}\r\n_a$9 = VisibleString;\r\n(() => {\r\n    typeStore.VisibleString = _a$9;\r\n})();\r\nVisibleString.NAME = \"VisibleString\";\n\nvar _a$8;\r\nclass GeneralString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 27;\r\n    }\r\n}\r\n_a$8 = GeneralString;\r\n(() => {\r\n    typeStore.GeneralString = _a$8;\r\n})();\r\nGeneralString.NAME = \"GeneralString\";\n\nvar _a$7;\r\nclass CharacterString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 29;\r\n    }\r\n}\r\n_a$7 = CharacterString;\r\n(() => {\r\n    typeStore.CharacterString = _a$7;\r\n})();\r\nCharacterString.NAME = \"CharacterString\";\n\nvar _a$6;\r\nclass UTCTime extends VisibleString {\r\n    constructor({ value, valueDate, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.year = 0;\r\n        this.month = 0;\r\n        this.day = 0;\r\n        this.hour = 0;\r\n        this.minute = 0;\r\n        this.second = 0;\r\n        if (value) {\r\n            this.fromString(value);\r\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\r\n            for (let i = 0; i < value.length; i++)\r\n                this.valueBlock.valueHexView[i] = value.charCodeAt(i);\r\n        }\r\n        if (valueDate) {\r\n            this.fromDate(valueDate);\r\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\r\n        }\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 23;\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));\r\n    }\r\n    toBuffer() {\r\n        const str = this.toString();\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new Uint8Array(buffer);\r\n        for (let i = 0; i < str.length; i++)\r\n            view[i] = str.charCodeAt(i);\r\n        return buffer;\r\n    }\r\n    fromDate(inputDate) {\r\n        this.year = inputDate.getUTCFullYear();\r\n        this.month = inputDate.getUTCMonth() + 1;\r\n        this.day = inputDate.getUTCDate();\r\n        this.hour = inputDate.getUTCHours();\r\n        this.minute = inputDate.getUTCMinutes();\r\n        this.second = inputDate.getUTCSeconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\r\n    }\r\n    fromString(inputString) {\r\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\r\n        const parserArray = parser.exec(inputString);\r\n        if (parserArray === null) {\r\n            this.error = \"Wrong input string for conversion\";\r\n            return;\r\n        }\r\n        const year = parseInt(parserArray[1], 10);\r\n        if (year >= 50)\r\n            this.year = 1900 + year;\r\n        else\r\n            this.year = 2000 + year;\r\n        this.month = parseInt(parserArray[2], 10);\r\n        this.day = parseInt(parserArray[3], 10);\r\n        this.hour = parseInt(parserArray[4], 10);\r\n        this.minute = parseInt(parserArray[5], 10);\r\n        this.second = parseInt(parserArray[6], 10);\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = new Array(7);\r\n            outputArray[0] = pvutils.padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\r\n            outputArray[1] = pvutils.padNumber(this.month, 2);\r\n            outputArray[2] = pvutils.padNumber(this.day, 2);\r\n            outputArray[3] = pvutils.padNumber(this.hour, 2);\r\n            outputArray[4] = pvutils.padNumber(this.minute, 2);\r\n            outputArray[5] = pvutils.padNumber(this.second, 2);\r\n            outputArray[6] = \"Z\";\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            year: this.year,\r\n            month: this.month,\r\n            day: this.day,\r\n            hour: this.hour,\r\n            minute: this.minute,\r\n            second: this.second,\r\n        };\r\n    }\r\n}\r\n_a$6 = UTCTime;\r\n(() => {\r\n    typeStore.UTCTime = _a$6;\r\n})();\r\nUTCTime.NAME = \"UTCTime\";\n\nvar _a$5;\r\nclass GeneralizedTime extends UTCTime {\r\n    constructor(parameters = {}) {\r\n        var _b;\r\n        super(parameters);\r\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 24;\r\n    }\r\n    fromDate(inputDate) {\r\n        super.fromDate(inputDate);\r\n        this.millisecond = inputDate.getUTCMilliseconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\r\n    }\r\n    fromString(inputString) {\r\n        let isUTC = false;\r\n        let timeString = \"\";\r\n        let dateTimeString = \"\";\r\n        let fractionPart = 0;\r\n        let parser;\r\n        let hourDifference = 0;\r\n        let minuteDifference = 0;\r\n        if (inputString[inputString.length - 1] === \"Z\") {\r\n            timeString = inputString.substring(0, inputString.length - 1);\r\n            isUTC = true;\r\n        }\r\n        else {\r\n            const number = new Number(inputString[inputString.length - 1]);\r\n            if (isNaN(number.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            timeString = inputString;\r\n        }\r\n        if (isUTC) {\r\n            if (timeString.indexOf(\"+\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            if (timeString.indexOf(\"-\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        else {\r\n            let multiplier = 1;\r\n            let differencePosition = timeString.indexOf(\"+\");\r\n            let differenceString = \"\";\r\n            if (differencePosition === -1) {\r\n                differencePosition = timeString.indexOf(\"-\");\r\n                multiplier = -1;\r\n            }\r\n            if (differencePosition !== -1) {\r\n                differenceString = timeString.substring(differencePosition + 1);\r\n                timeString = timeString.substring(0, differencePosition);\r\n                if ((differenceString.length !== 2) && (differenceString.length !== 4))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                let number = parseInt(differenceString.substring(0, 2), 10);\r\n                if (isNaN(number.valueOf()))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                hourDifference = multiplier * number;\r\n                if (differenceString.length === 4) {\r\n                    number = parseInt(differenceString.substring(2, 4), 10);\r\n                    if (isNaN(number.valueOf()))\r\n                        throw new Error(\"Wrong input string for conversion\");\r\n                    minuteDifference = multiplier * number;\r\n                }\r\n            }\r\n        }\r\n        let fractionPointPosition = timeString.indexOf(\".\");\r\n        if (fractionPointPosition === -1)\r\n            fractionPointPosition = timeString.indexOf(\",\");\r\n        if (fractionPointPosition !== -1) {\r\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\r\n            if (isNaN(fractionPartCheck.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            fractionPart = fractionPartCheck.valueOf();\r\n            dateTimeString = timeString.substring(0, fractionPointPosition);\r\n        }\r\n        else\r\n            dateTimeString = timeString;\r\n        switch (true) {\r\n            case (dateTimeString.length === 8):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1)\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                break;\r\n            case (dateTimeString.length === 10):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.minute = Math.floor(fractionResult);\r\n                    fractionResult = 60 * (fractionResult - this.minute);\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 12):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 14):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    const fractionResult = 1000 * fractionPart;\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        const parserArray = parser.exec(dateTimeString);\r\n        if (parserArray === null)\r\n            throw new Error(\"Wrong input string for conversion\");\r\n        for (let j = 1; j < parserArray.length; j++) {\r\n            switch (j) {\r\n                case 1:\r\n                    this.year = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 2:\r\n                    this.month = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 3:\r\n                    this.day = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 4:\r\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\r\n                    break;\r\n                case 5:\r\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\r\n                    break;\r\n                case 6:\r\n                    this.second = parseInt(parserArray[j], 10);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n            }\r\n        }\r\n        if (isUTC === false) {\r\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n            this.year = tempDate.getUTCFullYear();\r\n            this.month = tempDate.getUTCMonth();\r\n            this.day = tempDate.getUTCDay();\r\n            this.hour = tempDate.getUTCHours();\r\n            this.minute = tempDate.getUTCMinutes();\r\n            this.second = tempDate.getUTCSeconds();\r\n            this.millisecond = tempDate.getUTCMilliseconds();\r\n        }\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = [];\r\n            outputArray.push(pvutils.padNumber(this.year, 4));\r\n            outputArray.push(pvutils.padNumber(this.month, 2));\r\n            outputArray.push(pvutils.padNumber(this.day, 2));\r\n            outputArray.push(pvutils.padNumber(this.hour, 2));\r\n            outputArray.push(pvutils.padNumber(this.minute, 2));\r\n            outputArray.push(pvutils.padNumber(this.second, 2));\r\n            if (this.millisecond !== 0) {\r\n                outputArray.push(\".\");\r\n                outputArray.push(pvutils.padNumber(this.millisecond, 3));\r\n            }\r\n            outputArray.push(\"Z\");\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            millisecond: this.millisecond,\r\n        };\r\n    }\r\n}\r\n_a$5 = GeneralizedTime;\r\n(() => {\r\n    typeStore.GeneralizedTime = _a$5;\r\n})();\r\nGeneralizedTime.NAME = \"GeneralizedTime\";\n\nvar _a$4;\r\nclass DATE extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 31;\r\n    }\r\n}\r\n_a$4 = DATE;\r\n(() => {\r\n    typeStore.DATE = _a$4;\r\n})();\r\nDATE.NAME = \"DATE\";\n\nvar _a$3;\r\nclass TimeOfDay extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 32;\r\n    }\r\n}\r\n_a$3 = TimeOfDay;\r\n(() => {\r\n    typeStore.TimeOfDay = _a$3;\r\n})();\r\nTimeOfDay.NAME = \"TimeOfDay\";\n\nvar _a$2;\r\nclass DateTime extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 33;\r\n    }\r\n}\r\n_a$2 = DateTime;\r\n(() => {\r\n    typeStore.DateTime = _a$2;\r\n})();\r\nDateTime.NAME = \"DateTime\";\n\nvar _a$1;\r\nclass Duration extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 34;\r\n    }\r\n}\r\n_a$1 = Duration;\r\n(() => {\r\n    typeStore.Duration = _a$1;\r\n})();\r\nDuration.NAME = \"Duration\";\n\nvar _a;\r\nclass TIME extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 14;\r\n    }\r\n}\r\n_a = TIME;\r\n(() => {\r\n    typeStore.TIME = _a;\r\n})();\r\nTIME.NAME = \"TIME\";\n\nclass Any {\r\n    constructor({ name = EMPTY_STRING, optional = false, } = {}) {\r\n        this.name = name;\r\n        this.optional = optional;\r\n    }\r\n}\n\nclass Choice extends Any {\r\n    constructor({ value = [], ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n    }\r\n}\n\nclass Repeated extends Any {\r\n    constructor({ value = new Any(), local = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.local = local;\r\n    }\r\n}\n\nclass RawData {\r\n    constructor({ data = EMPTY_VIEW } = {}) {\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);\r\n    }\r\n    get data() {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n    set data(value) {\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const endLength = inputOffset + inputLength;\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\r\n        return endLength;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n}\n\nfunction compareSchema(root, inputData, inputSchema) {\r\n    if (inputSchema instanceof Choice) {\r\n        for (let j = 0; j < inputSchema.value.length; j++) {\r\n            const result = compareSchema(root, inputData, inputSchema.value[j]);\r\n            if (result.verified) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n        {\r\n            const _result = {\r\n                verified: false,\r\n                result: {\r\n                    error: \"Wrong values for Choice type\"\r\n                },\r\n            };\r\n            if (inputSchema.hasOwnProperty(NAME))\r\n                _result.name = inputSchema.name;\r\n            return _result;\r\n        }\r\n    }\r\n    if (inputSchema instanceof Any) {\r\n        if (inputSchema.hasOwnProperty(NAME))\r\n            root[inputSchema.name] = inputData;\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if ((root instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong root object\" }\r\n        };\r\n    }\r\n    if ((inputData instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 data\" }\r\n        };\r\n    }\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((ID_BLOCK in inputSchema) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((FROM_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((TO_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    const encodedId = inputSchema.idBlock.toBER(false);\r\n    if (encodedId.byteLength === 0) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error encoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\r\n    if (decodedOffset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error decoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly) {\r\n        if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {\r\n            return {\r\n                verified: false,\r\n                result: { error: \"Wrong ASN.1 schema\" }\r\n            };\r\n        }\r\n        const schemaView = inputSchema.idBlock.valueHexView;\r\n        const asn1View = inputData.idBlock.valueHexView;\r\n        if (schemaView.length !== asn1View.length) {\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < schemaView.length; i++) {\r\n            if (schemaView[i] !== asn1View[1]) {\r\n                return {\r\n                    verified: false,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n    }\r\n    if (inputSchema.name) {\r\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n        if (inputSchema.name)\r\n            root[inputSchema.name] = inputData;\r\n    }\r\n    if (inputSchema instanceof typeStore.Constructed) {\r\n        let admission = 0;\r\n        let result = {\r\n            verified: false,\r\n            result: {\r\n                error: \"Unknown error\",\r\n            }\r\n        };\r\n        let maxLength = inputSchema.valueBlock.value.length;\r\n        if (maxLength > 0) {\r\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                maxLength = inputData.valueBlock.value.length;\r\n            }\r\n        }\r\n        if (maxLength === 0) {\r\n            return {\r\n                verified: true,\r\n                result: root\r\n            };\r\n        }\r\n        if ((inputData.valueBlock.value.length === 0) &&\r\n            (inputSchema.valueBlock.value.length !== 0)) {\r\n            let _optional = true;\r\n            for (let i = 0; i < inputSchema.valueBlock.value.length; i++)\r\n                _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\r\n            if (_optional) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name)\r\n                    delete root[inputSchema.name];\r\n            }\r\n            root.error = \"Inconsistent object length\";\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < maxLength; i++) {\r\n            if ((i - admission) >= inputData.valueBlock.value.length) {\r\n                if (inputSchema.valueBlock.value[i].optional === false) {\r\n                    const _result = {\r\n                        verified: false,\r\n                        result: root\r\n                    };\r\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\r\n                    if (inputSchema.name) {\r\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                        if (inputSchema.name) {\r\n                            delete root[inputSchema.name];\r\n                            _result.name = inputSchema.name;\r\n                        }\r\n                    }\r\n                    return _result;\r\n                }\r\n            }\r\n            else {\r\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[0].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                    if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {\r\n                        let arrayRoot = {};\r\n                        if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))\r\n                            arrayRoot = inputData;\r\n                        else\r\n                            arrayRoot = root;\r\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\r\n                            arrayRoot[inputSchema.valueBlock.value[0].name] = [];\r\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[i].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (result.verified === false) {\r\n            const _result = {\r\n                verified: false,\r\n                result: root\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.primitiveSchema &&\r\n        (VALUE_HEX_VIEW in inputData.valueBlock)) {\r\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\r\n        if (asn1.offset === -1) {\r\n            const _result = {\r\n                verified: false,\r\n                result: asn1.result\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\r\n    }\r\n    return {\r\n        verified: true,\r\n        result: root\r\n    };\r\n}\r\nfunction verifySchema(inputBuffer, inputSchema) {\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema type\" }\r\n        };\r\n    }\r\n    const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    if (asn1.offset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: asn1.result\r\n        };\r\n    }\r\n    return compareSchema(asn1.result, asn1.result, inputSchema);\r\n}\n\nexport { Any, BaseBlock, BaseStringBlock, BitString, BmpString, Boolean, CharacterString, Choice, Constructed, DATE, DateTime, Duration, EndOfContent, Enumerated, GeneralString, GeneralizedTime, GraphicString, HexBlock, IA5String, Integer, Null, NumericString, ObjectIdentifier, OctetString, Primitive, PrintableString, RawData, RelativeObjectIdentifier, Repeated, Sequence, Set, TIME, TeletexString, TimeOfDay, UTCTime, UniversalString, Utf8String, ValueBlock, VideotexString, ViewWriter, VisibleString, compareSchema, fromBER, verifySchema };\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst event_iterator_1 = require(\"./event-iterator\");\nexports.EventIterator = event_iterator_1.EventIterator;\nfunction subscribe(event, options, evOptions) {\n    return new event_iterator_1.EventIterator(({ push }) => {\n        this.addEventListener(event, push, options);\n        return () => this.removeEventListener(event, push, options);\n    }, evOptions);\n}\nexports.subscribe = subscribe;\nexports.default = event_iterator_1.EventIterator;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n","// https://github.com/electron/electron/issues/2288\nfunction isElectron() {\n    // Renderer process\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n        return true;\n    }\n\n    // Main process\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\n        return true;\n    }\n\n    // Detect the user agent when the `nodeIntegration` option is set to false\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n        return true;\n    }\n\n    return false;\n}\n\nmodule.exports = isElectron;\n","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n","'use strict';\nconst isOptionObject = require('is-plain-obj');\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n","module.exports = require('./lib/murmurHash3js');\n","/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;\n\n  long2ip = function(long) {\n    var a, b, c, d;\n    a = (long & (0xff << 24)) >>> 24;\n    b = (long & (0xff << 16)) >>> 16;\n    c = (long & (0xff << 8)) >>> 8;\n    d = long & 0xff;\n    return [a, b, c, d].join('.');\n  };\n\n  ip2long = function(ip) {\n    var b, c, i, j, n, ref;\n    b = [];\n    for (i = j = 0; j <= 3; i = ++j) {\n      if (ip.length === 0) {\n        break;\n      }\n      if (i > 0) {\n        if (ip[0] !== '.') {\n          throw new Error('Invalid IP');\n        }\n        ip = ip.substring(1);\n      }\n      ref = atob(ip), n = ref[0], c = ref[1];\n      ip = ip.substring(c);\n      b.push(n);\n    }\n    if (ip.length !== 0) {\n      throw new Error('Invalid IP');\n    }\n    switch (b.length) {\n      case 1:\n        if (b[0] > 0xFFFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return b[0] >>> 0;\n      case 2:\n        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1]) >>> 0;\n      case 3:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;\n      case 4:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;\n      default:\n        throw new Error('Invalid IP');\n    }\n  };\n\n  chr = function(b) {\n    return b.charCodeAt(0);\n  };\n\n  chr0 = chr('0');\n\n  chra = chr('a');\n\n  chrA = chr('A');\n\n  atob = function(s) {\n    var base, dmax, i, n, start;\n    n = 0;\n    base = 10;\n    dmax = '9';\n    i = 0;\n    if (s.length > 1 && s[i] === '0') {\n      if (s[i + 1] === 'x' || s[i + 1] === 'X') {\n        i += 2;\n        base = 16;\n      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {\n        i++;\n        base = 8;\n        dmax = '7';\n      }\n    }\n    start = i;\n    while (i < s.length) {\n      if ('0' <= s[i] && s[i] <= dmax) {\n        n = (n * base + (chr(s[i]) - chr0)) >>> 0;\n      } else if (base === 16) {\n        if ('a' <= s[i] && s[i] <= 'f') {\n          n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;\n        } else if ('A' <= s[i] && s[i] <= 'F') {\n          n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n      if (n > 0xFFFFFFFF) {\n        throw new Error('too large');\n      }\n      i++;\n    }\n    if (i === start) {\n      throw new Error('empty octet');\n    }\n    return [n, i];\n  };\n\n  Netmask = (function() {\n    function Netmask(net, mask) {\n      var error, i, j, ref;\n      if (typeof net !== 'string') {\n        throw new Error(\"Missing `net' parameter\");\n      }\n      if (!mask) {\n        ref = net.split('/', 2), net = ref[0], mask = ref[1];\n      }\n      if (!mask) {\n        mask = 32;\n      }\n      if (typeof mask === 'string' && mask.indexOf('.') > -1) {\n        try {\n          this.maskLong = ip2long(mask);\n        } catch (error1) {\n          error = error1;\n          throw new Error(\"Invalid mask: \" + mask);\n        }\n        for (i = j = 32; j >= 0; i = --j) {\n          if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {\n            this.bitmask = i;\n            break;\n          }\n        }\n      } else if (mask || mask === 0) {\n        this.bitmask = parseInt(mask, 10);\n        this.maskLong = 0;\n        if (this.bitmask > 0) {\n          this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;\n        }\n      } else {\n        throw new Error(\"Invalid mask: empty\");\n      }\n      try {\n        this.netLong = (ip2long(net) & this.maskLong) >>> 0;\n      } catch (error1) {\n        error = error1;\n        throw new Error(\"Invalid net address: \" + net);\n      }\n      if (!(this.bitmask <= 32)) {\n        throw new Error(\"Invalid mask for ip4: \" + mask);\n      }\n      this.size = Math.pow(2, 32 - this.bitmask);\n      this.base = long2ip(this.netLong);\n      this.mask = long2ip(this.maskLong);\n      this.hostmask = long2ip(~this.maskLong);\n      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;\n      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);\n      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;\n    }\n\n    Netmask.prototype.contains = function(ip) {\n      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {\n        ip = new Netmask(ip);\n      }\n      if (ip instanceof Netmask) {\n        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);\n      } else {\n        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;\n      }\n    };\n\n    Netmask.prototype.next = function(count) {\n      if (count == null) {\n        count = 1;\n      }\n      return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);\n    };\n\n    Netmask.prototype.forEach = function(fn) {\n      var index, lastLong, long;\n      long = ip2long(this.first);\n      lastLong = ip2long(this.last);\n      index = 0;\n      while (long <= lastLong) {\n        fn(long2ip(long), long, index);\n        index++;\n        long++;\n      }\n    };\n\n    Netmask.prototype.toString = function() {\n      return this.base + \"/\" + this.bitmask;\n    };\n\n    return Netmask;\n\n  })();\n\n  exports.ip2long = ip2long;\n\n  exports.long2ip = long2ip;\n\n  exports.Netmask = Netmask;\n\n}).call(this);\n","/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n\n'use strict';\n\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data.buffer)\n            .slice(data.byteOffset, data.byteOffset + data.byteLength)\n            .buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data)\n            || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data)\n            || (data && this.isArrayBuffer(data.buffer));\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < aView.length; i++) {\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        let buffers;\n        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n            buffers = args[0];\n        }\n        else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n            buffers = args[0];\n        }\n        else {\n            if (args[args.length - 1] instanceof Function) {\n                buffers = args.slice(0, args.length - 1);\n            }\n            else {\n                buffers = args;\n            }\n        }\n        let size = 0;\n        for (const buffer of buffers) {\n            size += buffer.byteLength;\n        }\n        const res = new Uint8Array(size);\n        let offset = 0;\n        for (const buffer of buffers) {\n            const view = this.toUint8Array(buffer);\n            res.set(view, offset);\n            offset += view.length;\n        }\n        if (args[args.length - 1] instanceof Function) {\n            return this.toView(res, args[args.length - 1]);\n        }\n        return res.buffer;\n    }\n}\n\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for (let i = 0; i < s.length; i++) {\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for (let i = 0; i < text.length; i++) {\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === STRING_TYPE\n            && HEX_REGEX.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === STRING_TYPE\n            && BASE64_REGEX.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === STRING_TYPE\n            && BASE64URL_REGEX.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        }\n        else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        }\n        else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for (let i = 0; i < stringLength; i++) {\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let result = \"\";\n        const len = buf.length;\n        for (let i = 0; i < len; i++) {\n            const byte = buf[i];\n            if (byte < 16) {\n                result += \"0\";\n            }\n            result += byte.toString(16);\n        }\n        return result;\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for (let i = 0; i < formatted.length; i = i + 2) {\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - (base64.length % 4);\n        if (padCount < 4) {\n            for (let i = 0; i < padCount; i++) {\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\n\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for (let i = 1; i < arguments.length; i++) {\n        const obj = arguments[i];\n        for (const prop in obj) {\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item) => new Uint8Array(item)).forEach((arr) => {\n        for (const item2 of arr) {\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;\n","/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\nfunction getUTCDate(date) {\r\n    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));\r\n}\r\nfunction getParametersValue(parameters, name, defaultValue) {\r\n    var _a;\r\n    if ((parameters instanceof Object) === false) {\r\n        return defaultValue;\r\n    }\r\n    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;\r\n}\r\nfunction bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {\r\n    let result = \"\";\r\n    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {\r\n        const str = item.toString(16).toUpperCase();\r\n        if (str.length === 1) {\r\n            result += \"0\";\r\n        }\r\n        result += str;\r\n        if (insertSpace) {\r\n            result += \" \";\r\n        }\r\n    }\r\n    return result.trim();\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof ArrayBuffer)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction utilFromBase(inputBuffer, inputBase) {\r\n    let result = 0;\r\n    if (inputBuffer.length === 1) {\r\n        return inputBuffer[0];\r\n    }\r\n    for (let i = (inputBuffer.length - 1); i >= 0; i--) {\r\n        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);\r\n    }\r\n    return result;\r\n}\r\nfunction utilToBase(value, base, reserved = (-1)) {\r\n    const internalReserved = reserved;\r\n    let internalValue = value;\r\n    let result = 0;\r\n    let biggest = Math.pow(2, base);\r\n    for (let i = 1; i < 8; i++) {\r\n        if (value < biggest) {\r\n            let retBuf;\r\n            if (internalReserved < 0) {\r\n                retBuf = new ArrayBuffer(i);\r\n                result = i;\r\n            }\r\n            else {\r\n                if (internalReserved < i) {\r\n                    return (new ArrayBuffer(0));\r\n                }\r\n                retBuf = new ArrayBuffer(internalReserved);\r\n                result = internalReserved;\r\n            }\r\n            const retView = new Uint8Array(retBuf);\r\n            for (let j = (i - 1); j >= 0; j--) {\r\n                const basis = Math.pow(2, j * base);\r\n                retView[result - j - 1] = Math.floor(internalValue / basis);\r\n                internalValue -= (retView[result - j - 1]) * basis;\r\n            }\r\n            return retBuf;\r\n        }\r\n        biggest *= Math.pow(2, base);\r\n    }\r\n    return new ArrayBuffer(0);\r\n}\r\nfunction utilConcatBuf(...buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (const buffer of buffers) {\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retBuf = new ArrayBuffer(outputLength);\r\n    const retView = new Uint8Array(retBuf);\r\n    for (const buffer of buffers) {\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retBuf;\r\n}\r\nfunction utilConcatView(...views) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (const view of views) {\r\n        outputLength += view.length;\r\n    }\r\n    const retBuf = new ArrayBuffer(outputLength);\r\n    const retView = new Uint8Array(retBuf);\r\n    for (const view of views) {\r\n        retView.set(view, prevLength);\r\n        prevLength += view.length;\r\n    }\r\n    return retView;\r\n}\r\nfunction utilDecodeTC() {\r\n    const buf = new Uint8Array(this.valueHex);\r\n    if (this.valueHex.byteLength >= 2) {\r\n        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);\r\n        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);\r\n        if (condition1 || condition2) {\r\n            this.warnings.push(\"Needlessly long format\");\r\n        }\r\n    }\r\n    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n    const bigIntView = new Uint8Array(bigIntBuffer);\r\n    for (let i = 0; i < this.valueHex.byteLength; i++) {\r\n        bigIntView[i] = 0;\r\n    }\r\n    bigIntView[0] = (buf[0] & 0x80);\r\n    const bigInt = utilFromBase(bigIntView, 8);\r\n    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n    const smallIntView = new Uint8Array(smallIntBuffer);\r\n    for (let j = 0; j < this.valueHex.byteLength; j++) {\r\n        smallIntView[j] = buf[j];\r\n    }\r\n    smallIntView[0] &= 0x7F;\r\n    const smallInt = utilFromBase(smallIntView, 8);\r\n    return (smallInt - bigInt);\r\n}\r\nfunction utilEncodeTC(value) {\r\n    const modValue = (value < 0) ? (value * (-1)) : value;\r\n    let bigInt = 128;\r\n    for (let i = 1; i < 8; i++) {\r\n        if (modValue <= bigInt) {\r\n            if (value < 0) {\r\n                const smallInt = bigInt - modValue;\r\n                const retBuf = utilToBase(smallInt, 8, i);\r\n                const retView = new Uint8Array(retBuf);\r\n                retView[0] |= 0x80;\r\n                return retBuf;\r\n            }\r\n            let retBuf = utilToBase(modValue, 8, i);\r\n            let retView = new Uint8Array(retBuf);\r\n            if (retView[0] & 0x80) {\r\n                const tempBuf = retBuf.slice(0);\r\n                const tempView = new Uint8Array(tempBuf);\r\n                retBuf = new ArrayBuffer(retBuf.byteLength + 1);\r\n                retView = new Uint8Array(retBuf);\r\n                for (let k = 0; k < tempBuf.byteLength; k++) {\r\n                    retView[k + 1] = tempView[k];\r\n                }\r\n                retView[0] = 0x00;\r\n            }\r\n            return retBuf;\r\n        }\r\n        bigInt *= Math.pow(2, 8);\r\n    }\r\n    return (new ArrayBuffer(0));\r\n}\r\nfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\r\n    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {\r\n        return false;\r\n    }\r\n    const view1 = new Uint8Array(inputBuffer1);\r\n    const view2 = new Uint8Array(inputBuffer2);\r\n    for (let i = 0; i < view1.length; i++) {\r\n        if (view1[i] !== view2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction padNumber(inputNumber, fullLength) {\r\n    const str = inputNumber.toString(10);\r\n    if (fullLength < str.length) {\r\n        return \"\";\r\n    }\r\n    const dif = fullLength - str.length;\r\n    const padding = new Array(dif);\r\n    for (let i = 0; i < dif; i++) {\r\n        padding[i] = \"0\";\r\n    }\r\n    const paddingString = padding.join(\"\");\r\n    return paddingString.concat(str);\r\n}\r\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\r\nfunction toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {\r\n    let i = 0;\r\n    let flag1 = 0;\r\n    let flag2 = 0;\r\n    let output = \"\";\r\n    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n    if (skipLeadingZeros) {\r\n        let nonZeroPosition = 0;\r\n        for (let i = 0; i < input.length; i++) {\r\n            if (input.charCodeAt(i) !== 0) {\r\n                nonZeroPosition = i;\r\n                break;\r\n            }\r\n        }\r\n        input = input.slice(nonZeroPosition);\r\n    }\r\n    while (i < input.length) {\r\n        const chr1 = input.charCodeAt(i++);\r\n        if (i >= input.length) {\r\n            flag1 = 1;\r\n        }\r\n        const chr2 = input.charCodeAt(i++);\r\n        if (i >= input.length) {\r\n            flag2 = 1;\r\n        }\r\n        const chr3 = input.charCodeAt(i++);\r\n        const enc1 = chr1 >> 2;\r\n        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);\r\n        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);\r\n        let enc4 = chr3 & 0x3F;\r\n        if (flag1 === 1) {\r\n            enc3 = enc4 = 64;\r\n        }\r\n        else {\r\n            if (flag2 === 1) {\r\n                enc4 = 64;\r\n            }\r\n        }\r\n        if (skipPadding) {\r\n            if (enc3 === 64) {\r\n                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;\r\n            }\r\n            else {\r\n                if (enc4 === 64) {\r\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\r\n                }\r\n                else {\r\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {\r\n    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n    function indexOf(toSearch) {\r\n        for (let i = 0; i < 64; i++) {\r\n            if (template.charAt(i) === toSearch)\r\n                return i;\r\n        }\r\n        return 64;\r\n    }\r\n    function test(incoming) {\r\n        return ((incoming === 64) ? 0x00 : incoming);\r\n    }\r\n    let i = 0;\r\n    let output = \"\";\r\n    while (i < input.length) {\r\n        const enc1 = indexOf(input.charAt(i++));\r\n        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));\r\n        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);\r\n        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);\r\n        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);\r\n        output += String.fromCharCode(chr1);\r\n        if (enc3 !== 64) {\r\n            output += String.fromCharCode(chr2);\r\n        }\r\n        if (enc4 !== 64) {\r\n            output += String.fromCharCode(chr3);\r\n        }\r\n    }\r\n    if (cutTailZeros) {\r\n        const outputLength = output.length;\r\n        let nonZeroStart = (-1);\r\n        for (let i = (outputLength - 1); i >= 0; i--) {\r\n            if (output.charCodeAt(i) !== 0) {\r\n                nonZeroStart = i;\r\n                break;\r\n            }\r\n        }\r\n        if (nonZeroStart !== (-1)) {\r\n            output = output.slice(0, nonZeroStart + 1);\r\n        }\r\n        else {\r\n            output = \"\";\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction arrayBufferToString(buffer) {\r\n    let resultString = \"\";\r\n    const view = new Uint8Array(buffer);\r\n    for (const element of view) {\r\n        resultString += String.fromCharCode(element);\r\n    }\r\n    return resultString;\r\n}\r\nfunction stringToArrayBuffer(str) {\r\n    const stringLength = str.length;\r\n    const resultBuffer = new ArrayBuffer(stringLength);\r\n    const resultView = new Uint8Array(resultBuffer);\r\n    for (let i = 0; i < stringLength; i++) {\r\n        resultView[i] = str.charCodeAt(i);\r\n    }\r\n    return resultBuffer;\r\n}\r\nconst log2 = Math.log(2);\r\nfunction nearestPowerOf2(length) {\r\n    const base = (Math.log(length) / log2);\r\n    const floor = Math.floor(base);\r\n    const round = Math.round(base);\r\n    return ((floor === round) ? floor : round);\r\n}\r\nfunction clearProps(object, propsArray) {\r\n    for (const prop of propsArray) {\r\n        delete object[prop];\r\n    }\r\n}\n\nexport { arrayBufferToString, bufferToHexCodes, checkBufferParams, clearProps, fromBase64, getParametersValue, getUTCDate, isEqualBuffer, nearestPowerOf2, padNumber, stringToArrayBuffer, toBase64, utilConcatBuf, utilConcatView, utilDecodeTC, utilEncodeTC, utilFromBase, utilToBase };\n","import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n/** Check if `input` is IPv4. */\nexport function isIPv4(input) {\n    return Boolean(parseIPv4(input));\n}\n/** Check if `input` is IPv6. */\nexport function isIPv6(input) {\n    return Boolean(parseIPv6(input));\n}\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input) {\n    return Boolean(parseIP(input));\n}\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input) {\n    if (isIPv4(input)) {\n        return 4;\n    }\n    else if (isIPv6(input)) {\n        return 6;\n    }\n    else {\n        return undefined;\n    }\n}\n//# sourceMappingURL=is-ip.js.map","import { Parser } from \"./parser.js\";\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\nconst parser = new Parser();\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input) {\n    if (input.length > MAX_IPV4_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input) {\n    // strip zone index if it is present\n    if (input.includes(\"%\")) {\n        input = input.split(\"%\")[0];\n    }\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input) {\n    // strip zone index if it is present\n    if (input.includes(\"%\")) {\n        input = input.split(\"%\")[0];\n    }\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPAddr());\n}\n//# sourceMappingURL=parse.js.map","/* eslint-disable @typescript-eslint/no-unsafe-return */\nexport class Parser {\n    index = 0;\n    input = \"\";\n    new(input) {\n        this.index = 0;\n        this.input = input;\n        return this;\n    }\n    /** Run a parser, and restore the pre-parse state if it fails. */\n    readAtomically(fn) {\n        const index = this.index;\n        const result = fn();\n        if (result === undefined) {\n            this.index = index;\n        }\n        return result;\n    }\n    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n    parseWith(fn) {\n        const result = fn();\n        if (this.index !== this.input.length) {\n            return undefined;\n        }\n        return result;\n    }\n    /** Peek the next character from the input */\n    peekChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index];\n    }\n    /** Read the next character from the input */\n    readChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index++];\n    }\n    /** Read the next character from the input if it matches the target. */\n    readGivenChar(target) {\n        return this.readAtomically(() => {\n            const char = this.readChar();\n            if (char !== target) {\n                return undefined;\n            }\n            return char;\n        });\n    }\n    /**\n     * Helper for reading separators in an indexed loop. Reads the separator\n     * character iff index > 0, then runs the parser. When used in a loop,\n     * the separator character will only be read on index > 0 (see\n     * readIPv4Addr for an example)\n     */\n    readSeparator(sep, index, inner) {\n        return this.readAtomically(() => {\n            if (index > 0) {\n                if (this.readGivenChar(sep) === undefined) {\n                    return undefined;\n                }\n            }\n            return inner();\n        });\n    }\n    /**\n     * Read a number off the front of the input in the given radix, stopping\n     * at the first non-digit character or eof. Fails if the number has more\n     * digits than max_digits or if there is no number.\n     */\n    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {\n        return this.readAtomically(() => {\n            let result = 0;\n            let digitCount = 0;\n            const leadingChar = this.peekChar();\n            if (leadingChar === undefined) {\n                return undefined;\n            }\n            const hasLeadingZero = leadingChar === \"0\";\n            const maxValue = 2 ** (8 * maxBytes) - 1;\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const digit = this.readAtomically(() => {\n                    const char = this.readChar();\n                    if (char === undefined) {\n                        return undefined;\n                    }\n                    const num = Number.parseInt(char, radix);\n                    if (Number.isNaN(num)) {\n                        return undefined;\n                    }\n                    return num;\n                });\n                if (digit === undefined) {\n                    break;\n                }\n                result *= radix;\n                result += digit;\n                if (result > maxValue) {\n                    return undefined;\n                }\n                digitCount += 1;\n                if (maxDigits !== undefined) {\n                    if (digitCount > maxDigits) {\n                        return undefined;\n                    }\n                }\n            }\n            if (digitCount === 0) {\n                return undefined;\n            }\n            else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n                return undefined;\n            }\n            else {\n                return result;\n            }\n        });\n    }\n    /** Read an IPv4 address. */\n    readIPv4Addr() {\n        return this.readAtomically(() => {\n            const out = new Uint8Array(4);\n            for (let i = 0; i < out.length; i++) {\n                const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n                if (ix === undefined) {\n                    return undefined;\n                }\n                out[i] = ix;\n            }\n            return out;\n        });\n    }\n    /** Read an IPv6 Address. */\n    readIPv6Addr() {\n        /**\n         * Read a chunk of an IPv6 address into `groups`. Returns the number\n         * of groups read, along with a bool indicating if an embedded\n         * trailing IPv4 address was read. Specifically, read a series of\n         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n         * trailing embedded IPv4 address.\n         */\n        const readGroups = (groups) => {\n            for (let i = 0; i < groups.length / 2; i++) {\n                const ix = i * 2;\n                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n                if (i < groups.length - 3) {\n                    const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n                    if (ipv4 !== undefined) {\n                        groups[ix] = ipv4[0];\n                        groups[ix + 1] = ipv4[1];\n                        groups[ix + 2] = ipv4[2];\n                        groups[ix + 3] = ipv4[3];\n                        return [ix + 4, true];\n                    }\n                }\n                const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n                if (group === undefined) {\n                    return [ix, false];\n                }\n                groups[ix] = group >> 8;\n                groups[ix + 1] = group & 255;\n            }\n            return [groups.length, false];\n        };\n        return this.readAtomically(() => {\n            // Read the front part of the address; either the whole thing, or up to the first ::\n            const head = new Uint8Array(16);\n            const [headSize, headIp4] = readGroups(head);\n            if (headSize === 16) {\n                return head;\n            }\n            // IPv4 part is not allowed before `::`\n            if (headIp4) {\n                return undefined;\n            }\n            // Read `::` if previous code parsed less than 8 groups.\n            // `::` indicates one or more groups of 16 bits of zeros.\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            // Read the back part of the address. The :: must contain at least one\n            // set of zeroes, so our max length is 7.\n            const tail = new Uint8Array(14);\n            const limit = 16 - (headSize + 2);\n            const [tailSize] = readGroups(tail.subarray(0, limit));\n            // Concat the head and tail of the IP address\n            head.set(tail.subarray(0, tailSize), 16 - tailSize);\n            return head;\n        });\n    }\n    /** Read an IP Address, either IPv4 or IPv6. */\n    readIPAddr() {\n        return this.readIPv4Addr() ?? this.readIPv6Addr();\n    }\n}\n//# sourceMappingURL=parser.js.map","export const NOISE_MSG_MAX_LENGTH_BYTES = 65535;\nexport const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;\nexport const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);\n//# sourceMappingURL=constants.js.map","export function wrapCrypto(crypto) {\n    return {\n        generateKeypair: crypto.generateX25519KeyPair,\n        dh: (keypair, publicKey) => crypto.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),\n        encrypt: crypto.chaCha20Poly1305Encrypt,\n        decrypt: crypto.chaCha20Poly1305Decrypt,\n        hash: crypto.hashSHA256,\n        hkdf: crypto.getHKDF\n    };\n}\n//# sourceMappingURL=crypto.js.map","import { pureJsCrypto } from './js.js';\nexport const defaultCrypto = pureJsCrypto;\n//# sourceMappingURL=index.browser.js.map","import { chacha20poly1305 } from '@noble/ciphers/chacha';\nimport { x25519 } from '@noble/curves/ed25519';\nimport { extract, expand } from '@noble/hashes/hkdf';\nimport { sha256 } from '@noble/hashes/sha256';\nexport const pureJsCrypto = {\n    hashSHA256(data) {\n        return sha256(data.subarray());\n    },\n    getHKDF(ck, ikm) {\n        const prk = extract(sha256, ikm, ck);\n        const okmU8Array = expand(sha256, prk, undefined, 96);\n        const okm = okmU8Array;\n        const k1 = okm.subarray(0, 32);\n        const k2 = okm.subarray(32, 64);\n        const k3 = okm.subarray(64, 96);\n        return [k1, k2, k3];\n    },\n    generateX25519KeyPair() {\n        const secretKey = x25519.utils.randomPrivateKey();\n        const publicKey = x25519.getPublicKey(secretKey);\n        return {\n            publicKey,\n            privateKey: secretKey\n        };\n    },\n    generateX25519KeyPairFromSeed(seed) {\n        const publicKey = x25519.getPublicKey(seed);\n        return {\n            publicKey,\n            privateKey: seed\n        };\n    },\n    generateX25519SharedKey(privateKey, publicKey) {\n        return x25519.getSharedSecret(privateKey.subarray(), publicKey.subarray());\n    },\n    chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {\n        return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());\n    },\n    chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {\n        return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);\n    }\n};\n//# sourceMappingURL=js.js.map","import {} from 'uint8arraylist';\nimport { allocUnsafe as uint8ArrayAllocUnsafe } from 'uint8arrays/alloc';\nexport const uint16BEEncode = (value) => {\n    const target = uint8ArrayAllocUnsafe(2);\n    target[0] = value >> 8;\n    target[1] = value;\n    return target;\n};\nuint16BEEncode.bytes = 2;\nexport const uint16BEDecode = (data) => {\n    if (data.length < 2)\n        throw RangeError('Could not decode int16BE');\n    if (data instanceof Uint8Array) {\n        let value = 0;\n        value += data[0] << 8;\n        value += data[1];\n        return value;\n    }\n    return data.getUint16(0);\n};\nuint16BEDecode.bytes = 2;\n//# sourceMappingURL=encoder.js.map","export class UnexpectedPeerError extends Error {\n    code;\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.code = UnexpectedPeerError.code;\n    }\n    static code = 'ERR_UNEXPECTED_PEER';\n}\nexport class InvalidCryptoExchangeError extends Error {\n    code;\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.code = InvalidCryptoExchangeError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_EXCHANGE';\n}\n//# sourceMappingURL=errors.js.map","import { Noise } from './noise.js';\nexport { pureJsCrypto } from './crypto/js.js';\nexport function noise(init = {}) {\n    return (components) => new Noise(components, init);\n}\n//# sourceMappingURL=index.js.map","import { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { DUMP_SESSION_KEYS } from './constants.js';\nexport function logLocalStaticKeys(s, keyLogger) {\n    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n        return;\n    }\n    if (s) {\n        keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`);\n        keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`);\n    }\n    else {\n        keyLogger('Missing local static keys.');\n    }\n}\nexport function logLocalEphemeralKeys(e, keyLogger) {\n    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n        return;\n    }\n    if (e) {\n        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`);\n        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`);\n    }\n    else {\n        keyLogger('Missing local ephemeral keys.');\n    }\n}\nexport function logRemoteStaticKey(rs, keyLogger) {\n    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n        return;\n    }\n    if (rs) {\n        keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs.subarray(), 'hex')}`);\n    }\n    else {\n        keyLogger('Missing remote static public key.');\n    }\n}\nexport function logRemoteEphemeralKey(re, keyLogger) {\n    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n        return;\n    }\n    if (re) {\n        keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re.subarray(), 'hex')}`);\n    }\n    else {\n        keyLogger('Missing remote ephemeral keys.');\n    }\n}\nexport function logCipherState(cs1, cs2, keyLogger) {\n    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {\n        return;\n    }\n    keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && uint8ArrayToString(cs1.k, 'hex')}`);\n    keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && uint8ArrayToString(cs2.k, 'hex')}`);\n}\n//# sourceMappingURL=logger.js.map","export function registerMetrics(metrics) {\n    return {\n        xxHandshakeSuccesses: metrics.registerCounter('libp2p_noise_xxhandshake_successes_total', {\n            help: 'Total count of noise xxHandshakes successes_'\n        }),\n        xxHandshakeErrors: metrics.registerCounter('libp2p_noise_xxhandshake_error_total', {\n            help: 'Total count of noise xxHandshakes errors'\n        }),\n        encryptedPackets: metrics.registerCounter('libp2p_noise_encrypted_packets_total', {\n            help: 'Total count of noise encrypted packets successfully'\n        }),\n        decryptedPackets: metrics.registerCounter('libp2p_noise_decrypted_packets_total', {\n            help: 'Total count of noise decrypted packets'\n        }),\n        decryptErrors: metrics.registerCounter('libp2p_noise_decrypt_errors_total', {\n            help: 'Total count of noise decrypt errors'\n        })\n    };\n}\n//# sourceMappingURL=metrics.js.map","import { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { CodeError, serviceCapabilities, isPeerId } from '@libp2p/interface';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { decode } from 'it-length-prefixed';\nimport { lpStream } from 'it-length-prefixed-stream';\nimport { duplexPair } from 'it-pair/duplex';\nimport { pipe } from 'it-pipe';\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js';\nimport { defaultCrypto } from './crypto/index.js';\nimport { wrapCrypto } from './crypto.js';\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js';\nimport { registerMetrics } from './metrics.js';\nimport { performHandshakeInitiator, performHandshakeResponder } from './performHandshake.js';\nimport { decryptStream, encryptStream } from './streaming.js';\nexport class Noise {\n    protocol = '/noise';\n    crypto;\n    prologue;\n    staticKey;\n    extensions;\n    metrics;\n    components;\n    constructor(components, init = {}) {\n        const { staticNoiseKey, extensions, crypto, prologueBytes } = init;\n        const { metrics } = components;\n        this.components = components;\n        const _crypto = crypto ?? defaultCrypto;\n        this.crypto = wrapCrypto(_crypto);\n        this.extensions = extensions;\n        this.metrics = metrics ? registerMetrics(metrics) : undefined;\n        if (staticNoiseKey) {\n            // accepts x25519 private key of length 32\n            this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);\n        }\n        else {\n            this.staticKey = _crypto.generateX25519KeyPair();\n        }\n        this.prologue = prologueBytes ?? uint8ArrayAlloc(0);\n    }\n    [Symbol.toStringTag] = '@chainsafe/libp2p-noise';\n    [serviceCapabilities] = [\n        '@libp2p/connection-encryption',\n        '@chainsafe/libp2p-noise'\n    ];\n    async secureOutbound(...args) {\n        const { localPeer, connection, remotePeer, signal } = this.parseArgs(args);\n        const wrappedConnection = lpStream(connection, {\n            lengthEncoder: uint16BEEncode,\n            lengthDecoder: uint16BEDecode,\n            maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        if (!localPeer.privateKey) {\n            throw new CodeError('local peerId does not contain private key', 'ERR_NO_PRIVATE_KEY');\n        }\n        const privateKey = await unmarshalPrivateKey(localPeer.privateKey);\n        const remoteIdentityKey = remotePeer?.publicKey;\n        const handshake = await this.performHandshakeInitiator(wrappedConnection, privateKey, remoteIdentityKey, {\n            signal\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        connection.source = conn.source;\n        connection.sink = conn.sink;\n        return {\n            conn: connection,\n            remoteExtensions: handshake.payload.extensions,\n            remotePeer: await peerIdFromKeys(handshake.payload.identityKey)\n        };\n    }\n    async secureInbound(...args) {\n        const { localPeer, connection, remotePeer, signal } = this.parseArgs(args);\n        const wrappedConnection = lpStream(connection, {\n            lengthEncoder: uint16BEEncode,\n            lengthDecoder: uint16BEDecode,\n            maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        if (!localPeer.privateKey) {\n            throw new CodeError('local peerId does not contain private key', 'ERR_NO_PRIVATE_KEY');\n        }\n        const privateKey = await unmarshalPrivateKey(localPeer.privateKey);\n        const remoteIdentityKey = remotePeer?.publicKey;\n        const handshake = await this.performHandshakeResponder(wrappedConnection, privateKey, remoteIdentityKey, {\n            signal\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        connection.source = conn.source;\n        connection.sink = conn.sink;\n        return {\n            conn: connection,\n            remoteExtensions: handshake.payload.extensions,\n            remotePeer: await peerIdFromKeys(handshake.payload.identityKey)\n        };\n    }\n    /**\n     * Perform XX handshake as initiator.\n     */\n    async performHandshakeInitiator(connection, \n    // TODO: pass private key in noise constructor via Components\n    privateKey, remoteIdentityKey, options) {\n        let result;\n        try {\n            result = await performHandshakeInitiator({\n                connection,\n                privateKey,\n                remoteIdentityKey,\n                log: this.components.logger.forComponent('libp2p:noise:xxhandshake'),\n                crypto: this.crypto,\n                prologue: this.prologue,\n                s: this.staticKey,\n                extensions: this.extensions\n            }, options);\n            this.metrics?.xxHandshakeSuccesses.increment();\n        }\n        catch (e) {\n            this.metrics?.xxHandshakeErrors.increment();\n            throw e;\n        }\n        return result;\n    }\n    /**\n     * Perform XX handshake as responder.\n     */\n    async performHandshakeResponder(connection, \n    // TODO: pass private key in noise constructor via Components\n    privateKey, remoteIdentityKey, options) {\n        let result;\n        try {\n            result = await performHandshakeResponder({\n                connection,\n                privateKey,\n                remoteIdentityKey,\n                log: this.components.logger.forComponent('libp2p:noise:xxhandshake'),\n                crypto: this.crypto,\n                prologue: this.prologue,\n                s: this.staticKey,\n                extensions: this.extensions\n            }, options);\n            this.metrics?.xxHandshakeSuccesses.increment();\n        }\n        catch (e) {\n            this.metrics?.xxHandshakeErrors.increment();\n            throw e;\n        }\n        return result;\n    }\n    async createSecureConnection(connection, handshake) {\n        // Create encryption box/unbox wrapper\n        const [secure, user] = duplexPair();\n        const network = connection.unwrap();\n        await pipe(secure, // write to wrapper\n        encryptStream(handshake, this.metrics), // encrypt data + prefix with message length\n        network, // send to the remote peer\n        (source) => decode(source, { lengthDecoder: uint16BEDecode }), // read message length prefix\n        decryptStream(handshake, this.metrics), // decrypt the incoming data\n        secure // pipe to the wrapper\n        );\n        return user;\n    }\n    /**\n     * Detect call signature in `libp2p@1.x.x` or `libp2p@2.x.x` style.\n     *\n     * TODO: remove this after `libp2p@2.x.x` is released and only support the\n     * newer style\n     */\n    parseArgs(args) {\n        // if the first argument is a peer id, we're using the libp2p@1.x.x style\n        if (isPeerId(args[0])) {\n            return {\n                localPeer: args[0],\n                connection: args[1],\n                remotePeer: args[2]\n            };\n        }\n        else {\n            // handle upcoming changes in libp2p@2.x.x where the first argument is the\n            // connection and the second is optionally the remote peer\n            // @see https://github.com/libp2p/js-libp2p/pull/2304\n            return {\n                localPeer: this.components.peerId,\n                connection: args[0],\n                remotePeer: args[1]?.remotePeer,\n                signal: args[1]?.signal\n            };\n        }\n    }\n}\n//# sourceMappingURL=noise.js.map","import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nexport const MIN_NONCE = 0;\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport const MAX_NONCE = 0xffffffff;\nconst ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed';\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport class Nonce {\n    n;\n    bytes;\n    view;\n    constructor(n = MIN_NONCE) {\n        this.n = n;\n        this.bytes = uint8ArrayAlloc(12);\n        this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);\n        this.view.setUint32(4, n, true);\n    }\n    increment() {\n        this.n++;\n        // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n        this.view.setUint32(4, this.n, true);\n    }\n    getBytes() {\n        return this.bytes;\n    }\n    getUint64() {\n        return this.n;\n    }\n    assertValue() {\n        if (this.n > MAX_NONCE) {\n            throw new Error(ERR_MAX_NONCE);\n        }\n    }\n}\n//# sourceMappingURL=nonce.js.map","import { logLocalStaticKeys, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey, logCipherState } from './logger.js';\nimport { ZEROLEN, XXHandshakeState } from './protocol.js';\nimport { createHandshakePayload, decodeHandshakePayload } from './utils.js';\nexport async function performHandshakeInitiator(init, options) {\n    const { log, connection, crypto, privateKey, prologue, s, remoteIdentityKey, extensions } = init;\n    const payload = await createHandshakePayload(privateKey, s.publicKey, extensions);\n    const xx = new XXHandshakeState({\n        crypto,\n        protocolName: 'Noise_XX_25519_ChaChaPoly_SHA256',\n        initiator: true,\n        prologue,\n        s\n    });\n    logLocalStaticKeys(xx.s, log);\n    log.trace('Stage 0 - Initiator starting to send first message.');\n    await connection.write(xx.writeMessageA(ZEROLEN), options);\n    log.trace('Stage 0 - Initiator finished sending first message.');\n    logLocalEphemeralKeys(xx.e, log);\n    log.trace('Stage 1 - Initiator waiting to receive first message from responder...');\n    const plaintext = xx.readMessageB(await connection.read(options));\n    log.trace('Stage 1 - Initiator received the message.');\n    logRemoteEphemeralKey(xx.re, log);\n    logRemoteStaticKey(xx.rs, log);\n    log.trace(\"Initiator going to check remote's signature...\");\n    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);\n    log.trace('All good with the signature!');\n    log.trace('Stage 2 - Initiator sending third handshake message.');\n    await connection.write(xx.writeMessageC(payload), options);\n    log.trace('Stage 2 - Initiator sent message with signed payload.');\n    const [cs1, cs2] = xx.ss.split();\n    logCipherState(cs1, cs2, log);\n    return {\n        payload: receivedPayload,\n        encrypt: (plaintext) => cs1.encryptWithAd(ZEROLEN, plaintext),\n        decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)\n    };\n}\nexport async function performHandshakeResponder(init, options) {\n    const { log, connection, crypto, privateKey, prologue, s, remoteIdentityKey, extensions } = init;\n    const payload = await createHandshakePayload(privateKey, s.publicKey, extensions);\n    const xx = new XXHandshakeState({\n        crypto,\n        protocolName: 'Noise_XX_25519_ChaChaPoly_SHA256',\n        initiator: false,\n        prologue,\n        s\n    });\n    logLocalStaticKeys(xx.s, log);\n    log.trace('Stage 0 - Responder waiting to receive first message.');\n    xx.readMessageA(await connection.read(options));\n    log.trace('Stage 0 - Responder received first message.');\n    logRemoteEphemeralKey(xx.re, log);\n    log.trace('Stage 1 - Responder sending out first message with signed payload and static key.');\n    await connection.write(xx.writeMessageB(payload), options);\n    log.trace('Stage 1 - Responder sent the second handshake message with signed payload.');\n    logLocalEphemeralKeys(xx.e, log);\n    log.trace('Stage 2 - Responder waiting for third handshake message...');\n    const plaintext = xx.readMessageC(await connection.read(options));\n    log.trace('Stage 2 - Responder received the message, finished handshake.');\n    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);\n    const [cs1, cs2] = xx.ss.split();\n    logCipherState(cs1, cs2, log);\n    return {\n        payload: receivedPayload,\n        encrypt: (plaintext) => cs2.encryptWithAd(ZEROLEN, plaintext),\n        decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)\n    };\n}\n//# sourceMappingURL=performHandshake.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { decodeMessage, encodeMessage, message } from 'protons-runtime';\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nexport var NoiseExtensions;\n(function (NoiseExtensions) {\n    let _codec;\n    NoiseExtensions.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.webtransportCerthashes != null) {\n                    for (const value of obj.webtransportCerthashes) {\n                        w.uint32(10);\n                        w.bytes(value);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    webtransportCerthashes: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.webtransportCerthashes.push(reader.bytes());\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    NoiseExtensions.encode = (obj) => {\n        return encodeMessage(obj, NoiseExtensions.codec());\n    };\n    NoiseExtensions.decode = (buf) => {\n        return decodeMessage(buf, NoiseExtensions.codec());\n    };\n})(NoiseExtensions || (NoiseExtensions = {}));\nexport var NoiseHandshakePayload;\n(function (NoiseHandshakePayload) {\n    let _codec;\n    NoiseHandshakePayload.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.identityKey != null && obj.identityKey.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.identityKey);\n                }\n                if ((obj.identitySig != null && obj.identitySig.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.identitySig);\n                }\n                if (obj.extensions != null) {\n                    w.uint32(34);\n                    NoiseExtensions.codec().encode(obj.extensions, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    identityKey: uint8ArrayAlloc(0),\n                    identitySig: uint8ArrayAlloc(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.identityKey = reader.bytes();\n                            break;\n                        }\n                        case 2: {\n                            obj.identitySig = reader.bytes();\n                            break;\n                        }\n                        case 4: {\n                            obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32());\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    NoiseHandshakePayload.encode = (obj) => {\n        return encodeMessage(obj, NoiseHandshakePayload.codec());\n    };\n    NoiseHandshakePayload.decode = (buf) => {\n        return decodeMessage(buf, NoiseHandshakePayload.codec());\n    };\n})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));\n//# sourceMappingURL=payload.js.map","import { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays';\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nimport { InvalidCryptoExchangeError } from './errors.js';\nimport { Nonce } from './nonce.js';\n// Code in this file is a direct translation of a subset of the noise protocol https://noiseprotocol.org/noise.html,\n// agnostic to libp2p's usage of noise\nexport const ZEROLEN = uint8ArrayAlloc(0);\nexport class CipherState {\n    k;\n    n;\n    crypto;\n    constructor(crypto, k = undefined, n = 0) {\n        this.crypto = crypto;\n        this.k = k;\n        this.n = new Nonce(n);\n    }\n    hasKey() {\n        return Boolean(this.k);\n    }\n    encryptWithAd(ad, plaintext) {\n        if (!this.hasKey()) {\n            return plaintext;\n        }\n        this.n.assertValue();\n        const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);\n        this.n.increment();\n        return e;\n    }\n    decryptWithAd(ad, ciphertext, dst) {\n        if (!this.hasKey()) {\n            return ciphertext;\n        }\n        this.n.assertValue();\n        const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);\n        this.n.increment();\n        return plaintext;\n    }\n}\nexport class SymmetricState {\n    cs;\n    ck;\n    h;\n    crypto;\n    constructor(crypto, protocolName) {\n        this.crypto = crypto;\n        const protocolNameBytes = uint8ArrayFromString(protocolName, 'utf-8');\n        this.h = hashProtocolName(crypto, protocolNameBytes);\n        this.ck = this.h;\n        this.cs = new CipherState(crypto);\n    }\n    mixKey(ikm) {\n        const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);\n        this.ck = ck;\n        this.cs = new CipherState(this.crypto, tempK);\n    }\n    mixHash(data) {\n        this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));\n    }\n    encryptAndHash(plaintext) {\n        const ciphertext = this.cs.encryptWithAd(this.h, plaintext);\n        this.mixHash(ciphertext);\n        return ciphertext;\n    }\n    decryptAndHash(ciphertext) {\n        const plaintext = this.cs.decryptWithAd(this.h, ciphertext);\n        this.mixHash(ciphertext);\n        return plaintext;\n    }\n    split() {\n        const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);\n        return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];\n    }\n}\nexport class AbstractHandshakeState {\n    ss;\n    s;\n    e;\n    rs;\n    re;\n    initiator;\n    crypto;\n    constructor(init) {\n        const { crypto, protocolName, prologue, initiator, s, e, rs, re } = init;\n        this.crypto = crypto;\n        this.ss = new SymmetricState(crypto, protocolName);\n        this.ss.mixHash(prologue);\n        this.initiator = initiator;\n        this.s = s;\n        this.e = e;\n        this.rs = rs;\n        this.re = re;\n    }\n    writeE() {\n        if (this.e) {\n            throw new Error('ephemeral keypair is already set');\n        }\n        const e = this.crypto.generateKeypair();\n        this.ss.mixHash(e.publicKey);\n        this.e = e;\n        return e.publicKey;\n    }\n    writeS() {\n        if (!this.s) {\n            throw new Error('static keypair is not set');\n        }\n        return this.ss.encryptAndHash(this.s.publicKey);\n    }\n    writeEE() {\n        if (!this.e) {\n            throw new Error('ephemeral keypair is not set');\n        }\n        if (!this.re) {\n            throw new Error('remote ephemeral public key is not set');\n        }\n        this.ss.mixKey(this.crypto.dh(this.e, this.re));\n    }\n    writeES() {\n        if (this.initiator) {\n            if (!this.e) {\n                throw new Error('ephemeral keypair is not set');\n            }\n            if (!this.rs) {\n                throw new Error('remote static public key is not set');\n            }\n            this.ss.mixKey(this.crypto.dh(this.e, this.rs));\n        }\n        else {\n            if (!this.s) {\n                throw new Error('static keypair is not set');\n            }\n            if (!this.re) {\n                throw new Error('remote ephemeral public key is not set');\n            }\n            this.ss.mixKey(this.crypto.dh(this.s, this.re));\n        }\n    }\n    writeSE() {\n        if (this.initiator) {\n            if (!this.s) {\n                throw new Error('static keypair is not set');\n            }\n            if (!this.re) {\n                throw new Error('remote ephemeral public key is not set');\n            }\n            this.ss.mixKey(this.crypto.dh(this.s, this.re));\n        }\n        else {\n            if (!this.e) {\n                throw new Error('ephemeral keypair is not set');\n            }\n            if (!this.rs) {\n                throw new Error('remote static public key is not set');\n            }\n            this.ss.mixKey(this.crypto.dh(this.e, this.rs));\n        }\n    }\n    readE(message, offset = 0) {\n        if (this.re) {\n            throw new Error('remote ephemeral public key is already set');\n        }\n        if (message.byteLength < offset + 32) {\n            throw new Error('message is not long enough');\n        }\n        this.re = message.sublist(offset, offset + 32);\n        this.ss.mixHash(this.re);\n    }\n    readS(message, offset = 0) {\n        if (this.rs) {\n            throw new Error('remote static public key is already set');\n        }\n        const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);\n        if (message.byteLength < offset + cipherLength) {\n            throw new Error('message is not long enough');\n        }\n        const temp = message.sublist(offset, offset + cipherLength);\n        this.rs = this.ss.decryptAndHash(temp);\n        return cipherLength;\n    }\n    readEE() {\n        this.writeEE();\n    }\n    readES() {\n        this.writeES();\n    }\n    readSE() {\n        this.writeSE();\n    }\n}\n/**\n * A IHandshakeState that's optimized for the XX pattern\n */\nexport class XXHandshakeState extends AbstractHandshakeState {\n    // e\n    writeMessageA(payload) {\n        return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));\n    }\n    // e, ee, s, es\n    writeMessageB(payload) {\n        const e = this.writeE();\n        this.writeEE();\n        const encS = this.writeS();\n        this.writeES();\n        return new Uint8ArrayList(e, encS, this.ss.encryptAndHash(payload));\n    }\n    // s, se\n    writeMessageC(payload) {\n        const encS = this.writeS();\n        this.writeSE();\n        return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));\n    }\n    // e\n    readMessageA(message) {\n        try {\n            this.readE(message);\n            return this.ss.decryptAndHash(message.sublist(32));\n        }\n        catch (e) {\n            throw new InvalidCryptoExchangeError(`handshake stage 0 validation fail: ${e.message}`);\n        }\n    }\n    // e, ee, s, es\n    readMessageB(message) {\n        try {\n            this.readE(message);\n            this.readEE();\n            const consumed = this.readS(message, 32);\n            this.readES();\n            return this.ss.decryptAndHash(message.sublist(32 + consumed));\n        }\n        catch (e) {\n            throw new InvalidCryptoExchangeError(`handshake stage 1 validation fail: ${e.message}`);\n        }\n    }\n    // s, se\n    readMessageC(message) {\n        try {\n            const consumed = this.readS(message);\n            this.readSE();\n            return this.ss.decryptAndHash(message.sublist(consumed));\n        }\n        catch (e) {\n            throw new InvalidCryptoExchangeError(`handshake stage 2 validation fail: ${e.message}`);\n        }\n    }\n}\nfunction hashProtocolName(crypto, protocolName) {\n    if (protocolName.length <= 32) {\n        const h = uint8ArrayAlloc(32);\n        h.set(protocolName);\n        return h;\n    }\n    else {\n        return crypto.hash(protocolName);\n    }\n}\n//# sourceMappingURL=protocol.js.map","import { Uint8ArrayList } from 'uint8arraylist';\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from './constants.js';\nimport { uint16BEEncode } from './encoder.js';\nconst CHACHA_TAG_LENGTH = 16;\n// Returns generator that encrypts payload from the user\nexport function encryptStream(handshake, metrics) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n                let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n                if (end > chunk.length) {\n                    end = chunk.length;\n                }\n                let data;\n                if (chunk instanceof Uint8Array) {\n                    data = handshake.encrypt(chunk.subarray(i, end));\n                }\n                else {\n                    data = handshake.encrypt(chunk.sublist(i, end));\n                }\n                metrics?.encryptedPackets.increment();\n                yield new Uint8ArrayList(uint16BEEncode(data.byteLength), data);\n            }\n        }\n    };\n}\n// Decrypt received payload to the user\nexport function decryptStream(handshake, metrics) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n                let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n                if (end > chunk.length) {\n                    end = chunk.length;\n                }\n                if (end - CHACHA_TAG_LENGTH < i) {\n                    throw new Error('Invalid chunk');\n                }\n                const encrypted = chunk.sublist(i, end);\n                // memory allocation is not cheap so reuse the encrypted Uint8Array\n                // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164\n                // this is ok because chacha20 reads bytes one by one and don't reread after that\n                // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48\n                const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);\n                try {\n                    const plaintext = handshake.decrypt(encrypted, dst);\n                    metrics?.decryptedPackets.increment();\n                    yield plaintext;\n                }\n                catch (e) {\n                    metrics?.decryptErrors.increment();\n                    throw e;\n                }\n            }\n        }\n    };\n}\n//# sourceMappingURL=streaming.js.map","import { unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport {} from 'uint8arraylist';\nimport { equals, toString } from 'uint8arrays';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { UnexpectedPeerError } from './errors.js';\nimport { NoiseHandshakePayload } from './proto/payload.js';\nexport async function createHandshakePayload(privateKey, staticPublicKey, extensions) {\n    const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));\n    return NoiseHandshakePayload.encode({\n        identityKey: privateKey.public.bytes,\n        identitySig,\n        extensions\n    });\n}\nexport async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {\n    try {\n        const payload = NoiseHandshakePayload.decode(payloadBytes);\n        if (remoteIdentityKey) {\n            const remoteIdentityKeyBytes = remoteIdentityKey.subarray();\n            if (!equals(remoteIdentityKeyBytes, payload.identityKey)) {\n                throw new Error(`Payload identity key ${toString(payload.identityKey, 'hex')} does not match expected remote identity key ${toString(remoteIdentityKeyBytes, 'hex')}`);\n            }\n        }\n        if (!remoteStaticKey) {\n            throw new Error('Remote static does not exist');\n        }\n        const signaturePayload = getSignaturePayload(remoteStaticKey);\n        const publicKey = unmarshalPublicKey(payload.identityKey);\n        if (!(await publicKey.verify(signaturePayload, payload.identitySig))) {\n            throw new Error('Invalid payload signature');\n        }\n        return payload;\n    }\n    catch (e) {\n        throw new UnexpectedPeerError(e.message);\n    }\n}\nexport function getSignaturePayload(publicKey) {\n    const prefix = uint8ArrayFromString('noise-libp2p-static-key:');\n    if (publicKey instanceof Uint8Array) {\n        return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length);\n    }\n    publicKey.prepend(prefix);\n    return publicKey;\n}\n//# sourceMappingURL=utils.js.map","import { parseIPv4, parseIPv6 } from \"@chainsafe/is-ip/parse\";\nimport { IPv4Len, IPv6Len, maskIp } from \"./ip.js\";\nexport function parseCidr(s) {\n    const [address, maskString] = s.split(\"/\");\n    if (!address || !maskString)\n        throw new Error(\"Failed to parse given CIDR: \" + s);\n    let ipLength = IPv4Len;\n    let ip = parseIPv4(address);\n    if (ip == null) {\n        ipLength = IPv6Len;\n        ip = parseIPv6(address);\n        if (ip == null)\n            throw new Error(\"Failed to parse given CIDR: \" + s);\n    }\n    const m = parseInt(maskString, 10);\n    if (Number.isNaN(m) ||\n        String(m).length !== maskString.length ||\n        m < 0 ||\n        m > ipLength * 8) {\n        throw new Error(\"Failed to parse given CIDR: \" + s);\n    }\n    const mask = cidrMask(m, 8 * ipLength);\n    return {\n        network: maskIp(ip, mask),\n        mask,\n    };\n}\nexport function cidrMask(ones, bits) {\n    if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)\n        throw new Error(\"Invalid CIDR mask\");\n    if (ones < 0 || ones > bits)\n        throw new Error(\"Invalid CIDR mask\");\n    const l = bits / 8;\n    const m = new Uint8Array(l);\n    for (let i = 0; i < l; i++) {\n        if (ones >= 8) {\n            m[i] = 0xff;\n            ones -= 8;\n            continue;\n        }\n        m[i] = 255 - (0xff >> ones);\n        ones = 0;\n    }\n    return m;\n}\n//# sourceMappingURL=cidr.js.map","import { IpNet } from \"./ipnet.js\";\nexport { ipToString } from \"./util.js\";\nexport { maskIp, iPv4FromIPv6, isIPv4mappedIPv6 } from \"./ip.js\";\nexport { IpNet } from \"./ipnet.js\";\nexport { parseCidr } from \"./cidr.js\";\n/**\n * Checks if cidr block contains ip address\n * @param cidr ipv4 or ipv6 formatted cidr . Example 198.51.100.14/24 or 2001:db8::/48\n * @param ip ipv4 or ipv6 address Example 198.51.100.14 or 2001:db8::\n *\n */\nexport function cidrContains(cidr, ip) {\n    const ipnet = new IpNet(cidr);\n    return ipnet.contains(ip);\n}\n//# sourceMappingURL=index.js.map","import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\nexport function maskIp(ip, mask) {\n    if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n        mask = mask.slice(12);\n    }\n    if (mask.length === IPv4Len &&\n        ip.length === IPv6Len &&\n        deepEqual(ip, ipv4Prefix, 0, 11)) {\n        ip = ip.slice(12);\n    }\n    const n = ip.length;\n    if (n != mask.length) {\n        throw new Error(\"Failed to mask ip\");\n    }\n    const out = new Uint8Array(n);\n    for (let i = 0; i < n; i++) {\n        out[i] = ip[i] & mask[i];\n    }\n    return out;\n}\nexport function containsIp(net, ip) {\n    if (typeof ip === \"string\") {\n        ip = parseIP(ip);\n    }\n    if (ip == null)\n        throw new Error(\"Invalid ip\");\n    if (ip.length !== net.network.length) {\n        return false;\n    }\n    for (let i = 0; i < ip.length; i++) {\n        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function iPv4FromIPv6(ip) {\n    if (!isIPv4mappedIPv6(ip)) {\n        throw new Error(\"Must have 0xffff prefix\");\n    }\n    return ip.slice(12);\n}\nexport function isIPv4mappedIPv6(ip) {\n    return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n//# sourceMappingURL=ip.js.map","import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { cidrMask, parseCidr } from \"./cidr.js\";\nimport { containsIp, maskIp } from \"./ip.js\";\nimport { ipToString, maskToHex, simpleMaskLength } from \"./util.js\";\nexport class IpNet {\n    /**\n     *\n     * @param ipOrCidr either network ip or full cidr address\n     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address\n     */\n    constructor(ipOrCidr, mask) {\n        if (mask == null) {\n            ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));\n        }\n        else {\n            const ipResult = parseIP(ipOrCidr);\n            if (ipResult == null) {\n                throw new Error(\"Failed to parse network\");\n            }\n            mask = String(mask);\n            const m = parseInt(mask, 10);\n            if (Number.isNaN(m) ||\n                String(m).length !== mask.length ||\n                m < 0 ||\n                m > ipResult.length * 8) {\n                const maskResult = parseIP(mask);\n                if (maskResult == null) {\n                    throw new Error(\"Failed to parse mask\");\n                }\n                this.mask = maskResult;\n            }\n            else {\n                this.mask = cidrMask(m, 8 * ipResult.length);\n            }\n            this.network = maskIp(ipResult, this.mask);\n        }\n    }\n    /**\n     * Checks if netmask contains ip address\n     * @param ip\n     * @returns\n     */\n    contains(ip) {\n        return containsIp({ network: this.network, mask: this.mask }, ip);\n    }\n    /**Serializes back to string format */\n    toString() {\n        const l = simpleMaskLength(this.mask);\n        const mask = l !== -1 ? String(l) : maskToHex(this.mask);\n        return ipToString(this.network) + \"/\" + mask;\n    }\n}\n//# sourceMappingURL=ipnet.js.map","import { IPv4Len, IPv6Len } from \"./ip.js\";\nexport function allFF(a, from, to) {\n    let i = 0;\n    for (const e of a) {\n        if (i < from)\n            continue;\n        if (i > to)\n            break;\n        if (e !== 0xff)\n            return false;\n        i++;\n    }\n    return true;\n}\nexport function deepEqual(a, b, from, to) {\n    let i = 0;\n    for (const e of a) {\n        if (i < from)\n            continue;\n        if (i > to)\n            break;\n        if (e !== b[i])\n            return false;\n        i++;\n    }\n    return true;\n}\n/***\n * Returns long ip format\n */\nexport function ipToString(ip) {\n    switch (ip.length) {\n        case IPv4Len: {\n            return ip.join(\".\");\n        }\n        case IPv6Len: {\n            const result = [];\n            for (let i = 0; i < ip.length; i++) {\n                if (i % 2 === 0) {\n                    result.push(ip[i].toString(16).padStart(2, \"0\") +\n                        ip[i + 1].toString(16).padStart(2, \"0\"));\n                }\n            }\n            return result.join(\":\");\n        }\n        default: {\n            throw new Error(\"Invalid ip length\");\n        }\n    }\n}\n/**\n * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1\n */\nexport function simpleMaskLength(mask) {\n    let ones = 0;\n    // eslint-disable-next-line prefer-const\n    for (let [index, byte] of mask.entries()) {\n        if (byte === 0xff) {\n            ones += 8;\n            continue;\n        }\n        while ((byte & 0x80) != 0) {\n            ones++;\n            byte = byte << 1;\n        }\n        if ((byte & 0x80) != 0) {\n            return -1;\n        }\n        for (let i = index + 1; i < mask.length; i++) {\n            if (mask[i] != 0) {\n                return -1;\n            }\n        }\n        break;\n    }\n    return ones;\n}\nexport function maskToHex(mask) {\n    let hex = \"0x\";\n    for (const byte of mask) {\n        hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);\n    }\n    return hex;\n}\n//# sourceMappingURL=util.js.map","import { concat } from 'uint8arrays/concat';\nimport { fromString } from 'uint8arrays/from-string';\nimport webcrypto from '../webcrypto.js';\n// WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\nexport const derivedEmptyPasswordKey = { alg: 'A128GCM', ext: true, k: 'scm9jmO_4BJAgdwWGVulLg', key_ops: ['encrypt', 'decrypt'], kty: 'oct' };\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\nexport function create(opts) {\n    const algorithm = opts?.algorithm ?? 'AES-GCM';\n    let keyLength = opts?.keyLength ?? 16;\n    const nonceLength = opts?.nonceLength ?? 12;\n    const digest = opts?.digest ?? 'SHA-256';\n    const saltLength = opts?.saltLength ?? 16;\n    const iterations = opts?.iterations ?? 32767;\n    const crypto = webcrypto.get();\n    keyLength *= 8; // Browser crypto uses bits instead of bytes\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to encrypt the data.\n     */\n    async function encrypt(data, password) {\n        const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n        const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = fromString(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['encrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt']);\n            }\n        }\n        else {\n            // Derive a key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt']);\n        }\n        // Encrypt the string.\n        const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n        return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n    }\n    /**\n     * Uses the provided password to derive a pbkdf2 key. The key\n     * will then be used to decrypt the data. The options used to create\n     * this decryption cipher must be the same as those used to create\n     * the encryption cipher.\n     */\n    async function decrypt(data, password) {\n        const salt = data.subarray(0, saltLength);\n        const nonce = data.subarray(saltLength, saltLength + nonceLength);\n        const ciphertext = data.subarray(saltLength + nonceLength);\n        const aesGcm = { name: algorithm, iv: nonce };\n        if (typeof password === 'string') {\n            password = fromString(password);\n        }\n        let cryptoKey;\n        if (password.length === 0) {\n            try {\n                const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n                const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n                cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['decrypt']);\n            }\n            catch {\n                cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['decrypt']);\n            }\n        }\n        else {\n            // Derive the key using PBKDF2.\n            const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } };\n            const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey']);\n            cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt']);\n        }\n        // Decrypt the string.\n        const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n        return new Uint8Array(plaintext);\n    }\n    const cipher = {\n        encrypt,\n        decrypt\n    };\n    return cipher;\n}\n//# sourceMappingURL=aes-gcm.browser.js.map","import webcrypto from '../webcrypto.js';\nimport lengths from './lengths.js';\nconst hashTypes = {\n    SHA1: 'SHA-1',\n    SHA256: 'SHA-256',\n    SHA512: 'SHA-512'\n};\nconst sign = async (key, data) => {\n    const buf = await webcrypto.get().subtle.sign({ name: 'HMAC' }, key, data);\n    return new Uint8Array(buf, 0, buf.byteLength);\n};\nexport async function create(hashType, secret) {\n    const hash = hashTypes[hashType];\n    const key = await webcrypto.get().subtle.importKey('raw', secret, {\n        name: 'HMAC',\n        hash: { name: hash }\n    }, false, ['sign']);\n    return {\n        async digest(data) {\n            return sign(key, data);\n        },\n        length: lengths[hashType]\n    };\n}\n//# sourceMappingURL=index-browser.js.map","export default {\n    SHA1: 20,\n    SHA256: 32,\n    SHA512: 64\n};\n//# sourceMappingURL=lengths.js.map","import { CodeError } from '@libp2p/interface';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { base64urlToBuffer } from '../util.js';\nimport webcrypto from '../webcrypto.js';\nconst bits = {\n    'P-256': 256,\n    'P-384': 384,\n    'P-521': 521\n};\nconst curveTypes = Object.keys(bits);\nconst names = curveTypes.join(' / ');\nexport async function generateEphmeralKeyPair(curve) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const pair = await webcrypto.get().subtle.generateKey({\n        name: 'ECDH',\n        namedCurve: curve\n    }, true, ['deriveBits']);\n    // forcePrivate is used for testing only\n    const genSharedKey = async (theirPub, forcePrivate) => {\n        let privateKey;\n        if (forcePrivate != null) {\n            privateKey = await webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n                name: 'ECDH',\n                namedCurve: curve\n            }, false, ['deriveBits']);\n        }\n        else {\n            privateKey = pair.privateKey;\n        }\n        const key = await webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n            name: 'ECDH',\n            namedCurve: curve\n        }, false, []);\n        const buffer = await webcrypto.get().subtle.deriveBits({\n            name: 'ECDH',\n            // @ts-expect-error namedCurve is missing from the types\n            namedCurve: curve,\n            public: key\n        }, privateKey, bits[curve]);\n        return new Uint8Array(buffer, 0, buffer.byteLength);\n    };\n    const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n    const ecdhKey = {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n    };\n    return ecdhKey;\n}\nconst curveLengths = {\n    'P-256': 32,\n    'P-384': 48,\n    'P-521': 66\n};\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey(jwk) {\n    if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n        throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n        throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const byteLen = curveLengths[jwk.crv];\n    return uint8ArrayConcat([\n        Uint8Array.from([4]), // uncompressed point\n        base64urlToBuffer(jwk.x, byteLen),\n        base64urlToBuffer(jwk.y, byteLen)\n    ], 1 + byteLen * 2);\n}\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey(curve, key) {\n    if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n        throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE');\n    }\n    const byteLen = curveLengths[curve];\n    if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n        throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT');\n    }\n    return {\n        kty: 'EC',\n        crv: curve,\n        x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n        y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n        ext: true\n    };\n}\nconst unmarshalPrivateKey = (curve, key) => ({\n    ...unmarshalPublicKey(curve, key.public),\n    d: uint8ArrayToString(key.private, 'base64url')\n});\n//# sourceMappingURL=ecdh-browser.js.map","import { ed25519 as ed } from '@noble/curves/ed25519';\nconst PUBLIC_KEY_BYTE_LENGTH = 32;\nconst PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32;\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength };\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport function generateKey() {\n    // the actual private key (32 bytes)\n    const privateKeyRaw = ed.utils.randomPrivateKey();\n    const publicKey = ed.getPublicKey(privateKeyRaw);\n    // concatenated the public key to the private key\n    const privateKey = concatKeys(privateKeyRaw, publicKey);\n    return {\n        privateKey,\n        publicKey\n    };\n}\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport function generateKeyFromSeed(seed) {\n    if (seed.length !== KEYS_BYTE_LENGTH) {\n        throw new TypeError('\"seed\" must be 32 bytes in length.');\n    }\n    else if (!(seed instanceof Uint8Array)) {\n        throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n    }\n    // based on node forges algorithm, the seed is used directly as private key\n    const privateKeyRaw = seed;\n    const publicKey = ed.getPublicKey(privateKeyRaw);\n    const privateKey = concatKeys(privateKeyRaw, publicKey);\n    return {\n        privateKey,\n        publicKey\n    };\n}\nexport function hashAndSign(privateKey, msg) {\n    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);\n    return ed.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);\n}\nexport function hashAndVerify(publicKey, sig, msg) {\n    return ed.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);\n}\nfunction concatKeys(privateKeyRaw, publicKey) {\n    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);\n    for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n        privateKey[i] = privateKeyRaw[i];\n        privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n    }\n    return privateKey;\n}\n//# sourceMappingURL=ed25519-browser.js.map","import { CodeError } from '@libp2p/interface';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { isPromise } from '../util.js';\nimport * as crypto from './ed25519.js';\nimport { exporter } from './exporter.js';\nimport * as pbm from './keys.js';\nexport class Ed25519PublicKey {\n    _key;\n    constructor(key) {\n        this._key = ensureKey(key, crypto.publicKeyLength);\n    }\n    verify(data, sig) {\n        return crypto.hashAndVerify(this._key, sig, data);\n    }\n    marshal() {\n        return this._key;\n    }\n    get bytes() {\n        return pbm.PublicKey.encode({\n            Type: pbm.KeyType.Ed25519,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = sha256.digest(this.bytes);\n        if (isPromise(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n}\nexport class Ed25519PrivateKey {\n    _key;\n    _publicKey;\n    // key       - 64 byte Uint8Array containing private key\n    // publicKey - 32 byte Uint8Array containing public key\n    constructor(key, publicKey) {\n        this._key = ensureKey(key, crypto.privateKeyLength);\n        this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n    }\n    sign(message) {\n        return crypto.hashAndSign(this._key, message);\n    }\n    get public() {\n        return new Ed25519PublicKey(this._publicKey);\n    }\n    marshal() {\n        return this._key;\n    }\n    get bytes() {\n        return pbm.PrivateKey.encode({\n            Type: pbm.KeyType.Ed25519,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n    async hash() {\n        const p = sha256.digest(this.bytes);\n        let bytes;\n        if (isPromise(p)) {\n            ({ bytes } = await p);\n        }\n        else {\n            bytes = p.bytes;\n        }\n        return bytes;\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the identity multihash containing its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n    async id() {\n        const encoding = identity.digest(this.public.bytes);\n        return base58btc.encode(encoding.bytes).substring(1);\n    }\n    /**\n     * Exports the key into a password protected `format`\n     */\n    async export(password, format = 'libp2p-key') {\n        if (format === 'libp2p-key') {\n            return exporter(this.bytes, password);\n        }\n        else {\n            throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n        }\n    }\n}\nexport function unmarshalEd25519PrivateKey(bytes) {\n    // Try the old, redundant public key version\n    if (bytes.length > crypto.privateKeyLength) {\n        bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n        const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength);\n        const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length);\n        return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n    }\n    bytes = ensureKey(bytes, crypto.privateKeyLength);\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.subarray(crypto.publicKeyLength);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\nexport function unmarshalEd25519PublicKey(bytes) {\n    bytes = ensureKey(bytes, crypto.publicKeyLength);\n    return new Ed25519PublicKey(bytes);\n}\nexport async function generateKeyPair() {\n    const { privateKey, publicKey } = crypto.generateKey();\n    return new Ed25519PrivateKey(privateKey, publicKey);\n}\nexport async function generateKeyPairFromSeed(seed) {\n    const { privateKey, publicKey } = crypto.generateKeyFromSeed(seed);\n    return new Ed25519PrivateKey(privateKey, publicKey);\n}\nfunction ensureKey(key, length) {\n    key = Uint8Array.from(key ?? []);\n    if (key.length !== length) {\n        throw new CodeError(`Key must be a Uint8Array of length ${length}, got ${key.length}`, 'ERR_INVALID_KEY_TYPE');\n    }\n    return key;\n}\n//# sourceMappingURL=ed25519-class.js.map","import { generateEphmeralKeyPair } from './ecdh.js';\n/**\n * Generates an ephemeral public key and returns a function that will compute\n * the shared secret key.\n *\n * Focuses only on ECDH now, but can be made more general in the future.\n */\nexport default generateEphmeralKeyPair;\n//# sourceMappingURL=ephemeral-keys.js.map","import { base64 } from 'multiformats/bases/base64';\nimport * as ciphers from '../ciphers/aes-gcm.js';\n/**\n * Exports the given PrivateKey as a base64 encoded string.\n * The PrivateKey is encrypted via a password derived PBKDF2 key\n * leveraging the aes-gcm cipher algorithm.\n */\nexport async function exporter(privateKey, password) {\n    const cipher = ciphers.create();\n    const encryptedKey = await cipher.encrypt(privateKey, password);\n    return base64.encode(encryptedKey);\n}\n//# sourceMappingURL=exporter.js.map","import { base64 } from 'multiformats/bases/base64';\nimport * as ciphers from '../ciphers/aes-gcm.js';\n/**\n * Attempts to decrypt a base64 encoded PrivateKey string\n * with the given password. The privateKey must have been exported\n * using the same password and underlying cipher (aes-gcm)\n */\nexport async function importer(privateKey, password) {\n    const encryptedKey = base64.decode(privateKey);\n    const cipher = ciphers.create();\n    return cipher.decrypt(encryptedKey, password);\n}\n//# sourceMappingURL=importer.js.map","/**\n * @packageDocumentation\n *\n * **Supported Key Types**\n *\n * The {@link generateKeyPair}, {@link marshalPublicKey}, and {@link marshalPrivateKey} functions accept a string `type` argument.\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\nimport { CodeError } from '@libp2p/interface';\nimport * as Ed25519 from './ed25519-class.js';\nimport generateEphemeralKeyPair from './ephemeral-keys.js';\nimport { importer } from './importer.js';\nimport { keyStretcher } from './key-stretcher.js';\nimport * as keysPBM from './keys.js';\nimport * as RSA from './rsa-class.js';\nimport { importFromPem } from './rsa-utils.js';\nimport * as Secp256k1 from './secp256k1-class.js';\nexport { keyStretcher };\nexport { generateEphemeralKeyPair };\nexport { keysPBM };\nexport { RsaPrivateKey, RsaPublicKey, MAX_RSA_KEY_SIZE } from './rsa-class.js';\nexport { Ed25519PrivateKey, Ed25519PublicKey } from './ed25519-class.js';\nexport { Secp256k1PrivateKey, Secp256k1PublicKey } from './secp256k1-class.js';\nexport const supportedKeys = {\n    rsa: RSA,\n    ed25519: Ed25519,\n    secp256k1: Secp256k1\n};\nfunction unsupportedKey(type) {\n    const supported = Object.keys(supportedKeys).join(' / ');\n    return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, 'ERR_UNSUPPORTED_KEY_TYPE');\n}\nfunction typeToKey(type) {\n    type = type.toLowerCase();\n    if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n        return supportedKeys[type];\n    }\n    throw unsupportedKey(type);\n}\n/**\n * Generates a keypair of the given type and bitsize\n */\nexport async function generateKeyPair(type, bits) {\n    return typeToKey(type).generateKeyPair(bits ?? 2048);\n}\n/**\n * Generates a keypair of the given type and bitsize.\n *\n * Seed is a 32 byte uint8array\n */\nexport async function generateKeyPairFromSeed(type, seed, bits) {\n    if (type.toLowerCase() !== 'ed25519') {\n        throw new CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n    }\n    return Ed25519.generateKeyPairFromSeed(seed);\n}\n/**\n * Converts a protobuf serialized public key into its representative object\n */\nexport function unmarshalPublicKey(buf) {\n    const decoded = keysPBM.PublicKey.decode(buf);\n    const data = decoded.Data ?? new Uint8Array();\n    switch (decoded.Type) {\n        case keysPBM.KeyType.RSA:\n            return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n        case keysPBM.KeyType.Ed25519:\n            return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n        case keysPBM.KeyType.Secp256k1:\n            return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n        default:\n            throw unsupportedKey(decoded.Type ?? 'unknown');\n    }\n}\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function marshalPublicKey(key, type) {\n    type = (type ?? 'rsa').toLowerCase();\n    typeToKey(type); // check type\n    return key.bytes;\n}\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport async function unmarshalPrivateKey(buf) {\n    const decoded = keysPBM.PrivateKey.decode(buf);\n    const data = decoded.Data ?? new Uint8Array();\n    switch (decoded.Type) {\n        case keysPBM.KeyType.RSA:\n            return supportedKeys.rsa.unmarshalRsaPrivateKey(data);\n        case keysPBM.KeyType.Ed25519:\n            return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);\n        case keysPBM.KeyType.Secp256k1:\n            return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);\n        default:\n            throw unsupportedKey(decoded.Type ?? 'RSA');\n    }\n}\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function marshalPrivateKey(key, type) {\n    type = (type ?? 'rsa').toLowerCase();\n    typeToKey(type); // check type\n    return key.bytes;\n}\n/**\n * Converts an exported private key into its representative object.\n *\n * Supported formats are 'pem' (RSA only) and 'libp2p-key'.\n */\nexport async function importKey(encryptedKey, password) {\n    try {\n        const key = await importer(encryptedKey, password);\n        return await unmarshalPrivateKey(key);\n    }\n    catch (_) {\n        // Ignore and try the old pem decrypt\n    }\n    if (!encryptedKey.includes('BEGIN')) {\n        throw new CodeError('Encrypted key was not a libp2p-key or a PEM file', 'ERR_INVALID_IMPORT_FORMAT');\n    }\n    return importFromPem(encryptedKey, password);\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as hmac from '../hmac/index.js';\nconst cipherMap = {\n    'AES-128': {\n        ivSize: 16,\n        keySize: 16\n    },\n    'AES-256': {\n        ivSize: 16,\n        keySize: 32\n    },\n    Blowfish: {\n        ivSize: 8,\n        keySize: 32\n    }\n};\n/**\n * Generates a set of keys for each party by stretching the shared key.\n * (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n */\nexport async function keyStretcher(cipherType, hash, secret) {\n    const cipher = cipherMap[cipherType];\n    if (cipher == null) {\n        const allowed = Object.keys(cipherMap).join(' / ');\n        throw new CodeError(`unknown cipher type '${cipherType}'. Must be ${allowed}`, 'ERR_INVALID_CIPHER_TYPE');\n    }\n    if (hash == null) {\n        throw new CodeError('missing hash type', 'ERR_MISSING_HASH_TYPE');\n    }\n    const cipherKeySize = cipher.keySize;\n    const ivSize = cipher.ivSize;\n    const hmacKeySize = 20;\n    const seed = uint8ArrayFromString('key expansion');\n    const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n    const m = await hmac.create(hash, secret);\n    let a = await m.digest(seed);\n    const result = [];\n    let j = 0;\n    while (j < resultLength) {\n        const b = await m.digest(uint8ArrayConcat([a, seed]));\n        let todo = b.length;\n        if (j + todo > resultLength) {\n            todo = resultLength - j;\n        }\n        result.push(b);\n        j += todo;\n        a = await m.digest(a);\n    }\n    const half = resultLength / 2;\n    const resultBuffer = uint8ArrayConcat(result);\n    const r1 = resultBuffer.subarray(0, half);\n    const r2 = resultBuffer.subarray(half, resultLength);\n    const createKey = (res) => ({\n        iv: res.subarray(0, ivSize),\n        cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),\n        macKey: res.subarray(ivSize + cipherKeySize)\n    });\n    return {\n        k1: createKey(r1),\n        k2: createKey(r2)\n    };\n}\n//# sourceMappingURL=key-stretcher.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var KeyType;\n(function (KeyType) {\n    KeyType[\"RSA\"] = \"RSA\";\n    KeyType[\"Ed25519\"] = \"Ed25519\";\n    KeyType[\"Secp256k1\"] = \"Secp256k1\";\n})(KeyType || (KeyType = {}));\nvar __KeyTypeValues;\n(function (__KeyTypeValues) {\n    __KeyTypeValues[__KeyTypeValues[\"RSA\"] = 0] = \"RSA\";\n    __KeyTypeValues[__KeyTypeValues[\"Ed25519\"] = 1] = \"Ed25519\";\n    __KeyTypeValues[__KeyTypeValues[\"Secp256k1\"] = 2] = \"Secp256k1\";\n})(__KeyTypeValues || (__KeyTypeValues = {}));\n(function (KeyType) {\n    KeyType.codec = () => {\n        return enumeration(__KeyTypeValues);\n    };\n})(KeyType || (KeyType = {}));\nexport var PublicKey;\n(function (PublicKey) {\n    let _codec;\n    PublicKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PublicKey.encode = (obj) => {\n        return encodeMessage(obj, PublicKey.codec());\n    };\n    PublicKey.decode = (buf) => {\n        return decodeMessage(buf, PublicKey.codec());\n    };\n})(PublicKey || (PublicKey = {}));\nexport var PrivateKey;\n(function (PrivateKey) {\n    let _codec;\n    PrivateKey.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    KeyType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = KeyType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PrivateKey.encode = (obj) => {\n        return encodeMessage(obj, PrivateKey.codec());\n    };\n    PrivateKey.decode = (buf) => {\n        return decodeMessage(buf, PrivateKey.codec());\n    };\n})(PrivateKey || (PrivateKey = {}));\n//# sourceMappingURL=keys.js.map","import { CodeError } from '@libp2p/interface';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport randomBytes from '../random-bytes.js';\nimport webcrypto from '../webcrypto.js';\nimport * as utils from './rsa-utils.js';\nexport { utils };\nexport async function generateKey(bits) {\n    const pair = await webcrypto.get().subtle.generateKey({\n        name: 'RSASSA-PKCS1-v1_5',\n        modulusLength: bits,\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: { name: 'SHA-256' }\n    }, true, ['sign', 'verify']);\n    const keys = await exportKey(pair);\n    return {\n        privateKey: keys[0],\n        publicKey: keys[1]\n    };\n}\n// Takes a jwk key\nexport async function unmarshalPrivateKey(key) {\n    const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, true, ['sign']);\n    const pair = [\n        privateKey,\n        await derivePublicFromPrivate(key)\n    ];\n    const keys = await exportKey({\n        privateKey: pair[0],\n        publicKey: pair[1]\n    });\n    return {\n        privateKey: keys[0],\n        publicKey: keys[1]\n    };\n}\nexport { randomBytes as getRandomValues };\nexport async function hashAndSign(key, msg) {\n    const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, false, ['sign']);\n    const sig = await webcrypto.get().subtle.sign({ name: 'RSASSA-PKCS1-v1_5' }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());\n    return new Uint8Array(sig, 0, sig.byteLength);\n}\nexport async function hashAndVerify(key, sig, msg) {\n    const publicKey = await webcrypto.get().subtle.importKey('jwk', key, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, false, ['verify']);\n    return webcrypto.get().subtle.verify({ name: 'RSASSA-PKCS1-v1_5' }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());\n}\nasync function exportKey(pair) {\n    if (pair.privateKey == null || pair.publicKey == null) {\n        throw new CodeError('Private and public key are required', 'ERR_INVALID_PARAMETERS');\n    }\n    return Promise.all([\n        webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n        webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n    ]);\n}\nasync function derivePublicFromPrivate(jwKey) {\n    return webcrypto.get().subtle.importKey('jwk', {\n        kty: jwKey.kty,\n        n: jwKey.n,\n        e: jwKey.e\n    }, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n    }, true, ['verify']);\n}\nexport function keySize(jwk) {\n    if (jwk.kty !== 'RSA') {\n        throw new CodeError('invalid key type', 'ERR_INVALID_KEY_TYPE');\n    }\n    else if (jwk.n == null) {\n        throw new CodeError('invalid key modulus', 'ERR_INVALID_KEY_MODULUS');\n    }\n    const bytes = uint8ArrayFromString(jwk.n, 'base64url');\n    return bytes.length * 8;\n}\n//# sourceMappingURL=rsa-browser.js.map","import { CodeError } from '@libp2p/interface';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { isPromise } from '../util.js';\nimport { exporter } from './exporter.js';\nimport * as pbm from './keys.js';\nimport * as crypto from './rsa.js';\nexport const MAX_RSA_KEY_SIZE = 8192;\nexport class RsaPublicKey {\n    _key;\n    constructor(key) {\n        this._key = key;\n    }\n    verify(data, sig) {\n        return crypto.hashAndVerify(this._key, sig, data);\n    }\n    marshal() {\n        return crypto.utils.jwkToPkix(this._key);\n    }\n    get bytes() {\n        return pbm.PublicKey.encode({\n            Type: pbm.KeyType.RSA,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = sha256.digest(this.bytes);\n        if (isPromise(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n}\nexport class RsaPrivateKey {\n    _key;\n    _publicKey;\n    constructor(key, publicKey) {\n        this._key = key;\n        this._publicKey = publicKey;\n    }\n    genSecret() {\n        return crypto.getRandomValues(16);\n    }\n    sign(message) {\n        return crypto.hashAndSign(this._key, message);\n    }\n    get public() {\n        if (this._publicKey == null) {\n            throw new CodeError('public key not provided', 'ERR_PUBKEY_NOT_PROVIDED');\n        }\n        return new RsaPublicKey(this._publicKey);\n    }\n    marshal() {\n        return crypto.utils.jwkToPkcs1(this._key);\n    }\n    get bytes() {\n        return pbm.PrivateKey.encode({\n            Type: pbm.KeyType.RSA,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = sha256.digest(this.bytes);\n        if (isPromise(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     */\n    async id() {\n        const hash = await this.public.hash();\n        return uint8ArrayToString(hash, 'base58btc');\n    }\n    /**\n     * Exports the key as libp2p-key - a aes-gcm encrypted value with the key\n     * derived from the password.\n     *\n     * To export it as a password protected PEM file, please use the `exportPEM`\n     * function from `@libp2p/rsa`.\n     */\n    async export(password, format = 'pkcs-8') {\n        if (format === 'pkcs-8') {\n            return crypto.utils.exportToPem(this, password);\n        }\n        else if (format === 'libp2p-key') {\n            return exporter(this.bytes, password);\n        }\n        else {\n            throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n        }\n    }\n}\nexport async function unmarshalRsaPrivateKey(bytes) {\n    const jwk = crypto.utils.pkcs1ToJwk(bytes);\n    if (crypto.keySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    const keys = await crypto.unmarshalPrivateKey(jwk);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\nexport function unmarshalRsaPublicKey(bytes) {\n    const jwk = crypto.utils.pkixToJwk(bytes);\n    if (crypto.keySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    return new RsaPublicKey(jwk);\n}\nexport async function fromJwk(jwk) {\n    if (crypto.keySize(jwk) > MAX_RSA_KEY_SIZE) {\n        throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    const keys = await crypto.unmarshalPrivateKey(jwk);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\nexport async function generateKeyPair(bits) {\n    if (bits > MAX_RSA_KEY_SIZE) {\n        throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE');\n    }\n    const keys = await crypto.generateKey(bits);\n    return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n//# sourceMappingURL=rsa-class.js.map","import { CodeError } from '@libp2p/interface';\nimport { pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha512 } from '@noble/hashes/sha512';\nimport * as asn1js from 'asn1js';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport randomBytes from '../random-bytes.js';\nimport webcrypto from '../webcrypto.js';\nimport { unmarshalRsaPrivateKey } from './rsa-class.js';\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK key\n */\nexport function pkcs1ToJwk(bytes) {\n    const { result } = asn1js.fromBER(bytes);\n    // @ts-expect-error this looks fragile but DER is a canonical format so we are\n    // safe to have deeply property chains like this\n    const values = result.valueBlock.value;\n    const key = {\n        n: uint8ArrayToString(bnToBuf(values[1].toBigInt()), 'base64url'),\n        e: uint8ArrayToString(bnToBuf(values[2].toBigInt()), 'base64url'),\n        d: uint8ArrayToString(bnToBuf(values[3].toBigInt()), 'base64url'),\n        p: uint8ArrayToString(bnToBuf(values[4].toBigInt()), 'base64url'),\n        q: uint8ArrayToString(bnToBuf(values[5].toBigInt()), 'base64url'),\n        dp: uint8ArrayToString(bnToBuf(values[6].toBigInt()), 'base64url'),\n        dq: uint8ArrayToString(bnToBuf(values[7].toBigInt()), 'base64url'),\n        qi: uint8ArrayToString(bnToBuf(values[8].toBigInt()), 'base64url'),\n        kty: 'RSA',\n        alg: 'RS256'\n    };\n    return key;\n}\n/**\n * Convert a JWK key into PKCS#1 in ASN1 DER format\n */\nexport function jwkToPkcs1(jwk) {\n    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n        throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    const root = new asn1js.Sequence({\n        value: [\n            new asn1js.Integer({ value: 0 }),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.n, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.e, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.d, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.p, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.q, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.dp, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.dq, 'base64url'))),\n            asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.qi, 'base64url')))\n        ]\n    });\n    const der = root.toBER();\n    return new Uint8Array(der, 0, der.byteLength);\n}\n/**\n * Convert a PKCIX in ASN1 DER format to a JWK key\n */\nexport function pkixToJwk(bytes) {\n    const { result } = asn1js.fromBER(bytes);\n    // @ts-expect-error this looks fragile but DER is a canonical format so we are\n    // safe to have deeply property chains like this\n    const values = result.valueBlock.value[1].valueBlock.value[0].valueBlock.value;\n    return {\n        kty: 'RSA',\n        n: uint8ArrayToString(bnToBuf(values[0].toBigInt()), 'base64url'),\n        e: uint8ArrayToString(bnToBuf(values[1].toBigInt()), 'base64url')\n    };\n}\n/**\n * Convert a JWK key to PKCIX in ASN1 DER format\n */\nexport function jwkToPkix(jwk) {\n    if (jwk.n == null || jwk.e == null) {\n        throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS');\n    }\n    const root = new asn1js.Sequence({\n        value: [\n            new asn1js.Sequence({\n                value: [\n                    // rsaEncryption\n                    new asn1js.ObjectIdentifier({\n                        value: '1.2.840.113549.1.1.1'\n                    }),\n                    new asn1js.Null()\n                ]\n            }),\n            // this appears to be a bug in asn1js.js - this should really be a Sequence\n            // and not a BitString but it generates the same bytes as node-forge so \n            new asn1js.BitString({\n                valueHex: new asn1js.Sequence({\n                    value: [\n                        asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.n, 'base64url'))),\n                        asn1js.Integer.fromBigInt(bufToBn(uint8ArrayFromString(jwk.e, 'base64url')))\n                    ]\n                }).toBER()\n            })\n        ]\n    });\n    const der = root.toBER();\n    return new Uint8Array(der, 0, der.byteLength);\n}\nfunction bnToBuf(bn) {\n    let hex = bn.toString(16);\n    if (hex.length % 2 > 0) {\n        hex = `0${hex}`;\n    }\n    const len = hex.length / 2;\n    const u8 = new Uint8Array(len);\n    let i = 0;\n    let j = 0;\n    while (i < len) {\n        u8[i] = parseInt(hex.slice(j, j + 2), 16);\n        i += 1;\n        j += 2;\n    }\n    return u8;\n}\nfunction bufToBn(u8) {\n    const hex = [];\n    u8.forEach(function (i) {\n        let h = i.toString(16);\n        if (h.length % 2 > 0) {\n            h = `0${h}`;\n        }\n        hex.push(h);\n    });\n    return BigInt('0x' + hex.join(''));\n}\nconst SALT_LENGTH = 16;\nconst KEY_SIZE = 32;\nconst ITERATIONS = 10000;\nexport async function exportToPem(privateKey, password) {\n    const crypto = webcrypto.get();\n    // PrivateKeyInfo\n    const keyWrapper = new asn1js.Sequence({\n        value: [\n            // version (0)\n            new asn1js.Integer({ value: 0 }),\n            // privateKeyAlgorithm\n            new asn1js.Sequence({\n                value: [\n                    // rsaEncryption OID\n                    new asn1js.ObjectIdentifier({\n                        value: '1.2.840.113549.1.1.1'\n                    }),\n                    new asn1js.Null()\n                ]\n            }),\n            // PrivateKey\n            new asn1js.OctetString({\n                valueHex: privateKey.marshal()\n            })\n        ]\n    });\n    const keyBuf = keyWrapper.toBER();\n    const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);\n    const salt = randomBytes(SALT_LENGTH);\n    const encryptionKey = await pbkdf2Async(sha512, password, salt, {\n        c: ITERATIONS,\n        dkLen: KEY_SIZE\n    });\n    const iv = randomBytes(16);\n    const cryptoKey = await crypto.subtle.importKey('raw', encryptionKey, 'AES-CBC', false, ['encrypt']);\n    const encrypted = await crypto.subtle.encrypt({\n        name: 'AES-CBC',\n        iv\n    }, cryptoKey, keyArr);\n    const pbkdf2Params = new asn1js.Sequence({\n        value: [\n            // salt\n            new asn1js.OctetString({ valueHex: salt }),\n            // iteration count\n            new asn1js.Integer({ value: ITERATIONS }),\n            // key length\n            new asn1js.Integer({ value: KEY_SIZE }),\n            // AlgorithmIdentifier\n            new asn1js.Sequence({\n                value: [\n                    // hmacWithSHA512\n                    new asn1js.ObjectIdentifier({ value: '1.2.840.113549.2.11' }),\n                    new asn1js.Null()\n                ]\n            })\n        ]\n    });\n    const encryptionAlgorithm = new asn1js.Sequence({\n        value: [\n            // pkcs5PBES2\n            new asn1js.ObjectIdentifier({\n                value: '1.2.840.113549.1.5.13'\n            }),\n            new asn1js.Sequence({\n                value: [\n                    // keyDerivationFunc\n                    new asn1js.Sequence({\n                        value: [\n                            // pkcs5PBKDF2\n                            new asn1js.ObjectIdentifier({\n                                value: '1.2.840.113549.1.5.12'\n                            }),\n                            // PBKDF2-params\n                            pbkdf2Params\n                        ]\n                    }),\n                    // encryptionScheme\n                    new asn1js.Sequence({\n                        value: [\n                            // aes256-CBC\n                            new asn1js.ObjectIdentifier({\n                                value: '2.16.840.1.101.3.4.1.42'\n                            }),\n                            // iv\n                            new asn1js.OctetString({\n                                valueHex: iv\n                            })\n                        ]\n                    })\n                ]\n            })\n        ]\n    });\n    const finalWrapper = new asn1js.Sequence({\n        value: [\n            encryptionAlgorithm,\n            new asn1js.OctetString({ valueHex: encrypted })\n        ]\n    });\n    const finalWrapperBuf = finalWrapper.toBER();\n    const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);\n    return [\n        '-----BEGIN ENCRYPTED PRIVATE KEY-----',\n        ...uint8ArrayToString(finalWrapperArr, 'base64pad').split(/(.{64})/).filter(Boolean),\n        '-----END ENCRYPTED PRIVATE KEY-----'\n    ].join('\\n');\n}\nexport async function importFromPem(pem, password) {\n    const crypto = webcrypto.get();\n    let plaintext;\n    if (pem.includes('-----BEGIN ENCRYPTED PRIVATE KEY-----')) {\n        const key = uint8ArrayFromString(pem\n            .replace('-----BEGIN ENCRYPTED PRIVATE KEY-----', '')\n            .replace('-----END ENCRYPTED PRIVATE KEY-----', '')\n            .replace(/\\n/g, '')\n            .trim(), 'base64pad');\n        const { result } = asn1js.fromBER(key);\n        const { iv, salt, iterations, keySize, cipherText } = findEncryptedPEMData(result);\n        const encryptionKey = await pbkdf2Async(sha512, password, salt, {\n            c: iterations,\n            dkLen: keySize\n        });\n        const cryptoKey = await crypto.subtle.importKey('raw', encryptionKey, 'AES-CBC', false, ['decrypt']);\n        const decrypted = toUint8Array(await crypto.subtle.decrypt({\n            name: 'AES-CBC',\n            iv\n        }, cryptoKey, cipherText));\n        const { result: decryptedResult } = asn1js.fromBER(decrypted);\n        plaintext = findPEMData(decryptedResult);\n    }\n    else if (pem.includes('-----BEGIN PRIVATE KEY-----')) {\n        const key = uint8ArrayFromString(pem\n            .replace('-----BEGIN PRIVATE KEY-----', '')\n            .replace('-----END PRIVATE KEY-----', '')\n            .replace(/\\n/g, '')\n            .trim(), 'base64pad');\n        const { result } = asn1js.fromBER(key);\n        plaintext = findPEMData(result);\n    }\n    else {\n        throw new CodeError('Could not parse private key from PEM data', 'ERR_INVALID_PARAMETERS');\n    }\n    return unmarshalRsaPrivateKey(plaintext);\n}\nfunction findEncryptedPEMData(root) {\n    const encryptionAlgorithm = root.valueBlock.value[0];\n    const scheme = encryptionAlgorithm.valueBlock.value[0].toString();\n    if (scheme !== 'OBJECT IDENTIFIER : 1.2.840.113549.1.5.13') {\n        throw new CodeError('Only pkcs5PBES2 encrypted private keys are supported', 'ERR_INVALID_PARAMS');\n    }\n    const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];\n    const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();\n    if (keyDerivationFuncName !== 'OBJECT IDENTIFIER : 1.2.840.113549.1.5.12') {\n        throw new CodeError('Only pkcs5PBKDF2 key derivation functions are supported', 'ERR_INVALID_PARAMS');\n    }\n    const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];\n    const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());\n    let iterations = ITERATIONS;\n    let keySize = KEY_SIZE;\n    if (pbkdf2Params.valueBlock.value.length === 3) {\n        iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());\n        keySize = Number((pbkdf2Params.valueBlock.value[2]).toBigInt());\n    }\n    else if (pbkdf2Params.valueBlock.value.length === 2) {\n        throw new CodeError('Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key', 'ERR_INVALID_PARAMS');\n    }\n    const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];\n    const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();\n    if (encryptionSchemeName === 'OBJECT IDENTIFIER : 1.2.840.113549.3.7') {\n        // des-EDE3-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 1.3.14.3.2.7') {\n        // des-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2') {\n        // aes128-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22') {\n        // aes192-CBC\n    }\n    else if (encryptionSchemeName === 'OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42') {\n        // aes256-CBC\n    }\n    else {\n        throw new CodeError('Only AES-CBC encryption schemes are supported', 'ERR_INVALID_PARAMS');\n    }\n    const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());\n    return {\n        cipherText: toUint8Array(root.valueBlock.value[1].getValue()),\n        salt,\n        iterations,\n        keySize,\n        iv\n    };\n}\nfunction findPEMData(seq) {\n    return toUint8Array(seq.valueBlock.value[2].getValue());\n}\nfunction toUint8Array(buf) {\n    return new Uint8Array(buf, 0, buf.byteLength);\n}\n//# sourceMappingURL=rsa-utils.js.map","import { CodeError } from '@libp2p/interface';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { isPromise } from '../util.js';\nconst PRIVATE_KEY_BYTE_LENGTH = 32;\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport function generateKey() {\n    return secp.utils.randomPrivateKey();\n}\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign(key, msg) {\n    const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());\n    if (isPromise(p)) {\n        return p.then(({ digest }) => secp.sign(digest, key).toDERRawBytes())\n            .catch(err => {\n            throw new CodeError(String(err), 'ERR_INVALID_INPUT');\n        });\n    }\n    try {\n        return secp.sign(p.digest, key).toDERRawBytes();\n    }\n    catch (err) {\n        throw new CodeError(String(err), 'ERR_INVALID_INPUT');\n    }\n}\n/**\n * Hash message and verify signature with public key\n */\nexport function hashAndVerify(key, sig, msg) {\n    const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());\n    if (isPromise(p)) {\n        return p.then(({ digest }) => secp.verify(sig, digest, key))\n            .catch(err => {\n            throw new CodeError(String(err), 'ERR_INVALID_INPUT');\n        });\n    }\n    try {\n        return secp.verify(sig, p.digest, key);\n    }\n    catch (err) {\n        throw new CodeError(String(err), 'ERR_INVALID_INPUT');\n    }\n}\nexport function compressPublicKey(key) {\n    const point = secp.ProjectivePoint.fromHex(key).toRawBytes(true);\n    return point;\n}\nexport function decompressPublicKey(key) {\n    const point = secp.ProjectivePoint.fromHex(key).toRawBytes(false);\n    return point;\n}\nexport function validatePrivateKey(key) {\n    try {\n        secp.getPublicKey(key, true);\n    }\n    catch (err) {\n        throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n    }\n}\nexport function validatePublicKey(key) {\n    try {\n        secp.ProjectivePoint.fromHex(key);\n    }\n    catch (err) {\n        throw new CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY');\n    }\n}\nexport function computePublicKey(privateKey) {\n    try {\n        return secp.getPublicKey(privateKey, true);\n    }\n    catch (err) {\n        throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY');\n    }\n}\n//# sourceMappingURL=secp256k1-browser.js.map","import { CodeError } from '@libp2p/interface';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { isPromise } from '../util.js';\nimport { exporter } from './exporter.js';\nimport * as keysProtobuf from './keys.js';\nimport * as crypto from './secp256k1.js';\nexport class Secp256k1PublicKey {\n    _key;\n    constructor(key) {\n        crypto.validatePublicKey(key);\n        this._key = key;\n    }\n    verify(data, sig) {\n        return crypto.hashAndVerify(this._key, sig, data);\n    }\n    marshal() {\n        return crypto.compressPublicKey(this._key);\n    }\n    get bytes() {\n        return keysProtobuf.PublicKey.encode({\n            Type: keysProtobuf.KeyType.Secp256k1,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n    async hash() {\n        const p = sha256.digest(this.bytes);\n        let bytes;\n        if (isPromise(p)) {\n            ({ bytes } = await p);\n        }\n        else {\n            bytes = p.bytes;\n        }\n        return bytes;\n    }\n}\nexport class Secp256k1PrivateKey {\n    _key;\n    _publicKey;\n    constructor(key, publicKey) {\n        this._key = key;\n        this._publicKey = publicKey ?? crypto.computePublicKey(key);\n        crypto.validatePrivateKey(this._key);\n        crypto.validatePublicKey(this._publicKey);\n    }\n    sign(message) {\n        return crypto.hashAndSign(this._key, message);\n    }\n    get public() {\n        return new Secp256k1PublicKey(this._publicKey);\n    }\n    marshal() {\n        return this._key;\n    }\n    get bytes() {\n        return keysProtobuf.PrivateKey.encode({\n            Type: keysProtobuf.KeyType.Secp256k1,\n            Data: this.marshal()\n        }).subarray();\n    }\n    equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n    hash() {\n        const p = sha256.digest(this.bytes);\n        if (isPromise(p)) {\n            return p.then(({ bytes }) => bytes);\n        }\n        return p.bytes;\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     */\n    async id() {\n        const hash = await this.public.hash();\n        return uint8ArrayToString(hash, 'base58btc');\n    }\n    /**\n     * Exports the key into a password protected `format`\n     */\n    async export(password, format = 'libp2p-key') {\n        if (format === 'libp2p-key') {\n            return exporter(this.bytes, password);\n        }\n        else {\n            throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT');\n        }\n    }\n}\nexport function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n}\nexport function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n}\nexport async function generateKeyPair() {\n    const privateKeyBytes = crypto.generateKey();\n    return new Secp256k1PrivateKey(privateKeyBytes);\n}\n//# sourceMappingURL=secp256k1-class.js.map","import { CodeError } from '@libp2p/interface';\nimport { randomBytes as randB } from '@noble/hashes/utils';\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nexport default function randomBytes(length) {\n    if (isNaN(length) || length <= 0) {\n        throw new CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH');\n    }\n    return randB(length);\n}\n//# sourceMappingURL=random-bytes.js.map","import { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nexport function base64urlToBuffer(str, len) {\n    let buf = uint8ArrayFromString(str, 'base64urlpad');\n    if (len != null) {\n        if (buf.length > len)\n            throw new Error('byte array longer than desired length');\n        buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);\n    }\n    return buf;\n}\nexport function isPromise(thing) {\n    if (thing == null) {\n        return false;\n    }\n    return typeof thing.then === 'function' &&\n        typeof thing.catch === 'function' &&\n        typeof thing.finally === 'function';\n}\n//# sourceMappingURL=util.js.map","/* eslint-env browser */\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\nexport default {\n    get(win = globalThis) {\n        const nativeCrypto = win.crypto;\n        if (nativeCrypto?.subtle == null) {\n            throw Object.assign(new Error('Missing Web Crypto API. ' +\n                'The most likely cause of this error is that this page is being accessed ' +\n                'from an insecure context (i.e. not HTTPS). For more information and ' +\n                'possible resolutions see ' +\n                'https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api'), { code: 'ERR_MISSING_WEB_CRYPTO' });\n        }\n        return nativeCrypto;\n    }\n};\n//# sourceMappingURL=webcrypto-browser.js.map","export const PROTOCOL_VERSION = 'ipfs/0.1.0'; // deprecated\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0'; // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0'; // deprecated\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0';\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id';\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push';\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0';\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0';\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nexport const MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;\n// https://github.com/libp2p/go-libp2p/blob/0385ec924bad172f74a74db09939e97c079b1420/p2p/protocol/identify/id.go#L47C7-L47C25\nexport const MAX_PUSH_CONCURRENCY = 32;\n//# sourceMappingURL=consts.js.map","/* eslint-disable complexity */\nimport { serviceCapabilities, setMaxListeners } from '@libp2p/interface';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { protocols } from '@multiformats/multiaddr';\nimport drain from 'it-drain';\nimport parallel from 'it-parallel';\nimport { pbStream } from 'it-protobuf-stream';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION } from './consts.js';\nimport { Identify as IdentifyMessage } from './pb/message.js';\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues } from './utils.js';\nexport class IdentifyPush extends AbstractIdentify {\n    connectionManager;\n    concurrency;\n    constructor(components, init = {}) {\n        super(components, {\n            ...init,\n            protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,\n            log: components.logger.forComponent('libp2p:identify-push')\n        });\n        this.connectionManager = components.connectionManager;\n        this.concurrency = init.concurrency ?? defaultValues.concurrency;\n        if ((init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate)) {\n            // When self peer record changes, trigger identify-push\n            components.events.addEventListener('self:peer:update', (evt) => {\n                void this.push().catch(err => { this.log.error(err); });\n            });\n        }\n    }\n    [serviceCapabilities] = [\n        '@libp2p/identify-push'\n    ];\n    /**\n     * Calls `push` on all peer connections\n     */\n    async push() {\n        // Do not try to push if we are not running\n        if (!this.isStarted()) {\n            return;\n        }\n        const listenAddresses = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code));\n        const peerRecord = new PeerRecord({\n            peerId: this.peerId,\n            multiaddrs: listenAddresses\n        });\n        const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);\n        const supportedProtocols = this.registrar.getProtocols();\n        const peer = await this.peerStore.get(this.peerId);\n        const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion));\n        const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion));\n        const self = this;\n        async function* pushToConnections() {\n            for (const connection of self.connectionManager.getConnections()) {\n                const peer = await self.peerStore.get(connection.remotePeer);\n                if (!peer.protocols.includes(self.protocol)) {\n                    continue;\n                }\n                yield async () => {\n                    let stream;\n                    const signal = AbortSignal.timeout(self.timeout);\n                    setMaxListeners(Infinity, signal);\n                    try {\n                        stream = await connection.newStream(self.protocol, {\n                            signal,\n                            runOnTransientConnection: self.runOnTransientConnection\n                        });\n                        const pb = pbStream(stream, {\n                            maxDataLength: self.maxMessageSize\n                        }).pb(IdentifyMessage);\n                        await pb.write({\n                            listenAddrs: listenAddresses.map(ma => ma.bytes),\n                            signedPeerRecord: signedPeerRecord.marshal(),\n                            protocols: supportedProtocols,\n                            agentVersion,\n                            protocolVersion\n                        }, {\n                            signal\n                        });\n                        await stream.close({\n                            signal\n                        });\n                    }\n                    catch (err) {\n                        // Just log errors\n                        self.log.error('could not push identify update to peer', err);\n                        stream?.abort(err);\n                    }\n                };\n            }\n        }\n        await drain(parallel(pushToConnections(), {\n            concurrency: this.concurrency\n        }));\n    }\n    /**\n     * Reads the Identify Push message from the given `connection`\n     */\n    async handleProtocol(data) {\n        const { connection, stream } = data;\n        try {\n            if (this.peerId.equals(connection.remotePeer)) {\n                throw new Error('received push from ourselves?');\n            }\n            const options = {\n                signal: AbortSignal.timeout(this.timeout)\n            };\n            const pb = pbStream(stream, {\n                maxDataLength: this.maxMessageSize\n            }).pb(IdentifyMessage);\n            const message = await pb.read(options);\n            await stream.close(options);\n            await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message);\n        }\n        catch (err) {\n            this.log.error('received invalid message', err);\n            stream.abort(err);\n            return;\n        }\n        this.log('handled push from %p', connection.remotePeer);\n    }\n}\n//# sourceMappingURL=identify-push.js.map","/* eslint-disable complexity */\nimport { CodeError, serviceCapabilities, setMaxListeners } from '@libp2p/interface';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { protocols } from '@multiformats/multiaddr';\nimport { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher';\nimport { pbStream } from 'it-protobuf-stream';\nimport { MULTICODEC_IDENTIFY_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PROTOCOL_VERSION } from './consts.js';\nimport { Identify as IdentifyMessage } from './pb/message.js';\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues, getCleanMultiaddr } from './utils.js';\nexport class Identify extends AbstractIdentify {\n    constructor(components, init = {}) {\n        super(components, {\n            ...init,\n            protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n            log: components.logger.forComponent('libp2p:identify')\n        });\n        if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n            // When a new connection happens, trigger identify\n            components.events.addEventListener('connection:open', (evt) => {\n                const connection = evt.detail;\n                this.identify(connection).catch(err => { this.log.error('error during identify trigged by connection:open', err); });\n            });\n        }\n    }\n    [serviceCapabilities] = [\n        '@libp2p/identify'\n    ];\n    async _identify(connection, options = {}) {\n        let stream;\n        if (options.signal == null) {\n            const signal = AbortSignal.timeout(this.timeout);\n            setMaxListeners(Infinity, signal);\n            options = {\n                ...options,\n                signal\n            };\n        }\n        try {\n            stream = await connection.newStream(this.protocol, {\n                ...options,\n                runOnTransientConnection: this.runOnTransientConnection\n            });\n            const pb = pbStream(stream, {\n                maxDataLength: this.maxMessageSize\n            }).pb(IdentifyMessage);\n            const message = await pb.read(options);\n            await stream.close(options);\n            return message;\n        }\n        catch (err) {\n            this.log.error('error while reading identify message', err);\n            stream?.abort(err);\n            throw err;\n        }\n    }\n    async identify(connection, options = {}) {\n        const message = await this._identify(connection, options);\n        const { publicKey, protocols, observedAddr } = message;\n        if (publicKey == null) {\n            throw new CodeError('public key was missing from identify message', 'ERR_MISSING_PUBLIC_KEY');\n        }\n        const id = await peerIdFromKeys(publicKey);\n        if (!connection.remotePeer.equals(id)) {\n            throw new CodeError('identified peer does not match the expected peer', 'ERR_INVALID_PEER');\n        }\n        if (this.peerId.equals(id)) {\n            throw new CodeError('identified peer is our own peer id?', 'ERR_INVALID_PEER');\n        }\n        // Get the observedAddr if there is one\n        const cleanObservedAddr = getCleanMultiaddr(observedAddr);\n        this.log('identify completed for peer %p and protocols %o', id, protocols);\n        this.log('our observed address is %a', cleanObservedAddr);\n        if (cleanObservedAddr != null &&\n            this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {\n            this.log('storing our observed address %a', cleanObservedAddr);\n            this.addressManager.addObservedAddr(cleanObservedAddr);\n        }\n        return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message);\n    }\n    /**\n     * Sends the `Identify` response with the Signed Peer Record\n     * to the requesting peer over the given `connection`\n     */\n    async handleProtocol(data) {\n        const { connection, stream } = data;\n        const signal = AbortSignal.timeout(this.timeout);\n        setMaxListeners(Infinity, signal);\n        try {\n            const publicKey = this.peerId.publicKey ?? new Uint8Array(0);\n            const peerData = await this.peerStore.get(this.peerId);\n            const multiaddrs = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code));\n            let signedPeerRecord = peerData.peerRecordEnvelope;\n            if (multiaddrs.length > 0 && signedPeerRecord == null) {\n                const peerRecord = new PeerRecord({\n                    peerId: this.peerId,\n                    multiaddrs\n                });\n                const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);\n                signedPeerRecord = envelope.marshal().subarray();\n            }\n            let observedAddr = connection.remoteAddr.bytes;\n            if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {\n                observedAddr = undefined;\n            }\n            const pb = pbStream(stream).pb(IdentifyMessage);\n            await pb.write({\n                protocolVersion: this.host.protocolVersion,\n                agentVersion: this.host.agentVersion,\n                publicKey,\n                listenAddrs: multiaddrs.map(addr => addr.bytes),\n                signedPeerRecord,\n                observedAddr,\n                protocols: peerData.protocols\n            }, {\n                signal\n            });\n            await stream.close({\n                signal\n            });\n        }\n        catch (err) {\n            this.log.error('could not respond to identify request', err);\n            stream.abort(err);\n        }\n    }\n}\n//# sourceMappingURL=identify.js.map","/**\n * @packageDocumentation\n *\n * Use the `identify` function to add support for the [Identify protocol](https://github.com/libp2p/specs/blob/master/identify/README.md) to libp2p.\n *\n * This protocol allows network peers to discover the multiaddrs the current node listens on, and the protocols it supports.\n *\n * A second function, `identifyPush` is also exported to add support for [identify/push](https://github.com/libp2p/specs/blob/master/identify/README.md#identifypush).\n *\n * This protocol will send updates to all connected peers when the multiaddrs or protocols of the current node change.\n *\n * > [!TIP]\n * > For maximum network compatibility you should configure both protocols\n *\n * @example Enabling identify\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identify } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identify: identify()\n *   }\n * })\n * ```\n *\n * @example Enabling identify push\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identifyPush } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identifyPush: identifyPush()\n *   }\n * })\n * ```\n */\nimport { IdentifyPush as IdentifyPushClass } from './identify-push.js';\nimport { Identify as IdentifyClass } from './identify.js';\nexport function identify(init = {}) {\n    return (components) => new IdentifyClass(components, init);\n}\nexport function identifyPush(init = {}) {\n    return (components) => new IdentifyPushClass(components, init);\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Identify;\n(function (Identify) {\n    let _codec;\n    Identify.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.protocolVersion != null) {\n                    w.uint32(42);\n                    w.string(obj.protocolVersion);\n                }\n                if (obj.agentVersion != null) {\n                    w.uint32(50);\n                    w.string(obj.agentVersion);\n                }\n                if (obj.publicKey != null) {\n                    w.uint32(10);\n                    w.bytes(obj.publicKey);\n                }\n                if (obj.listenAddrs != null) {\n                    for (const value of obj.listenAddrs) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (obj.observedAddr != null) {\n                    w.uint32(34);\n                    w.bytes(obj.observedAddr);\n                }\n                if (obj.protocols != null) {\n                    for (const value of obj.protocols) {\n                        w.uint32(26);\n                        w.string(value);\n                    }\n                }\n                if (obj.signedPeerRecord != null) {\n                    w.uint32(66);\n                    w.bytes(obj.signedPeerRecord);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    listenAddrs: [],\n                    protocols: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 5:\n                            obj.protocolVersion = reader.string();\n                            break;\n                        case 6:\n                            obj.agentVersion = reader.string();\n                            break;\n                        case 1:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.listenAddrs.push(reader.bytes());\n                            break;\n                        case 4:\n                            obj.observedAddr = reader.bytes();\n                            break;\n                        case 3:\n                            obj.protocols.push(reader.string());\n                            break;\n                        case 8:\n                            obj.signedPeerRecord = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Identify.encode = (obj) => {\n        return encodeMessage(obj, Identify.codec());\n    };\n    Identify.decode = (buf) => {\n        return decodeMessage(buf, Identify.codec());\n    };\n})(Identify || (Identify = {}));\n//# sourceMappingURL=message.js.map","import { CodeError } from '@libp2p/interface';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { isNode, isBrowser, isWebWorker, isElectronMain, isElectronRenderer, isReactNative } from 'wherearewe';\nimport { IDENTIFY_PROTOCOL_VERSION, MAX_IDENTIFY_MESSAGE_SIZE, MAX_PUSH_CONCURRENCY } from './consts.js';\nexport const defaultValues = {\n    protocolPrefix: 'ipfs',\n    timeout: 5000,\n    maxInboundStreams: 1,\n    maxOutboundStreams: 1,\n    maxObservedAddresses: 10,\n    maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,\n    runOnConnectionOpen: true,\n    runOnSelfUpdate: true,\n    runOnTransientConnection: true,\n    concurrency: MAX_PUSH_CONCURRENCY\n};\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nexport function getCleanMultiaddr(addr) {\n    if (addr != null && addr.length > 0) {\n        try {\n            return multiaddr(addr);\n        }\n        catch {\n        }\n    }\n}\nexport function getAgentVersion(nodeInfo, agentVersion) {\n    if (agentVersion != null) {\n        return agentVersion;\n    }\n    agentVersion = `${nodeInfo.name}/${nodeInfo.version}`;\n    // Append user agent version to default AGENT_VERSION depending on the environment\n    if (isNode || isElectronMain) {\n        agentVersion += ` UserAgent=${globalThis.process.version}`;\n    }\n    else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {\n        agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;\n    }\n    return agentVersion;\n}\nexport async function consumeIdentifyMessage(peerStore, events, log, connection, message) {\n    log('received identify from %p', connection.remotePeer);\n    if (message == null) {\n        throw new CodeError('message was null or undefined', 'ERR_INVALID_MESSAGE');\n    }\n    const peer = {};\n    if (message.listenAddrs.length > 0) {\n        peer.addresses = message.listenAddrs.map(buf => ({\n            isCertified: false,\n            multiaddr: multiaddr(buf)\n        }));\n    }\n    if (message.protocols.length > 0) {\n        peer.protocols = message.protocols;\n    }\n    if (message.publicKey != null) {\n        peer.publicKey = message.publicKey;\n        const peerId = await peerIdFromKeys(message.publicKey);\n        if (!peerId.equals(connection.remotePeer)) {\n            throw new CodeError('public key did not match remote PeerId', 'ERR_INVALID_PUBLIC_KEY');\n        }\n    }\n    let output;\n    // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n    if (message.signedPeerRecord != null) {\n        log('received signedPeerRecord from %p', connection.remotePeer);\n        let peerRecordEnvelope = message.signedPeerRecord;\n        const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);\n        let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n        // Verify peerId\n        if (!peerRecord.peerId.equals(envelope.peerId)) {\n            throw new CodeError('signing key does not match PeerId in the PeerRecord', 'ERR_INVALID_SIGNING_KEY');\n        }\n        // Make sure remote peer is the one sending the record\n        if (!connection.remotePeer.equals(peerRecord.peerId)) {\n            throw new CodeError('signing key does not match remote PeerId', 'ERR_INVALID_PEER_RECORD_KEY');\n        }\n        let existingPeer;\n        try {\n            existingPeer = await peerStore.get(peerRecord.peerId);\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        if (existingPeer != null) {\n            // don't lose any existing metadata\n            peer.metadata = existingPeer.metadata;\n            // if we have previously received a signed record for this peer, compare it to the incoming one\n            if (existingPeer.peerRecordEnvelope != null) {\n                const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);\n                const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);\n                // ensure seq is greater than, or equal to, the last received\n                if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n                    log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n                    peerRecord = storedRecord;\n                    peerRecordEnvelope = existingPeer.peerRecordEnvelope;\n                }\n            }\n        }\n        // store the signed record for next time\n        peer.peerRecordEnvelope = peerRecordEnvelope;\n        // override the stored addresses with the signed multiaddrs\n        peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n            isCertified: true,\n            multiaddr\n        }));\n        output = {\n            seq: peerRecord.seqNumber,\n            addresses: peerRecord.multiaddrs\n        };\n    }\n    else {\n        log('%p did not send a signed peer record', connection.remotePeer);\n    }\n    log('patching %p with', connection.remotePeer, peer);\n    await peerStore.patch(connection.remotePeer, peer);\n    if (message.agentVersion != null || message.protocolVersion != null) {\n        const metadata = {};\n        if (message.agentVersion != null) {\n            metadata.AgentVersion = uint8ArrayFromString(message.agentVersion);\n        }\n        if (message.protocolVersion != null) {\n            metadata.ProtocolVersion = uint8ArrayFromString(message.protocolVersion);\n        }\n        log('merging %p metadata', connection.remotePeer, metadata);\n        await peerStore.merge(connection.remotePeer, {\n            metadata\n        });\n    }\n    const result = {\n        peerId: connection.remotePeer,\n        protocolVersion: message.protocolVersion,\n        agentVersion: message.agentVersion,\n        publicKey: message.publicKey,\n        listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n        observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n        protocols: message.protocols,\n        signedPeerRecord: output,\n        connection\n    };\n    events.safeDispatchEvent('peer:identify', { detail: result });\n    return result;\n}\nexport class AbstractIdentify {\n    host;\n    protocol;\n    started;\n    timeout;\n    peerId;\n    peerStore;\n    registrar;\n    addressManager;\n    maxInboundStreams;\n    maxOutboundStreams;\n    maxMessageSize;\n    maxObservedAddresses;\n    events;\n    runOnTransientConnection;\n    log;\n    constructor(components, init) {\n        this.protocol = init.protocol;\n        this.started = false;\n        this.peerId = components.peerId;\n        this.peerStore = components.peerStore;\n        this.registrar = components.registrar;\n        this.addressManager = components.addressManager;\n        this.events = components.events;\n        this.log = init.log;\n        this.timeout = init.timeout ?? defaultValues.timeout;\n        this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;\n        this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;\n        this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize;\n        this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;\n        this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection;\n        // Store self host metadata\n        this.host = {\n            protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n            agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)\n        };\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        if (this.started) {\n            return;\n        }\n        await this.peerStore.merge(this.peerId, {\n            metadata: {\n                AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n                ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n            }\n        });\n        await this.registrar.handle(this.protocol, (data) => {\n            void this.handleProtocol(data).catch(err => {\n                this.log.error(err);\n            });\n        }, {\n            maxInboundStreams: this.maxInboundStreams,\n            maxOutboundStreams: this.maxOutboundStreams,\n            runOnTransientConnection: this.runOnTransientConnection\n        });\n        this.started = true;\n    }\n    async stop() {\n        await this.registrar.unhandle(this.protocol);\n        this.started = false;\n    }\n}\n//# sourceMappingURL=utils.js.map","export const connectionSymbol = Symbol.for('@libp2p/connection');\nexport function isConnection(other) {\n    return other != null && Boolean(other[connectionSymbol]);\n}\n//# sourceMappingURL=index.js.map","/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRoutingSymbol = Symbol.for('@libp2p/content-routing');\n//# sourceMappingURL=index.js.map","/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n    code;\n    type;\n    constructor(message = 'The operation was aborted') {\n        super(message);\n        this.name = 'AbortError';\n        this.code = AbortError.code;\n        this.type = AbortError.type;\n    }\n    static code = 'ABORT_ERR';\n    static type = 'aborted';\n}\nexport class CodeError extends Error {\n    code;\n    props;\n    constructor(message, code, props) {\n        super(message);\n        this.code = code;\n        this.name = props?.name ?? 'CodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nexport class AggregateCodeError extends AggregateError {\n    code;\n    props;\n    constructor(errors, message, code, props) {\n        super(errors, message);\n        this.code = code;\n        this.name = props?.name ?? 'AggregateCodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nexport class UnexpectedPeerError extends Error {\n    code;\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.name = 'UnexpectedPeerError';\n        this.code = UnexpectedPeerError.code;\n    }\n    static code = 'ERR_UNEXPECTED_PEER';\n}\nexport class InvalidCryptoExchangeError extends Error {\n    code;\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.name = 'InvalidCryptoExchangeError';\n        this.code = InvalidCryptoExchangeError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_EXCHANGE';\n}\nexport class InvalidCryptoTransmissionError extends Error {\n    code;\n    constructor(message = 'Invalid crypto transmission') {\n        super(message);\n        this.name = 'InvalidCryptoTransmissionError';\n        this.code = InvalidCryptoTransmissionError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_TRANSMISSION';\n}\n// Error codes\nexport const ERR_TIMEOUT = 'ERR_TIMEOUT';\nexport const ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS';\nexport const ERR_NOT_FOUND = 'ERR_NOT_FOUND';\nexport const ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE';\n//# sourceMappingURL=errors.js.map","import { setMaxListeners } from './events.js';\n/**\n * An implementation of a typed event target\n * etc\n */\nexport class TypedEventEmitter extends EventTarget {\n    #listeners = new Map();\n    constructor() {\n        super();\n        // silence MaxListenersExceededWarning warning on Node.js, this is a red\n        // herring almost all of the time\n        setMaxListeners(Infinity, this);\n    }\n    listenerCount(type) {\n        const listeners = this.#listeners.get(type);\n        if (listeners == null) {\n            return 0;\n        }\n        return listeners.length;\n    }\n    addEventListener(type, listener, options) {\n        super.addEventListener(type, listener, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            list = [];\n            this.#listeners.set(type, list);\n        }\n        list.push({\n            callback: listener,\n            once: (options !== true && options !== false && options?.once) ?? false\n        });\n    }\n    removeEventListener(type, listener, options) {\n        super.removeEventListener(type.toString(), listener ?? null, options);\n        let list = this.#listeners.get(type);\n        if (list == null) {\n            return;\n        }\n        list = list.filter(({ callback }) => callback !== listener);\n        this.#listeners.set(type, list);\n    }\n    dispatchEvent(event) {\n        const result = super.dispatchEvent(event);\n        let list = this.#listeners.get(event.type);\n        if (list == null) {\n            return result;\n        }\n        list = list.filter(({ once }) => !once);\n        this.#listeners.set(event.type, list);\n        return result;\n    }\n    safeDispatchEvent(type, detail = {}) {\n        return this.dispatchEvent(new CustomEvent(type, detail));\n    }\n}\nexport const CustomEvent = globalThis.CustomEvent;\n//# sourceMappingURL=event-target.js.map","/** Noop for browser compatibility */\nexport function setMaxListeners() { }\n//# sourceMappingURL=events.browser.js.map","import { setMaxListeners as nodeSetMaxListeners } from 'events';\n// create a setMaxListeners that doesn't break browser usage\nexport const setMaxListeners = (n, ...eventTargets) => {\n    try {\n        nodeSetMaxListeners(n, ...eventTargets);\n    }\n    catch {\n        // swallow error, gulp\n    }\n};\n//# sourceMappingURL=events.js.map","/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities');\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies');\nexport * from './connection/index.js';\nexport * from './connection-encrypter/index.js';\nexport * from './connection-gater/index.js';\nexport * from './content-routing/index.js';\nexport * from './keys/index.js';\nexport * from './metrics/index.js';\nexport * from './peer-discovery/index.js';\nexport * from './peer-id/index.js';\nexport * from './peer-info/index.js';\nexport * from './peer-routing/index.js';\nexport * from './peer-store/index.js';\nexport * from './peer-store/tags.js';\nexport * from './pubsub/index.js';\nexport * from './record/index.js';\nexport * from './stream-handler/index.js';\nexport * from './stream-muxer/index.js';\nexport * from './topology/index.js';\nexport * from './transport/index.js';\nexport * from './errors.js';\nexport * from './event-target.js';\nexport * from './events.js';\nexport * from './startable.js';\n//# sourceMappingURL=index.js.map","export const Ed25519 = 'Ed25519';\nexport const RSA = 'RSA';\nexport const secp256k1 = 'secp256k1';\n//# sourceMappingURL=index.js.map","/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscoverySymbol = Symbol.for('@libp2p/peer-discovery');\n//# sourceMappingURL=index.js.map","export const peerIdSymbol = Symbol.for('@libp2p/peer-id');\nexport function isPeerId(other) {\n    return other != null && Boolean(other[peerIdSymbol]);\n}\n//# sourceMappingURL=index.js.map","/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRoutingSymbol = Symbol.for('@libp2p/peer-routing');\n//# sourceMappingURL=index.js.map","export const KEEP_ALIVE = 'keep-alive';\n//# sourceMappingURL=tags.js.map","/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign';\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign';\nexport var TopicValidatorResult;\n(function (TopicValidatorResult) {\n    /**\n     * The message is considered valid, and it should be delivered and forwarded to the network\n     */\n    TopicValidatorResult[\"Accept\"] = \"accept\";\n    /**\n     * The message is neither delivered nor forwarded to the network\n     */\n    TopicValidatorResult[\"Ignore\"] = \"ignore\";\n    /**\n     * The message is considered invalid, and it should be rejected\n     */\n    TopicValidatorResult[\"Reject\"] = \"reject\";\n})(TopicValidatorResult || (TopicValidatorResult = {}));\n//# sourceMappingURL=index.js.map","export function isStartable(obj) {\n    return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function';\n}\nexport async function start(...objs) {\n    const startables = [];\n    for (const obj of objs) {\n        if (isStartable(obj)) {\n            startables.push(obj);\n        }\n    }\n    await Promise.all(startables.map(async (s) => {\n        if (s.beforeStart != null) {\n            await s.beforeStart();\n        }\n    }));\n    await Promise.all(startables.map(async (s) => {\n        await s.start();\n    }));\n    await Promise.all(startables.map(async (s) => {\n        if (s.afterStart != null) {\n            await s.afterStart();\n        }\n    }));\n}\nexport async function stop(...objs) {\n    const startables = [];\n    for (const obj of objs) {\n        if (isStartable(obj)) {\n            startables.push(obj);\n        }\n    }\n    await Promise.all(startables.map(async (s) => {\n        if (s.beforeStop != null) {\n            await s.beforeStop();\n        }\n    }));\n    await Promise.all(startables.map(async (s) => {\n        await s.stop();\n    }));\n    await Promise.all(startables.map(async (s) => {\n        if (s.afterStop != null) {\n            await s.afterStop();\n        }\n    }));\n}\n//# sourceMappingURL=startable.js.map","export const transportSymbol = Symbol.for('@libp2p/transport');\nexport function isTransport(other) {\n    return other != null && Boolean(other[transportSymbol]);\n}\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport var FaultTolerance;\n(function (FaultTolerance) {\n    /**\n     * should be used for failing in any listen circumstance\n     */\n    FaultTolerance[FaultTolerance[\"FATAL_ALL\"] = 0] = \"FATAL_ALL\";\n    /**\n     * should be used for not failing when not listening\n     */\n    FaultTolerance[FaultTolerance[\"NO_FATAL\"] = 1] = \"NO_FATAL\";\n})(FaultTolerance || (FaultTolerance = {}));\n//# sourceMappingURL=index.js.map","// MaxRecordAge specifies the maximum time that any node will hold onto a record\n// from the time its received. This does not apply to any other forms of validity that\n// the record may contain.\n// For example, a record may contain an ipns entry with an EOL saying its valid\n// until the year 2020 (a great time in the future). For that record to stick around\n// it must be rebroadcasted more frequently than once every 'MaxRecordAge'\nexport const second = 1000;\nexport const minute = 60 * second;\nexport const hour = 60 * minute;\nexport const MAX_RECORD_AGE = 36 * hour;\nexport const PROTOCOL = '/ipfs/kad/1.0.0';\nexport const RECORD_KEY_PREFIX = '/dht/record';\nexport const PROVIDER_KEY_PREFIX = '/dht/provider';\nexport const PROVIDERS_LRU_CACHE_SIZE = 256;\nexport const PROVIDERS_VALIDITY = 24 * hour;\nexport const PROVIDERS_CLEANUP_INTERVAL = hour;\nexport const READ_MESSAGE_TIMEOUT = 10 * second;\n// The number of records that will be retrieved on a call to getMany()\nexport const GET_MANY_RECORD_COUNT = 16;\n// K is the maximum number of requests to perform before returning failure\nexport const K = 20;\n// Alpha is the concurrency for asynchronous requests\nexport const ALPHA = 3;\n// How often we look for our closest DHT neighbours\nexport const QUERY_SELF_INTERVAL = 5 * minute;\n// How often we look for the first set of our closest DHT neighbours\nexport const QUERY_SELF_INITIAL_INTERVAL = second;\n// How long to look for our closest DHT neighbours for\nexport const QUERY_SELF_TIMEOUT = 5 * second;\n// How often we try to find new peers\nexport const TABLE_REFRESH_INTERVAL = 5 * minute;\n// How how long to look for new peers for\nexport const TABLE_REFRESH_QUERY_TIMEOUT = 30 * second;\n// When a timeout is not specified, run a query for this long\nexport const DEFAULT_QUERY_TIMEOUT = 180 * second;\n//# sourceMappingURL=constants.js.map","import { CodeError } from '@libp2p/interface';\nimport { Libp2pRecord } from '@libp2p/record';\nimport map from 'it-map';\nimport parallel from 'it-parallel';\nimport { pipe } from 'it-pipe';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { ALPHA } from '../constants.js';\nimport { MessageType } from '../message/dht.js';\nimport { valueEvent, queryErrorEvent } from '../query/events.js';\nimport { bestRecord } from '../record/selectors.js';\nimport { verifyRecord } from '../record/validators.js';\nimport { createPutRecord, bufferToRecordKey } from '../utils.js';\nexport class ContentFetching {\n    log;\n    components;\n    validators;\n    selectors;\n    peerRouting;\n    queryManager;\n    network;\n    constructor(components, init) {\n        const { validators, selectors, peerRouting, queryManager, network, logPrefix } = init;\n        this.components = components;\n        this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);\n        this.validators = validators;\n        this.selectors = selectors;\n        this.peerRouting = peerRouting;\n        this.queryManager = queryManager;\n        this.network = network;\n    }\n    /**\n     * Attempt to retrieve the value for the given key from\n     * the local datastore\n     */\n    async getLocal(key) {\n        this.log('getLocal %b', key);\n        const dsKey = bufferToRecordKey(key);\n        this.log('fetching record for key %k', dsKey);\n        const raw = await this.components.datastore.get(dsKey);\n        this.log('found %k in local datastore', dsKey);\n        const rec = Libp2pRecord.deserialize(raw);\n        await verifyRecord(this.validators, rec);\n        return rec;\n    }\n    /**\n     * Send the best record found to any peers that have an out of date record\n     */\n    async *sendCorrectionRecord(key, vals, best, options = {}) {\n        this.log('sendCorrection for %b', key);\n        const fixupRec = createPutRecord(key, best);\n        for (const { value, from } of vals) {\n            // no need to do anything\n            if (uint8ArrayEquals(value, best)) {\n                this.log('record was ok');\n                continue;\n            }\n            // correct ourself\n            if (this.components.peerId.equals(from)) {\n                try {\n                    const dsKey = bufferToRecordKey(key);\n                    this.log(`Storing corrected record for key ${dsKey.toString()}`);\n                    await this.components.datastore.put(dsKey, fixupRec.subarray());\n                }\n                catch (err) {\n                    this.log.error('Failed error correcting self', err);\n                }\n                continue;\n            }\n            // send correction\n            let sentCorrection = false;\n            const request = {\n                type: MessageType.PUT_VALUE,\n                key,\n                record: fixupRec\n            };\n            for await (const event of this.network.sendRequest(from, request, options)) {\n                if (event.name === 'PEER_RESPONSE' && (event.record != null) && uint8ArrayEquals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {\n                    sentCorrection = true;\n                }\n                yield event;\n            }\n            if (!sentCorrection) {\n                yield queryErrorEvent({ from, error: new CodeError('value not put correctly', 'ERR_PUT_VALUE_INVALID') }, options);\n            }\n            this.log.error('Failed error correcting entry');\n        }\n    }\n    /**\n     * Store the given key/value pair in the DHT\n     */\n    async *put(key, value, options = {}) {\n        this.log('put key %b value %b', key, value);\n        // create record in the dht format\n        const record = createPutRecord(key, value);\n        // store the record locally\n        const dsKey = bufferToRecordKey(key);\n        this.log(`storing record for key ${dsKey.toString()}`);\n        await this.components.datastore.put(dsKey, record.subarray());\n        // put record to the closest peers\n        yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => map(source, (event) => {\n            return async () => {\n                if (event.name !== 'FINAL_PEER') {\n                    return [event];\n                }\n                const events = [];\n                const msg = {\n                    type: MessageType.PUT_VALUE,\n                    key,\n                    record\n                };\n                this.log('send put to %p', event.peer.id);\n                for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {\n                    events.push(putEvent);\n                    if (putEvent.name !== 'PEER_RESPONSE') {\n                        continue;\n                    }\n                    if (!(putEvent.record != null && uint8ArrayEquals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {\n                        events.push(queryErrorEvent({ from: event.peer.id, error: new CodeError('value not put correctly', 'ERR_PUT_VALUE_INVALID') }, options));\n                    }\n                }\n                return events;\n            };\n        }), (source) => parallel(source, {\n            ordered: false,\n            concurrency: ALPHA\n        }), async function* (source) {\n            for await (const events of source) {\n                yield* events;\n            }\n        });\n    }\n    /**\n     * Get the value to the given key\n     */\n    async *get(key, options = {}) {\n        this.log('get %b', key);\n        const vals = [];\n        for await (const event of this.getMany(key, options)) {\n            if (event.name === 'VALUE') {\n                vals.push(event);\n            }\n            yield event;\n        }\n        if (vals.length === 0) {\n            return;\n        }\n        const records = vals.map((v) => v.value);\n        let i = 0;\n        try {\n            i = bestRecord(this.selectors, key, records);\n        }\n        catch (err) {\n            // Assume the first record if no selector available\n            if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n                throw err;\n            }\n        }\n        const best = records[i];\n        this.log('GetValue %b %b', key, best);\n        if (best == null) {\n            throw new CodeError('best value was not found', 'ERR_NOT_FOUND');\n        }\n        yield* this.sendCorrectionRecord(key, vals, best, options);\n        yield vals[i];\n    }\n    /**\n     * Get the `n` values to the given key without sorting\n     */\n    async *getMany(key, options = {}) {\n        this.log('getMany values for %b', key);\n        try {\n            const localRec = await this.getLocal(key);\n            yield valueEvent({\n                value: localRec.value,\n                from: this.components.peerId\n            }, options);\n        }\n        catch (err) {\n            this.log('error getting local value for %b', key, err);\n        }\n        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        const getValueQuery = async function* ({ peer, signal }) {\n            for await (const event of self.peerRouting.getValueOrPeers(peer, key, { signal })) {\n                yield event;\n                if (event.name === 'PEER_RESPONSE' && (event.record != null)) {\n                    yield valueEvent({ from: peer, value: event.record.value }, options);\n                }\n            }\n        };\n        // we have peers, lets send the actual query to them\n        yield* this.queryManager.run(key, getValueQuery, options);\n    }\n}\n//# sourceMappingURL=index.js.map","import { PeerSet } from '@libp2p/peer-collections';\nimport map from 'it-map';\nimport parallel from 'it-parallel';\nimport { pipe } from 'it-pipe';\nimport { ALPHA } from '../constants.js';\nimport { MessageType } from '../message/dht.js';\nimport { toPbPeerInfo } from '../message/utils.js';\nimport { queryErrorEvent, peerResponseEvent, providerEvent } from '../query/events.js';\nexport class ContentRouting {\n    log;\n    components;\n    network;\n    peerRouting;\n    queryManager;\n    routingTable;\n    providers;\n    constructor(components, init) {\n        const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;\n        this.components = components;\n        this.log = components.logger.forComponent(`${logPrefix}:content-routing`);\n        this.network = network;\n        this.peerRouting = peerRouting;\n        this.queryManager = queryManager;\n        this.routingTable = routingTable;\n        this.providers = providers;\n    }\n    /**\n     * Announce to the network that we can provide the value for a given key and\n     * are contactable on the given multiaddrs\n     */\n    async *provide(key, multiaddrs, options = {}) {\n        this.log('provide %s', key);\n        const target = key.multihash.bytes;\n        // Add peer as provider\n        await this.providers.addProvider(key, this.components.peerId);\n        const msg = {\n            type: MessageType.ADD_PROVIDER,\n            key: target,\n            providers: [\n                toPbPeerInfo({\n                    id: this.components.peerId,\n                    multiaddrs\n                })\n            ]\n        };\n        let sent = 0;\n        const maybeNotifyPeer = (event) => {\n            return async () => {\n                if (event.name !== 'FINAL_PEER') {\n                    return [event];\n                }\n                const events = [];\n                this.log('putProvider %s to %p', key, event.peer.id);\n                try {\n                    this.log('sending provider record for %s to %p', key, event.peer.id);\n                    for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {\n                        if (sendEvent.name === 'PEER_RESPONSE') {\n                            this.log('sent provider record for %s to %p', key, event.peer.id);\n                            sent++;\n                        }\n                        events.push(sendEvent);\n                    }\n                }\n                catch (err) {\n                    this.log.error('error sending provide record to peer %p', event.peer.id, err);\n                    events.push(queryErrorEvent({ from: event.peer.id, error: err }, options));\n                }\n                return events;\n            };\n        };\n        // Notify closest peers\n        yield* pipe(this.peerRouting.getClosestPeers(target, options), (source) => map(source, (event) => maybeNotifyPeer(event)), (source) => parallel(source, {\n            ordered: false,\n            concurrency: ALPHA\n        }), async function* (source) {\n            for await (const events of source) {\n                yield* events;\n            }\n        });\n        this.log('sent provider records to %d peers', sent);\n    }\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     */\n    async *findProviders(key, options) {\n        const toFind = this.routingTable.kBucketSize;\n        let found = 0;\n        const target = key.multihash.bytes;\n        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        this.log('findProviders %c', key);\n        const provs = await this.providers.getProviders(key);\n        // yield values if we have some, also slice because maybe we got lucky and already have too many?\n        if (provs.length > 0) {\n            const providers = [];\n            for (const peerId of provs.slice(0, toFind)) {\n                try {\n                    const peer = await this.components.peerStore.get(peerId);\n                    providers.push({\n                        id: peerId,\n                        multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr)\n                    });\n                }\n                catch (err) {\n                    if (err.code !== 'ERR_NOT_FOUND') {\n                        throw err;\n                    }\n                    this.log('no peer store entry for %p', peerId);\n                }\n            }\n            yield peerResponseEvent({ from: this.components.peerId, messageType: MessageType.GET_PROVIDERS, providers }, options);\n            yield providerEvent({ from: this.components.peerId, providers }, options);\n            found += providers.length;\n            if (found >= toFind) {\n                return;\n            }\n        }\n        /**\n         * The query function to use on this particular disjoint path\n         */\n        const findProvidersQuery = async function* ({ peer, signal }) {\n            const request = {\n                type: MessageType.GET_PROVIDERS,\n                key: target\n            };\n            yield* self.network.sendRequest(peer, request, {\n                ...options,\n                signal\n            });\n        };\n        const providers = new PeerSet(provs);\n        for await (const event of this.queryManager.run(target, findProvidersQuery, options)) {\n            yield event;\n            if (event.name === 'PEER_RESPONSE') {\n                this.log('Found %d provider entries for %c and %d closer peers', event.providers.length, key, event.closer.length);\n                const newProviders = [];\n                for (const peer of event.providers) {\n                    if (providers.has(peer.id)) {\n                        continue;\n                    }\n                    providers.add(peer.id);\n                    newProviders.push(peer);\n                }\n                if (newProviders.length > 0) {\n                    yield providerEvent({ from: event.from, providers: newProviders }, options);\n                    found += newProviders.length;\n                    if (found >= toFind) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module implements the [libp2p Kademlia spec](https://github.com/libp2p/specs/blob/master/kad-dht/README.md) in TypeScript.\n *\n * The Kademlia DHT allow for several operations such as finding peers, searching for providers of DHT records, etc.\n *\n * @example Using with libp2p\n *\n * ```TypeScript\n * import { kadDHT } from '@libp2p/kad-dht'\n * import { createLibp2p } from 'libp2p'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const node = await createLibp2p({\n *   services: {\n *     dht: kadDHT({\n *       // DHT options\n *     })\n *   }\n * })\n *\n * const peerId = peerIdFromString('QmFoo')\n * const peerInfo = await node.peerRouting.findPeer(peerId)\n *\n * console.info(peerInfo) // peer id, multiaddrs\n * ```\n *\n * @example Connecting to the IPFS Amino DHT\n *\n * The [Amino DHT](https://blog.ipfs.tech/2023-09-amino-refactoring/) is a public-good DHT used by IPFS to fetch content, find peers, etc.\n *\n * If you are trying to access content on the public internet, this is the implementation you want.\n *\n * ```TypeScript\n * import { kadDHT, removePrivateAddressesMapper } from '@libp2p/kad-dht'\n * import { createLibp2p } from 'libp2p'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const node = await createLibp2p({\n *   services: {\n *     aminoDHT: kadDHT({\n *       protocol: '/ipfs/kad/1.0.0',\n *       peerInfoMapper: removePrivateAddressesMapper\n *     })\n *   }\n * })\n *\n * const peerId = peerIdFromString('QmFoo')\n * const peerInfo = await node.peerRouting.findPeer(peerId)\n *\n * console.info(peerInfo) // peer id, multiaddrs\n * ```\n *\n * @example Connecting to a LAN-only DHT\n *\n * This DHT only works with privately dialable peers.\n *\n * This is for use when peers are on the local area network.\n *\n * ```TypeScript\n * import { kadDHT, removePublicAddressesMapper } from '@libp2p/kad-dht'\n * import { createLibp2p } from 'libp2p'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const node = await createLibp2p({\n *   services: {\n *     lanDHT: kadDHT({\n *       protocol: '/ipfs/lan/kad/1.0.0',\n *       peerInfoMapper: removePublicAddressesMapper,\n *       clientMode: false\n *     })\n *   }\n * })\n *\n * const peerId = peerIdFromString('QmFoo')\n * const peerInfo = await node.peerRouting.findPeer(peerId)\n *\n * console.info(peerInfo) // peer id, multiaddrs\n * ```\n */\nimport { KadDHT as KadDHTClass } from './kad-dht.js';\nimport { MessageType } from './message/dht.js';\nimport { removePrivateAddressesMapper, removePublicAddressesMapper, passthroughMapper } from './utils.js';\nexport { Libp2pRecord as Record } from '@libp2p/record';\nexport { removePrivateAddressesMapper, removePublicAddressesMapper, passthroughMapper };\n/**\n * The types of events emitted during DHT queries\n */\nexport var EventTypes;\n(function (EventTypes) {\n    EventTypes[EventTypes[\"SEND_QUERY\"] = 0] = \"SEND_QUERY\";\n    EventTypes[EventTypes[\"PEER_RESPONSE\"] = 1] = \"PEER_RESPONSE\";\n    EventTypes[EventTypes[\"FINAL_PEER\"] = 2] = \"FINAL_PEER\";\n    EventTypes[EventTypes[\"QUERY_ERROR\"] = 3] = \"QUERY_ERROR\";\n    EventTypes[EventTypes[\"PROVIDER\"] = 4] = \"PROVIDER\";\n    EventTypes[EventTypes[\"VALUE\"] = 5] = \"VALUE\";\n    EventTypes[EventTypes[\"ADD_PEER\"] = 6] = \"ADD_PEER\";\n    EventTypes[EventTypes[\"DIAL_PEER\"] = 7] = \"DIAL_PEER\";\n})(EventTypes || (EventTypes = {}));\n/**\n * The types of messages sent to peers during DHT queries\n */\nexport { MessageType };\n/**\n * Creates a custom DHT implementation, please ensure you pass a `protocol`\n * string as an option.\n */\nexport function kadDHT(init = {}) {\n    return (components) => new KadDHTClass(components, init);\n}\n//# sourceMappingURL=index.js.map","import { CodeError, CustomEvent, TypedEventEmitter, contentRoutingSymbol, peerDiscoverySymbol, peerRoutingSymbol, serviceCapabilities, serviceDependencies, start, stop } from '@libp2p/interface';\nimport drain from 'it-drain';\nimport pDefer from 'p-defer';\nimport { PROTOCOL } from './constants.js';\nimport { ContentFetching } from './content-fetching/index.js';\nimport { ContentRouting as KADDHTContentRouting } from './content-routing/index.js';\nimport { Network } from './network.js';\nimport { PeerRouting as KADDHTPeerRouting } from './peer-routing/index.js';\nimport { Providers } from './providers.js';\nimport { QueryManager } from './query/manager.js';\nimport { QuerySelf } from './query-self.js';\nimport { selectors as recordSelectors } from './record/selectors.js';\nimport { validators as recordValidators } from './record/validators.js';\nimport { RoutingTable } from './routing-table/index.js';\nimport { RoutingTableRefresh } from './routing-table/refresh.js';\nimport { RPC } from './rpc/index.js';\nimport { TopologyListener } from './topology-listener.js';\nimport { multiaddrIsPublic, removePrivateAddressesMapper } from './utils.js';\n/**\n * Wrapper class to convert events into returned values\n */\nclass DHTContentRouting {\n    dht;\n    constructor(dht) {\n        this.dht = dht;\n    }\n    async provide(cid, options = {}) {\n        await drain(this.dht.provide(cid, options));\n    }\n    async *findProviders(cid, options = {}) {\n        for await (const event of this.dht.findProviders(cid, options)) {\n            if (event.name === 'PROVIDER') {\n                yield* event.providers;\n            }\n        }\n    }\n    async put(key, value, options) {\n        await drain(this.dht.put(key, value, options));\n    }\n    async get(key, options) {\n        for await (const event of this.dht.get(key, options)) {\n            if (event.name === 'VALUE') {\n                return event.value;\n            }\n        }\n        throw new CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n}\n/**\n * Wrapper class to convert events into returned values\n */\nclass DHTPeerRouting {\n    dht;\n    constructor(dht) {\n        this.dht = dht;\n    }\n    async findPeer(peerId, options = {}) {\n        for await (const event of this.dht.findPeer(peerId, options)) {\n            if (event.name === 'FINAL_PEER') {\n                return event.peer;\n            }\n        }\n        throw new CodeError('Not found', 'ERR_NOT_FOUND');\n    }\n    async *getClosestPeers(key, options = {}) {\n        for await (const event of this.dht.getClosestPeers(key, options)) {\n            if (event.name === 'FINAL_PEER') {\n                yield event.peer;\n            }\n        }\n    }\n}\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32;\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * A DHT implementation modelled after Kademlia with S/Kademlia modifications.\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nexport class KadDHT extends TypedEventEmitter {\n    protocol;\n    routingTable;\n    providers;\n    network;\n    peerRouting;\n    components;\n    log;\n    running;\n    kBucketSize;\n    clientMode;\n    validators;\n    selectors;\n    queryManager;\n    contentFetching;\n    contentRouting;\n    routingTableRefresh;\n    rpc;\n    topologyListener;\n    querySelf;\n    maxInboundStreams;\n    maxOutboundStreams;\n    dhtContentRouting;\n    dhtPeerRouting;\n    peerInfoMapper;\n    /**\n     * Create a new KadDHT\n     */\n    constructor(components, init = {}) {\n        super();\n        const { kBucketSize, clientMode, validators, selectors, querySelfInterval, protocol, logPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams, providers: providersInit } = init;\n        const loggingPrefix = logPrefix ?? 'libp2p:kad-dht';\n        this.running = false;\n        this.components = components;\n        this.log = components.logger.forComponent(loggingPrefix);\n        this.protocol = protocol ?? PROTOCOL;\n        this.kBucketSize = kBucketSize ?? 20;\n        this.clientMode = clientMode ?? true;\n        this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;\n        this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n        this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;\n        this.routingTable = new RoutingTable(components, {\n            kBucketSize,\n            pingTimeout,\n            pingConcurrency,\n            protocol: this.protocol,\n            logPrefix: loggingPrefix\n        });\n        this.providers = new Providers(components, providersInit ?? {});\n        this.validators = {\n            ...recordValidators,\n            ...validators\n        };\n        this.selectors = {\n            ...recordSelectors,\n            ...selectors\n        };\n        this.network = new Network(components, {\n            protocol: this.protocol,\n            logPrefix: loggingPrefix\n        });\n        // all queries should wait for the initial query-self query to run so we have\n        // some peers and don't force consumers to use arbitrary timeouts\n        const initialQuerySelfHasRun = pDefer();\n        // if the user doesn't want to wait for query peers, resolve the initial\n        // self-query promise immediately\n        if (init.allowQueryWithZeroPeers === true) {\n            initialQuerySelfHasRun.resolve();\n        }\n        this.queryManager = new QueryManager(components, {\n            // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper\n            disjointPaths: Math.ceil(this.kBucketSize / 2),\n            logPrefix: loggingPrefix,\n            initialQuerySelfHasRun,\n            routingTable: this.routingTable\n        });\n        // DHT components\n        this.peerRouting = new KADDHTPeerRouting(components, {\n            routingTable: this.routingTable,\n            network: this.network,\n            validators: this.validators,\n            queryManager: this.queryManager,\n            logPrefix: loggingPrefix\n        });\n        this.contentFetching = new ContentFetching(components, {\n            validators: this.validators,\n            selectors: this.selectors,\n            peerRouting: this.peerRouting,\n            queryManager: this.queryManager,\n            network: this.network,\n            logPrefix: loggingPrefix\n        });\n        this.contentRouting = new KADDHTContentRouting(components, {\n            network: this.network,\n            peerRouting: this.peerRouting,\n            queryManager: this.queryManager,\n            routingTable: this.routingTable,\n            providers: this.providers,\n            logPrefix: loggingPrefix\n        });\n        this.routingTableRefresh = new RoutingTableRefresh(components, {\n            peerRouting: this.peerRouting,\n            routingTable: this.routingTable,\n            logPrefix: loggingPrefix\n        });\n        this.rpc = new RPC(components, {\n            routingTable: this.routingTable,\n            providers: this.providers,\n            peerRouting: this.peerRouting,\n            validators: this.validators,\n            logPrefix: loggingPrefix,\n            peerInfoMapper: this.peerInfoMapper\n        });\n        this.topologyListener = new TopologyListener(components, {\n            protocol: this.protocol,\n            logPrefix: loggingPrefix\n        });\n        this.querySelf = new QuerySelf(components, {\n            peerRouting: this.peerRouting,\n            interval: querySelfInterval,\n            initialInterval: init.initialQuerySelfInterval,\n            logPrefix: loggingPrefix,\n            initialQuerySelfHasRun,\n            routingTable: this.routingTable\n        });\n        // handle peers being discovered during processing of DHT messages\n        this.network.addEventListener('peer', (evt) => {\n            const peerData = evt.detail;\n            this.onPeerConnect(peerData).catch(err => {\n                this.log.error('could not add %p to routing table', peerData.id, err);\n            });\n            this.dispatchEvent(new CustomEvent('peer', {\n                detail: peerData\n            }));\n        });\n        // handle peers being discovered via other peer discovery mechanisms\n        this.topologyListener.addEventListener('peer', (evt) => {\n            const peerId = evt.detail;\n            Promise.resolve().then(async () => {\n                const peer = await this.components.peerStore.get(peerId);\n                const peerData = {\n                    id: peerId,\n                    multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr),\n                    protocols: peer.protocols\n                };\n                await this.onPeerConnect(peerData);\n            }).catch(err => {\n                this.log.error('could not add %p to routing table', peerId, err);\n            });\n        });\n        this.dhtPeerRouting = new DHTPeerRouting(this);\n        this.dhtContentRouting = new DHTContentRouting(this);\n        // if client mode has not been explicitly specified, auto-switch to server\n        // mode when the node's peer data is updated with publicly dialable\n        // addresses\n        if (init.clientMode == null) {\n            components.events.addEventListener('self:peer:update', (evt) => {\n                this.log('received update of self-peer info');\n                void Promise.resolve().then(async () => {\n                    const hasPublicAddress = evt.detail.peer.addresses\n                        .some(({ multiaddr }) => multiaddrIsPublic(multiaddr));\n                    const mode = this.getMode();\n                    if (hasPublicAddress && mode === 'client') {\n                        await this.setMode('server');\n                    }\n                    else if (mode === 'server' && !hasPublicAddress) {\n                        await this.setMode('client');\n                    }\n                })\n                    .catch(err => {\n                    this.log.error('error setting dht server mode', err);\n                });\n            });\n        }\n    }\n    [Symbol.toStringTag] = '@libp2p/kad-dht';\n    [serviceCapabilities] = [\n        '@libp2p/content-routing',\n        '@libp2p/peer-routing',\n        '@libp2p/peer-discovery'\n    ];\n    [serviceDependencies] = [\n        '@libp2p/identify'\n    ];\n    get [contentRoutingSymbol]() {\n        return this.dhtContentRouting;\n    }\n    get [peerRoutingSymbol]() {\n        return this.dhtPeerRouting;\n    }\n    get [peerDiscoverySymbol]() {\n        return this;\n    }\n    async onPeerConnect(peerData) {\n        this.log('peer %p connected', peerData.id);\n        peerData = this.peerInfoMapper(peerData);\n        if (peerData.multiaddrs.length === 0) {\n            this.log('ignoring %p as there were no valid addresses in %s after filtering', peerData.id, peerData.multiaddrs.map(addr => addr.toString()));\n            return;\n        }\n        try {\n            await this.routingTable.add(peerData.id);\n        }\n        catch (err) {\n            this.log.error('could not add %p to routing table', peerData.id, err);\n        }\n    }\n    /**\n     * Is this DHT running.\n     */\n    isStarted() {\n        return this.running;\n    }\n    /**\n     * If 'server' this node will respond to DHT queries, if 'client' this node will not\n     */\n    getMode() {\n        return this.clientMode ? 'client' : 'server';\n    }\n    /**\n     * If 'server' this node will respond to DHT queries, if 'client' this node will not\n     */\n    async setMode(mode) {\n        await this.components.registrar.unhandle(this.protocol);\n        if (mode === 'client') {\n            this.log('enabling client mode');\n            this.clientMode = true;\n        }\n        else {\n            this.log('enabling server mode');\n            this.clientMode = false;\n            await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {\n                maxInboundStreams: this.maxInboundStreams,\n                maxOutboundStreams: this.maxOutboundStreams\n            });\n        }\n    }\n    /**\n     * Start listening to incoming connections.\n     */\n    async start() {\n        this.running = true;\n        // Only respond to queries when not in client mode\n        await this.setMode(this.clientMode ? 'client' : 'server');\n        await start(this.querySelf, this.providers, this.queryManager, this.network, this.routingTable, this.topologyListener, this.routingTableRefresh);\n    }\n    /**\n     * Stop accepting incoming connections and sending outgoing\n     * messages.\n     */\n    async stop() {\n        this.running = false;\n        await stop(this.querySelf, this.providers, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener);\n    }\n    /**\n     * Store the given key/value pair in the DHT\n     */\n    async *put(key, value, options = {}) {\n        yield* this.contentFetching.put(key, value, options);\n    }\n    /**\n     * Get the value that corresponds to the passed key\n     */\n    async *get(key, options = {}) {\n        yield* this.contentFetching.get(key, options);\n    }\n    // ----------- Content Routing\n    /**\n     * Announce to the network that we can provide given key's value\n     */\n    async *provide(key, options = {}) {\n        yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options);\n    }\n    /**\n     * Search the dht for providers of the given CID\n     */\n    async *findProviders(key, options = {}) {\n        yield* this.contentRouting.findProviders(key, options);\n    }\n    // ----------- Peer Routing -----------\n    /**\n     * Search for a peer with the given ID\n     */\n    async *findPeer(id, options = {}) {\n        yield* this.peerRouting.findPeer(id, options);\n    }\n    /**\n     * Kademlia 'node lookup' operation\n     */\n    async *getClosestPeers(key, options = {}) {\n        yield* this.peerRouting.getClosestPeers(key, options);\n    }\n    async refreshRoutingTable() {\n        this.routingTableRefresh.refreshTable(true);\n    }\n}\n//# sourceMappingURL=kad-dht.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { decodeMessage, encodeMessage, enumeration, message } from 'protons-runtime';\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nexport var Record;\n(function (Record) {\n    let _codec;\n    Record.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.key != null) {\n                    w.uint32(10);\n                    w.bytes(obj.key);\n                }\n                if (obj.value != null) {\n                    w.uint32(18);\n                    w.bytes(obj.value);\n                }\n                if (obj.author != null) {\n                    w.uint32(26);\n                    w.bytes(obj.author);\n                }\n                if (obj.signature != null) {\n                    w.uint32(34);\n                    w.bytes(obj.signature);\n                }\n                if (obj.timeReceived != null) {\n                    w.uint32(42);\n                    w.string(obj.timeReceived);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.key = reader.bytes();\n                            break;\n                        }\n                        case 2: {\n                            obj.value = reader.bytes();\n                            break;\n                        }\n                        case 3: {\n                            obj.author = reader.bytes();\n                            break;\n                        }\n                        case 4: {\n                            obj.signature = reader.bytes();\n                            break;\n                        }\n                        case 5: {\n                            obj.timeReceived = reader.string();\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Record.encode = (obj) => {\n        return encodeMessage(obj, Record.codec());\n    };\n    Record.decode = (buf) => {\n        return decodeMessage(buf, Record.codec());\n    };\n})(Record || (Record = {}));\nexport var MessageType;\n(function (MessageType) {\n    MessageType[\"PUT_VALUE\"] = \"PUT_VALUE\";\n    MessageType[\"GET_VALUE\"] = \"GET_VALUE\";\n    MessageType[\"ADD_PROVIDER\"] = \"ADD_PROVIDER\";\n    MessageType[\"GET_PROVIDERS\"] = \"GET_PROVIDERS\";\n    MessageType[\"FIND_NODE\"] = \"FIND_NODE\";\n    MessageType[\"PING\"] = \"PING\";\n})(MessageType || (MessageType = {}));\nvar __MessageTypeValues;\n(function (__MessageTypeValues) {\n    __MessageTypeValues[__MessageTypeValues[\"PUT_VALUE\"] = 0] = \"PUT_VALUE\";\n    __MessageTypeValues[__MessageTypeValues[\"GET_VALUE\"] = 1] = \"GET_VALUE\";\n    __MessageTypeValues[__MessageTypeValues[\"ADD_PROVIDER\"] = 2] = \"ADD_PROVIDER\";\n    __MessageTypeValues[__MessageTypeValues[\"GET_PROVIDERS\"] = 3] = \"GET_PROVIDERS\";\n    __MessageTypeValues[__MessageTypeValues[\"FIND_NODE\"] = 4] = \"FIND_NODE\";\n    __MessageTypeValues[__MessageTypeValues[\"PING\"] = 5] = \"PING\";\n})(__MessageTypeValues || (__MessageTypeValues = {}));\n(function (MessageType) {\n    MessageType.codec = () => {\n        return enumeration(__MessageTypeValues);\n    };\n})(MessageType || (MessageType = {}));\nexport var ConnectionType;\n(function (ConnectionType) {\n    ConnectionType[\"NOT_CONNECTED\"] = \"NOT_CONNECTED\";\n    ConnectionType[\"CONNECTED\"] = \"CONNECTED\";\n    ConnectionType[\"CAN_CONNECT\"] = \"CAN_CONNECT\";\n    ConnectionType[\"CANNOT_CONNECT\"] = \"CANNOT_CONNECT\";\n})(ConnectionType || (ConnectionType = {}));\nvar __ConnectionTypeValues;\n(function (__ConnectionTypeValues) {\n    __ConnectionTypeValues[__ConnectionTypeValues[\"NOT_CONNECTED\"] = 0] = \"NOT_CONNECTED\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CAN_CONNECT\"] = 2] = \"CAN_CONNECT\";\n    __ConnectionTypeValues[__ConnectionTypeValues[\"CANNOT_CONNECT\"] = 3] = \"CANNOT_CONNECT\";\n})(__ConnectionTypeValues || (__ConnectionTypeValues = {}));\n(function (ConnectionType) {\n    ConnectionType.codec = () => {\n        return enumeration(__ConnectionTypeValues);\n    };\n})(ConnectionType || (ConnectionType = {}));\nexport var PeerInfo;\n(function (PeerInfo) {\n    let _codec;\n    PeerInfo.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.id != null && obj.id.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.id);\n                }\n                if (obj.multiaddrs != null) {\n                    for (const value of obj.multiaddrs) {\n                        w.uint32(18);\n                        w.bytes(value);\n                    }\n                }\n                if (obj.connection != null) {\n                    w.uint32(24);\n                    ConnectionType.codec().encode(obj.connection, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    id: uint8ArrayAlloc(0),\n                    multiaddrs: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.id = reader.bytes();\n                            break;\n                        }\n                        case 2: {\n                            obj.multiaddrs.push(reader.bytes());\n                            break;\n                        }\n                        case 3: {\n                            obj.connection = ConnectionType.codec().decode(reader);\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PeerInfo.encode = (obj) => {\n        return encodeMessage(obj, PeerInfo.codec());\n    };\n    PeerInfo.decode = (buf) => {\n        return decodeMessage(buf, PeerInfo.codec());\n    };\n})(PeerInfo || (PeerInfo = {}));\nexport var Message;\n(function (Message) {\n    let _codec;\n    Message.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {\n                    w.uint32(8);\n                    MessageType.codec().encode(obj.type, w);\n                }\n                if (obj.clusterLevel != null) {\n                    w.uint32(80);\n                    w.int32(obj.clusterLevel);\n                }\n                if (obj.key != null) {\n                    w.uint32(18);\n                    w.bytes(obj.key);\n                }\n                if (obj.record != null) {\n                    w.uint32(26);\n                    w.bytes(obj.record);\n                }\n                if (obj.closer != null) {\n                    for (const value of obj.closer) {\n                        w.uint32(66);\n                        PeerInfo.codec().encode(value, w);\n                    }\n                }\n                if (obj.providers != null) {\n                    for (const value of obj.providers) {\n                        w.uint32(74);\n                        PeerInfo.codec().encode(value, w);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    type: MessageType.PUT_VALUE,\n                    closer: [],\n                    providers: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.type = MessageType.codec().decode(reader);\n                            break;\n                        }\n                        case 10: {\n                            obj.clusterLevel = reader.int32();\n                            break;\n                        }\n                        case 2: {\n                            obj.key = reader.bytes();\n                            break;\n                        }\n                        case 3: {\n                            obj.record = reader.bytes();\n                            break;\n                        }\n                        case 8: {\n                            obj.closer.push(PeerInfo.codec().decode(reader, reader.uint32()));\n                            break;\n                        }\n                        case 9: {\n                            obj.providers.push(PeerInfo.codec().decode(reader, reader.uint32()));\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Message.encode = (obj) => {\n        return encodeMessage(obj, Message.codec());\n    };\n    Message.decode = (buf) => {\n        return decodeMessage(buf, Message.codec());\n    };\n})(Message || (Message = {}));\n//# sourceMappingURL=dht.js.map","import { peerIdFromBytes } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nexport function toPbPeerInfo(peer, connection) {\n    const output = {\n        id: peer.id.toBytes(),\n        multiaddrs: (peer.multiaddrs ?? []).map((m) => m.bytes),\n        connection\n    };\n    return output;\n}\nexport function fromPbPeerInfo(peer) {\n    if (peer.id == null) {\n        throw new Error('Invalid peer in message');\n    }\n    return {\n        id: peerIdFromBytes(peer.id),\n        multiaddrs: (peer.multiaddrs ?? []).map((a) => multiaddr(a))\n    };\n}\n//# sourceMappingURL=utils.js.map","import { TypedEventEmitter } from '@libp2p/interface';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { AdaptiveTimeout } from '@libp2p/utils/adaptive-timeout';\nimport { pbStream } from 'it-protobuf-stream';\nimport { CodeError } from 'protons-runtime';\nimport { Message } from './message/dht.js';\nimport { fromPbPeerInfo } from './message/utils.js';\nimport { dialPeerEvent, sendQueryEvent, peerResponseEvent, queryErrorEvent } from './query/events.js';\n/**\n * Handle network operations for the dht\n */\nexport class Network extends TypedEventEmitter {\n    log;\n    protocol;\n    running;\n    components;\n    timeout;\n    /**\n     * Create a new network\n     */\n    constructor(components, init) {\n        super();\n        const { protocol } = init;\n        this.components = components;\n        this.log = components.logger.forComponent(`${init.logPrefix}:network`);\n        this.running = false;\n        this.protocol = protocol;\n        this.timeout = new AdaptiveTimeout({\n            ...(init.timeout ?? {}),\n            metrics: components.metrics,\n            metricName: `${init.logPrefix.replaceAll(':', '_')}_network_message_send_times_milliseconds`\n        });\n    }\n    /**\n     * Start the network\n     */\n    async start() {\n        if (this.running) {\n            return;\n        }\n        this.running = true;\n    }\n    /**\n     * Stop all network activity\n     */\n    async stop() {\n        this.running = false;\n    }\n    /**\n     * Is the network online?\n     */\n    isStarted() {\n        return this.running;\n    }\n    /**\n     * Send a request and record RTT for latency measurements\n     */\n    async *sendRequest(to, msg, options = {}) {\n        if (!this.running) {\n            return;\n        }\n        const type = msg.type;\n        if (type == null) {\n            throw new CodeError('Message type was missing', 'ERR_INVALID_PARAMETERS');\n        }\n        this.log('sending %s to %p', msg.type, to);\n        yield dialPeerEvent({ peer: to }, options);\n        yield sendQueryEvent({ to, type }, options);\n        let stream;\n        const signal = this.timeout.getTimeoutSignal(options);\n        options = {\n            ...options,\n            signal\n        };\n        try {\n            const connection = await this.components.connectionManager.openConnection(to, options);\n            stream = await connection.newStream(this.protocol, options);\n            const response = await this._writeReadMessage(stream, msg, options);\n            stream.close(options)\n                .catch(err => {\n                this.log.error('error closing stream to %p', to, err);\n                stream?.abort(err);\n            });\n            yield peerResponseEvent({\n                from: to,\n                messageType: response.type,\n                closer: response.closer.map(fromPbPeerInfo),\n                providers: response.providers.map(fromPbPeerInfo),\n                record: response.record == null ? undefined : Libp2pRecord.deserialize(response.record)\n            }, options);\n        }\n        catch (err) {\n            stream?.abort(err);\n            this.log.error('could not send %s to %p', msg.type, to, err);\n            yield queryErrorEvent({ from: to, error: err }, options);\n        }\n        finally {\n            this.timeout.cleanUp(signal);\n        }\n    }\n    /**\n     * Sends a message without expecting an answer\n     */\n    async *sendMessage(to, msg, options = {}) {\n        if (!this.running) {\n            return;\n        }\n        const type = msg.type;\n        if (type == null) {\n            throw new CodeError('Message type was missing', 'ERR_INVALID_PARAMETERS');\n        }\n        this.log('sending %s to %p', msg.type, to);\n        yield dialPeerEvent({ peer: to }, options);\n        yield sendQueryEvent({ to, type }, options);\n        let stream;\n        const signal = this.timeout.getTimeoutSignal(options);\n        options = {\n            ...options,\n            signal\n        };\n        try {\n            const connection = await this.components.connectionManager.openConnection(to, options);\n            stream = await connection.newStream(this.protocol, options);\n            await this._writeMessage(stream, msg, options);\n            stream.close(options)\n                .catch(err => {\n                this.log.error('error closing stream to %p', to, err);\n                stream?.abort(err);\n            });\n            yield peerResponseEvent({ from: to, messageType: type }, options);\n        }\n        catch (err) {\n            stream?.abort(err);\n            yield queryErrorEvent({ from: to, error: err }, options);\n        }\n        finally {\n            this.timeout.cleanUp(signal);\n        }\n    }\n    /**\n     * Write a message to the given stream\n     */\n    async _writeMessage(stream, msg, options) {\n        const pb = pbStream(stream);\n        await pb.write(msg, Message, options);\n        await pb.unwrap().close(options);\n    }\n    /**\n     * Write a message and read its response.\n     * If no response is received after the specified timeout\n     * this will error out.\n     */\n    async _writeReadMessage(stream, msg, options) {\n        const pb = pbStream(stream);\n        await pb.write(msg, Message, options);\n        const message = await pb.read(Message, options);\n        await pb.unwrap().close(options);\n        // tell any listeners about new peers we've seen\n        message.closer.forEach(peerData => {\n            this.safeDispatchEvent('peer', {\n                detail: fromPbPeerInfo(peerData)\n            });\n        });\n        message.providers.forEach(peerData => {\n            this.safeDispatchEvent('peer', {\n                detail: fromPbPeerInfo(peerData)\n            });\n        });\n        return message;\n    }\n}\n//# sourceMappingURL=network.js.map","import { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport { xorCompare as uint8ArrayXorCompare } from 'uint8arrays/xor-compare';\nimport { convertPeerId } from '../utils.js';\n/**\n * Maintains a list of peerIds sorted by distance from a DHT key.\n */\nexport class PeerDistanceList {\n    /**\n     * The DHT key from which distance is calculated\n     */\n    originDhtKey;\n    /**\n     * The maximum size of the list\n     */\n    capacity;\n    peerDistances;\n    constructor(originDhtKey, capacity) {\n        this.originDhtKey = originDhtKey;\n        this.capacity = capacity;\n        this.peerDistances = [];\n    }\n    /**\n     * The length of the list\n     */\n    get length() {\n        return this.peerDistances.length;\n    }\n    /**\n     * The peers in the list, in order of distance from the origin key\n     */\n    get peers() {\n        return this.peerDistances.map(pd => pd.peer);\n    }\n    /**\n     * Add a peerId to the list.\n     */\n    async add(peer) {\n        const dhtKey = await convertPeerId(peer.id);\n        this.addWitKadId(peer, dhtKey);\n    }\n    /**\n     * Add a peerId to the list.\n     */\n    addWitKadId(peer, kadId) {\n        if (this.peerDistances.find(pd => pd.peer.id.equals(peer.id)) != null) {\n            return;\n        }\n        const el = {\n            peer,\n            distance: uint8ArrayXor(this.originDhtKey, kadId)\n        };\n        this.peerDistances.push(el);\n        this.peerDistances.sort((a, b) => uint8ArrayXorCompare(a.distance, b.distance));\n        this.peerDistances = this.peerDistances.slice(0, this.capacity);\n    }\n    /**\n     * Indicates whether any of the peerIds passed as a parameter are closer\n     * to the origin key than the furthest peerId in the PeerDistanceList.\n     */\n    async isCloser(peerId) {\n        if (this.length === 0) {\n            return true;\n        }\n        const dhtKey = await convertPeerId(peerId);\n        const dhtKeyXor = uint8ArrayXor(dhtKey, this.originDhtKey);\n        const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;\n        return uint8ArrayXorCompare(dhtKeyXor, furthestDistance) === -1;\n    }\n    /**\n     * Indicates whether any of the peerIds passed as a parameter are closer\n     * to the origin key than the furthest peerId in the PeerDistanceList.\n     */\n    async anyCloser(peerIds) {\n        if (peerIds.length === 0) {\n            return false;\n        }\n        return Promise.any(peerIds.map(async (peerId) => this.isCloser(peerId)));\n    }\n}\n//# sourceMappingURL=peer-distance-list.js.map","import { keys } from '@libp2p/crypto';\nimport { CodeError } from '@libp2p/interface';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { MessageType } from '../message/dht.js';\nimport { PeerDistanceList } from '../peer-list/peer-distance-list.js';\nimport { queryErrorEvent, finalPeerEvent, valueEvent } from '../query/events.js';\nimport { verifyRecord } from '../record/validators.js';\nimport * as utils from '../utils.js';\nexport class PeerRouting {\n    log;\n    routingTable;\n    network;\n    validators;\n    queryManager;\n    peerStore;\n    peerId;\n    constructor(components, init) {\n        const { routingTable, network, validators, queryManager, logPrefix } = init;\n        this.routingTable = routingTable;\n        this.network = network;\n        this.validators = validators;\n        this.queryManager = queryManager;\n        this.peerStore = components.peerStore;\n        this.peerId = components.peerId;\n        this.log = components.logger.forComponent(`${logPrefix}:peer-routing`);\n    }\n    /**\n     * Look if we are connected to a peer with the given id.\n     * Returns its id and addresses, if found, otherwise `undefined`.\n     */\n    async findPeerLocal(peer) {\n        let peerData;\n        const p = await this.routingTable.find(peer);\n        if (p != null) {\n            this.log('findPeerLocal found %p in routing table', peer);\n            try {\n                peerData = await this.peerStore.get(p);\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n        }\n        if (peerData == null) {\n            try {\n                peerData = await this.peerStore.get(peer);\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n        }\n        if (peerData != null) {\n            this.log('findPeerLocal found %p in peer store', peer);\n            return {\n                id: peerData.id,\n                multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n            };\n        }\n        return undefined;\n    }\n    /**\n     * Get a value via rpc call for the given parameters\n     */\n    async *_getValueSingle(peer, key, options = {}) {\n        const msg = {\n            type: MessageType.GET_VALUE,\n            key\n        };\n        yield* this.network.sendRequest(peer, msg, options);\n    }\n    /**\n     * Get the public key directly from a node\n     */\n    async *getPublicKeyFromNode(peer, options = {}) {\n        const pkKey = utils.keyForPublicKey(peer);\n        for await (const event of this._getValueSingle(peer, pkKey, options)) {\n            yield event;\n            if (event.name === 'PEER_RESPONSE' && event.record != null) {\n                const recPeer = await peerIdFromKeys(keys.marshalPublicKey({ bytes: event.record.value }));\n                // compare hashes of the pub key\n                if (!recPeer.equals(peer)) {\n                    throw new CodeError('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n                }\n                if (recPeer.publicKey == null) {\n                    throw new CodeError('public key missing', 'ERR_PUBLIC_KEY_MISSING');\n                }\n                yield valueEvent({ from: peer, value: recPeer.publicKey }, options);\n            }\n        }\n        throw new CodeError(`Node not responding with its public key: ${peer.toString()}`, 'ERR_INVALID_RECORD');\n    }\n    /**\n     * Search for a peer with the given ID\n     */\n    async *findPeer(id, options = {}) {\n        this.log('findPeer %p', id);\n        if (options.useCache !== false) {\n            // Try to find locally\n            const pi = await this.findPeerLocal(id);\n            // already got it\n            if (pi != null) {\n                this.log('found local');\n                yield finalPeerEvent({\n                    from: this.peerId,\n                    peer: pi\n                }, options);\n                return;\n            }\n        }\n        let foundPeer = false;\n        if (options.useNetwork !== false) {\n            const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n            const findPeerQuery = async function* ({ peer, signal }) {\n                const request = {\n                    type: MessageType.FIND_NODE,\n                    key: id.toBytes()\n                };\n                for await (const event of self.network.sendRequest(peer, request, {\n                    ...options,\n                    signal\n                })) {\n                    yield event;\n                    if (event.name === 'PEER_RESPONSE') {\n                        const match = event.closer.find((p) => p.id.equals(id));\n                        // found the peer\n                        if (match != null) {\n                            yield finalPeerEvent({ from: event.from, peer: match }, options);\n                        }\n                    }\n                }\n            };\n            for await (const event of this.queryManager.run(id.toBytes(), findPeerQuery, options)) {\n                if (event.name === 'FINAL_PEER') {\n                    foundPeer = true;\n                }\n                yield event;\n            }\n        }\n        if (!foundPeer) {\n            yield queryErrorEvent({ from: this.peerId, error: new CodeError('Not found', 'ERR_NOT_FOUND') }, options);\n        }\n    }\n    /**\n     * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from\n     * a multihash or a peer ID\n     */\n    async *getClosestPeers(key, options = {}) {\n        this.log('getClosestPeers to %b', key);\n        const kadId = await utils.convertBuffer(key);\n        const tablePeers = this.routingTable.closestPeers(kadId);\n        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);\n        await Promise.all(tablePeers.map(async (peer) => { await peers.add({ id: peer, multiaddrs: [] }); }));\n        const getCloserPeersQuery = async function* ({ peer, signal }) {\n            self.log('closerPeersSingle %s from %p', uint8ArrayToString(key, 'base32'), peer);\n            const request = {\n                type: MessageType.FIND_NODE,\n                key\n            };\n            yield* self.network.sendRequest(peer, request, {\n                ...options,\n                signal\n            });\n        };\n        for await (const event of this.queryManager.run(key, getCloserPeersQuery, options)) {\n            if (event.name === 'PEER_RESPONSE') {\n                await Promise.all(event.closer.map(async (peerData) => {\n                    await peers.add(peerData);\n                }));\n            }\n            yield event;\n        }\n        this.log('found %d peers close to %b', peers.length, key);\n        for (const peer of peers.peers) {\n            yield finalPeerEvent({\n                from: this.peerId,\n                peer\n            }, options);\n        }\n    }\n    /**\n     * Query a particular peer for the value for the given key.\n     * It will either return the value or a list of closer peers.\n     *\n     * Note: The peerStore is updated with new addresses found for the given peer.\n     */\n    async *getValueOrPeers(peer, key, options = {}) {\n        for await (const event of this._getValueSingle(peer, key, options)) {\n            if (event.name === 'PEER_RESPONSE') {\n                if (event.record != null) {\n                    // We have a record\n                    try {\n                        await this._verifyRecordOnline(event.record);\n                    }\n                    catch (err) {\n                        const errMsg = 'invalid record received, discarded';\n                        this.log(errMsg);\n                        yield queryErrorEvent({ from: event.from, error: new CodeError(errMsg, 'ERR_INVALID_RECORD') }, options);\n                        continue;\n                    }\n                }\n            }\n            yield event;\n        }\n    }\n    /**\n     * Verify a record, fetching missing public keys from the network.\n     * Throws an error if the record is invalid.\n     */\n    async _verifyRecordOnline(record) {\n        if (record.timeReceived == null) {\n            throw new CodeError('invalid record received', 'ERR_INVALID_RECORD');\n        }\n        await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));\n    }\n    /**\n     * Get the nearest peers to the given query, but if closer\n     * than self\n     */\n    async getCloserPeersOffline(key, closerThan) {\n        const id = await utils.convertBuffer(key);\n        const ids = this.routingTable.closestPeers(id);\n        const output = [];\n        for (const peerId of ids) {\n            if (peerId.equals(closerThan)) {\n                continue;\n            }\n            try {\n                const peer = await this.peerStore.get(peerId);\n                output.push({\n                    id: peerId,\n                    multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr)\n                });\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n        }\n        if (output.length > 0) {\n            this.log('getCloserPeersOffline found %d peer(s) closer to %b than %p', output.length, key, closerThan);\n        }\n        else {\n            this.log('getCloserPeersOffline could not find peer closer to %b than %p with %d peers in the routing table', key, closerThan, this.routingTable.size);\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=index.js.map","import { peerIdFromString } from '@libp2p/peer-id';\nimport cache from 'hashlru';\nimport { Key } from 'interface-datastore/key';\nimport Queue from 'p-queue';\nimport * as varint from 'uint8-varint';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { PROVIDERS_CLEANUP_INTERVAL, PROVIDERS_VALIDITY, PROVIDERS_LRU_CACHE_SIZE, PROVIDER_KEY_PREFIX } from './constants.js';\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nexport class Providers {\n    log;\n    datastore;\n    cache;\n    cleanupInterval;\n    provideValidity;\n    syncQueue;\n    started;\n    cleaner;\n    constructor(components, init = {}) {\n        const { cacheSize, cleanupInterval, provideValidity } = init;\n        this.log = components.logger.forComponent('libp2p:kad-dht:providers');\n        this.datastore = components.datastore;\n        this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;\n        this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;\n        this.cache = cache(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);\n        this.syncQueue = new Queue({ concurrency: 1 });\n        this.started = false;\n    }\n    isStarted() {\n        return this.started;\n    }\n    /**\n     * Start the provider cleanup service\n     */\n    async start() {\n        if (this.started) {\n            return;\n        }\n        this.started = true;\n        this.cleaner = setInterval(() => {\n            this._cleanup().catch(err => {\n                this.log.error(err);\n            });\n        }, this.cleanupInterval);\n    }\n    /**\n     * Release any resources.\n     */\n    async stop() {\n        this.started = false;\n        if (this.cleaner != null) {\n            clearInterval(this.cleaner);\n            this.cleaner = undefined;\n        }\n    }\n    /**\n     * Check all providers if they are still valid, and if not delete them\n     */\n    async _cleanup() {\n        await this.syncQueue.add(async () => {\n            const start = Date.now();\n            let count = 0;\n            let deleteCount = 0;\n            const deleted = new Map();\n            const batch = this.datastore.batch();\n            // Get all provider entries from the datastore\n            const query = this.datastore.query({ prefix: PROVIDER_KEY_PREFIX });\n            for await (const entry of query) {\n                try {\n                    // Add a delete to the batch for each expired entry\n                    const { cid, peerId } = parseProviderKey(entry.key);\n                    const time = readTime(entry.value).getTime();\n                    const now = Date.now();\n                    const delta = now - time;\n                    const expired = delta > this.provideValidity;\n                    this.log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n                    if (expired) {\n                        deleteCount++;\n                        batch.delete(entry.key);\n                        const peers = deleted.get(cid) ?? new Set();\n                        peers.add(peerId);\n                        deleted.set(cid, peers);\n                    }\n                    count++;\n                }\n                catch (err) {\n                    this.log.error(err.message);\n                }\n            }\n            // Commit the deletes to the datastore\n            if (deleted.size > 0) {\n                this.log('deleting %d / %d entries', deleteCount, count);\n                await batch.commit();\n            }\n            else {\n                this.log('nothing to delete');\n            }\n            // Clear expired entries from the cache\n            for (const [cid, peers] of deleted) {\n                const key = makeProviderKey(cid);\n                const provs = this.cache.get(key);\n                if (provs != null) {\n                    for (const peerId of peers) {\n                        provs.delete(peerId);\n                    }\n                    if (provs.size === 0) {\n                        this.cache.remove(key);\n                    }\n                    else {\n                        this.cache.set(key, provs);\n                    }\n                }\n            }\n            this.log('Cleanup successful (%dms)', Date.now() - start);\n        });\n    }\n    /**\n     * Get the currently known provider peer ids for a given CID\n     */\n    async _getProvidersMap(cid) {\n        const cacheKey = makeProviderKey(cid);\n        let provs = this.cache.get(cacheKey);\n        if (provs == null) {\n            provs = await loadProviders(this.datastore, cid);\n            this.cache.set(cacheKey, provs);\n        }\n        return provs;\n    }\n    /**\n     * Add a new provider for the given CID\n     */\n    async addProvider(cid, provider) {\n        await this.syncQueue.add(async () => {\n            this.log('%p provides %s', provider, cid);\n            const provs = await this._getProvidersMap(cid);\n            this.log('loaded %s provs', provs.size);\n            const now = new Date();\n            provs.set(provider.toString(), now);\n            const dsKey = makeProviderKey(cid);\n            this.cache.set(dsKey, provs);\n            await writeProviderEntry(this.datastore, cid, provider, now);\n        });\n    }\n    /**\n     * Get a list of providers for the given CID\n     */\n    async getProviders(cid) {\n        return this.syncQueue.add(async () => {\n            this.log('get providers for %s', cid);\n            const provs = await this._getProvidersMap(cid);\n            return [...provs.keys()].map(peerIdStr => {\n                return peerIdFromString(peerIdStr);\n            });\n        }, {\n            // no timeout is specified for this queue so it will not\n            // throw, but this is required to get the right return\n            // type since p-queue@7.3.4\n            throwOnTimeout: true\n        });\n    }\n}\n/**\n * Encode the given key its matching datastore key\n */\nfunction makeProviderKey(cid) {\n    const cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32');\n    return `${PROVIDER_KEY_PREFIX}/${cidStr}`;\n}\n/**\n * Write a provider into the given store\n */\nasync function writeProviderEntry(store, cid, peer, time) {\n    const dsKey = [\n        makeProviderKey(cid),\n        '/',\n        peer.toString()\n    ].join('');\n    const key = new Key(dsKey);\n    const buffer = varint.encode(time.getTime());\n    await store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n */\nfunction parseProviderKey(key) {\n    const parts = key.toString().split('/');\n    if (parts.length !== 5) {\n        throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);\n    }\n    return {\n        cid: parts[3],\n        peerId: parts[4]\n    };\n}\n/**\n * Load providers for the given CID from the store\n */\nasync function loadProviders(store, cid) {\n    const providers = new Map();\n    const query = store.query({ prefix: makeProviderKey(cid) });\n    for await (const entry of query) {\n        const { peerId } = parseProviderKey(entry.key);\n        providers.set(peerId, readTime(entry.value));\n    }\n    return providers;\n}\nfunction readTime(buf) {\n    return new Date(varint.decode(buf));\n}\n//# sourceMappingURL=providers.js.map","import { setMaxListeners } from '@libp2p/interface';\nimport { anySignal } from 'any-signal';\nimport length from 'it-length';\nimport { pipe } from 'it-pipe';\nimport take from 'it-take';\nimport pDefer from 'p-defer';\nimport { pEvent } from 'p-event';\nimport { QUERY_SELF_INTERVAL, QUERY_SELF_TIMEOUT, K, QUERY_SELF_INITIAL_INTERVAL } from './constants.js';\n/**\n * Receives notifications of new peers joining the network that support the DHT protocol\n */\nexport class QuerySelf {\n    log;\n    peerId;\n    peerRouting;\n    routingTable;\n    count;\n    interval;\n    initialInterval;\n    queryTimeout;\n    started;\n    timeoutId;\n    controller;\n    initialQuerySelfHasRun;\n    querySelfPromise;\n    constructor(components, init) {\n        const { peerRouting, logPrefix, count, interval, queryTimeout, routingTable } = init;\n        this.peerId = components.peerId;\n        this.log = components.logger.forComponent(`${logPrefix}:query-self`);\n        this.started = false;\n        this.peerRouting = peerRouting;\n        this.routingTable = routingTable;\n        this.count = count ?? K;\n        this.interval = interval ?? QUERY_SELF_INTERVAL;\n        this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;\n        this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;\n        this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        if (this.started) {\n            return;\n        }\n        this.started = true;\n        clearTimeout(this.timeoutId);\n        this.timeoutId = setTimeout(() => {\n            this.querySelf()\n                .catch(err => {\n                this.log.error('error running self-query', err);\n            });\n        }, this.initialInterval);\n    }\n    stop() {\n        this.started = false;\n        if (this.timeoutId != null) {\n            clearTimeout(this.timeoutId);\n        }\n        if (this.controller != null) {\n            this.controller.abort();\n        }\n    }\n    async querySelf() {\n        if (!this.started) {\n            this.log('skip self-query because we are not started');\n            return;\n        }\n        if (this.querySelfPromise != null) {\n            this.log('joining existing self query');\n            return this.querySelfPromise.promise;\n        }\n        this.querySelfPromise = pDefer();\n        if (this.started) {\n            this.controller = new AbortController();\n            const timeoutSignal = AbortSignal.timeout(this.queryTimeout);\n            const signal = anySignal([this.controller.signal, timeoutSignal]);\n            // this controller will get used for lots of dial attempts so make sure we don't cause warnings to be logged\n            setMaxListeners(Infinity, signal, this.controller.signal, timeoutSignal);\n            try {\n                if (this.routingTable.size === 0) {\n                    this.log('routing table was empty, waiting for some peers before running query');\n                    // wait to discover at least one DHT peer\n                    await pEvent(this.routingTable, 'peer:add', {\n                        signal\n                    });\n                }\n                this.log('run self-query, look for %d peers timing out after %dms', this.count, this.queryTimeout);\n                const start = Date.now();\n                const found = await pipe(this.peerRouting.getClosestPeers(this.peerId.toBytes(), {\n                    signal,\n                    isSelfQuery: true\n                }), (source) => take(source, this.count), async (source) => length(source));\n                this.log('self-query found %d peers in %dms', found, Date.now() - start);\n            }\n            catch (err) {\n                this.log.error('self-query error', err);\n            }\n            finally {\n                signal.clear();\n                if (this.initialQuerySelfHasRun != null) {\n                    this.initialQuerySelfHasRun.resolve();\n                    this.initialQuerySelfHasRun = undefined;\n                }\n            }\n        }\n        this.querySelfPromise.resolve();\n        this.querySelfPromise = undefined;\n        if (!this.started) {\n            return;\n        }\n        this.timeoutId = setTimeout(() => {\n            this.querySelf()\n                .catch(err => {\n                this.log.error('error running self-query', err);\n            });\n        }, this.interval);\n    }\n}\n//# sourceMappingURL=query-self.js.map","import { CustomEvent } from '@libp2p/interface';\nexport function sendQueryEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'SEND_QUERY',\n        type: 0,\n        messageName: fields.type,\n        messageType: fields.type\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:send-query', { detail: event }));\n    return event;\n}\nexport function peerResponseEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'PEER_RESPONSE',\n        type: 1,\n        messageName: fields.messageType,\n        closer: fields.closer ?? [],\n        providers: fields.providers ?? []\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:peer-response', { detail: event }));\n    return event;\n}\nexport function finalPeerEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'FINAL_PEER',\n        type: 2\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:final-peer', { detail: event }));\n    return event;\n}\nexport function queryErrorEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'QUERY_ERROR',\n        type: 3\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:query-error', { detail: event }));\n    return event;\n}\nexport function providerEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'PROVIDER',\n        type: 4\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:provider', { detail: event }));\n    return event;\n}\nexport function valueEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'VALUE',\n        type: 5\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:value', { detail: event }));\n    return event;\n}\nexport function addPeerEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'ADD_PEER',\n        type: 6\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:add-peer', { detail: event }));\n    return event;\n}\nexport function dialPeerEvent(fields, options = {}) {\n    const event = {\n        ...fields,\n        name: 'DIAL_PEER',\n        type: 7\n    };\n    options.onProgress?.(new CustomEvent('kad-dht:query:dial-peer', { detail: event }));\n    return event;\n}\n//# sourceMappingURL=events.js.map","import { setMaxListeners } from '@libp2p/interface';\nimport { PeerSet } from '@libp2p/peer-collections';\nimport { anySignal } from 'any-signal';\nimport merge from 'it-merge';\nimport { raceSignal } from 'race-signal';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { ALPHA, K, DEFAULT_QUERY_TIMEOUT } from '../constants.js';\nimport { convertBuffer } from '../utils.js';\nimport { queryPath } from './query-path.js';\n/**\n * Keeps track of all running queries\n */\nexport class QueryManager {\n    disjointPaths;\n    alpha;\n    shutDownController;\n    running;\n    queries;\n    logger;\n    peerId;\n    connectionManager;\n    routingTable;\n    initialQuerySelfHasRun;\n    logPrefix;\n    metrics;\n    constructor(components, init) {\n        const { disjointPaths = K, alpha = ALPHA, logPrefix } = init;\n        this.logPrefix = logPrefix;\n        this.disjointPaths = disjointPaths ?? K;\n        this.running = false;\n        this.alpha = alpha ?? ALPHA;\n        this.queries = 0;\n        this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;\n        this.routingTable = init.routingTable;\n        this.logger = components.logger;\n        this.peerId = components.peerId;\n        this.connectionManager = components.connectionManager;\n        if (components.metrics != null) {\n            this.metrics = {\n                runningQueries: components.metrics.registerMetric(`${logPrefix.replaceAll(':', '_')}_running_queries`),\n                queryTime: components.metrics.registerMetric(`${logPrefix.replaceAll(':', '_')}_query_time_seconds`)\n            };\n        }\n        // allow us to stop queries on shut down\n        this.shutDownController = new AbortController();\n        // make sure we don't make a lot of noise in the logs\n        setMaxListeners(Infinity, this.shutDownController.signal);\n    }\n    isStarted() {\n        return this.running;\n    }\n    /**\n     * Starts the query manager\n     */\n    async start() {\n        this.running = true;\n        // allow us to stop queries on shut down\n        this.shutDownController = new AbortController();\n        // make sure we don't make a lot of noise in the logs\n        setMaxListeners(Infinity, this.shutDownController.signal);\n    }\n    /**\n     * Stops all queries\n     */\n    async stop() {\n        this.running = false;\n        this.shutDownController.abort();\n    }\n    async *run(key, queryFunc, options = {}) {\n        if (!this.running) {\n            throw new Error('QueryManager not started');\n        }\n        const stopQueryTimer = this.metrics?.queryTime.timer();\n        if (options.signal == null) {\n            // don't let queries run forever\n            const signal = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);\n            // this signal will get listened to for network requests, etc\n            // so make sure we don't make a lot of noise in the logs\n            setMaxListeners(Infinity, signal);\n            options = {\n                ...options,\n                signal\n            };\n        }\n        // if the user breaks out of a for..await of loop iterating over query\n        // results we need to cancel any in-flight network requests\n        const queryEarlyExitController = new AbortController();\n        const signal = anySignal([\n            this.shutDownController.signal,\n            queryEarlyExitController.signal,\n            options.signal\n        ]);\n        // this signal will get listened to for every invocation of queryFunc\n        // so make sure we don't make a lot of noise in the logs\n        setMaxListeners(Infinity, signal, queryEarlyExitController.signal);\n        const log = this.logger.forComponent(`${this.logPrefix}:query:` + uint8ArrayToString(key, 'base58btc'));\n        // query a subset of peers up to `kBucketSize / 2` in length\n        const startTime = Date.now();\n        let queryFinished = false;\n        try {\n            if (options.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {\n                log('waiting for initial query-self query before continuing');\n                await raceSignal(this.initialQuerySelfHasRun.promise, signal);\n                this.initialQuerySelfHasRun = undefined;\n            }\n            log('query:start');\n            this.queries++;\n            this.metrics?.runningQueries.update(this.queries);\n            const id = await convertBuffer(key);\n            const peers = this.routingTable.closestPeers(id);\n            const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));\n            if (peers.length === 0) {\n                log.error('Running query with no peers');\n                return;\n            }\n            // make sure we don't get trapped in a loop\n            const peersSeen = new PeerSet();\n            // Create query paths from the starting peers\n            const paths = peersToQuery.map((peer, index) => {\n                return queryPath({\n                    key,\n                    startingPeer: peer,\n                    ourPeerId: this.peerId,\n                    signal,\n                    query: queryFunc,\n                    pathIndex: index,\n                    numPaths: peersToQuery.length,\n                    alpha: this.alpha,\n                    queryFuncTimeout: options.queryFuncTimeout,\n                    log,\n                    peersSeen,\n                    onProgress: options.onProgress,\n                    connectionManager: this.connectionManager\n                });\n            });\n            // Execute the query along each disjoint path and yield their results as they become available\n            for await (const event of merge(...paths)) {\n                if (event.name === 'QUERY_ERROR') {\n                    log.error('query error', event.error);\n                }\n                if (event.name === 'PEER_RESPONSE') {\n                    for (const peer of [...event.closer, ...event.providers]) {\n                        // eslint-disable-next-line max-depth\n                        if (!(await this.connectionManager.isDialable(peer.multiaddrs))) {\n                            continue;\n                        }\n                        await this.routingTable.add(peer.id);\n                    }\n                }\n                yield event;\n            }\n            queryFinished = true;\n        }\n        catch (err) {\n            if (!this.running && err.code === 'ERR_QUERY_ABORTED') {\n                // ignore query aborted errors that were thrown during query manager shutdown\n            }\n            else {\n                throw err;\n            }\n        }\n        finally {\n            if (!queryFinished) {\n                log('query exited early');\n                queryEarlyExitController.abort();\n            }\n            signal.clear();\n            this.queries--;\n            this.metrics?.runningQueries.update(this.queries);\n            if (stopQueryTimer != null) {\n                stopQueryTimer();\n            }\n            log('query:done in %dms', Date.now() - startTime);\n        }\n    }\n}\n//# sourceMappingURL=manager.js.map","import { CodeError, setMaxListeners } from '@libp2p/interface';\nimport { Queue } from '@libp2p/utils/queue';\nimport { anySignal } from 'any-signal';\nimport { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport { xorCompare as uint8ArrayXorCompare } from 'uint8arrays/xor-compare';\nimport { convertPeerId, convertBuffer } from '../utils.js';\nimport { queryErrorEvent } from './events.js';\n/**\n * Walks a path through the DHT, calling the passed query function for\n * every peer encountered that we have not seen before\n */\nexport async function* queryPath(options) {\n    const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, queryFuncTimeout, log, peersSeen, connectionManager } = options;\n    // Only ALPHA node/value lookups are allowed at any given time for each process\n    // https://github.com/libp2p/specs/tree/master/kad-dht#alpha-concurrency-parameter-%CE%B1\n    const queue = new Queue({\n        concurrency: alpha,\n        sort: (a, b) => uint8ArrayXorCompare(a.options.distance, b.options.distance)\n    });\n    // perform lookups on kadId, not the actual value\n    const kadId = await convertBuffer(key);\n    /**\n     * Adds the passed peer to the query queue if it's not us and no\n     * other path has passed through this peer\n     */\n    function queryPeer(peer, peerKadId) {\n        if (peer == null) {\n            return;\n        }\n        peersSeen.add(peer);\n        const peerXor = uint8ArrayXor(peerKadId, kadId);\n        queue.add(async () => {\n            const signals = [signal];\n            if (queryFuncTimeout != null) {\n                signals.push(AbortSignal.timeout(queryFuncTimeout));\n            }\n            const compoundSignal = anySignal(signals);\n            // this signal can get listened to a lot\n            setMaxListeners(Infinity, compoundSignal);\n            try {\n                for await (const event of query({\n                    key,\n                    peer,\n                    signal: compoundSignal,\n                    pathIndex,\n                    numPaths\n                })) {\n                    if (compoundSignal.aborted) {\n                        return;\n                    }\n                    // if there are closer peers and the query has not completed, continue the query\n                    if (event.name === 'PEER_RESPONSE') {\n                        for (const closerPeer of event.closer) {\n                            if (peersSeen.has(closerPeer.id)) { // eslint-disable-line max-depth\n                                log('already seen %p in query', closerPeer.id);\n                                continue;\n                            }\n                            if (ourPeerId.equals(closerPeer.id)) { // eslint-disable-line max-depth\n                                log('not querying ourselves');\n                                continue;\n                            }\n                            if (!(await connectionManager.isDialable(closerPeer.multiaddrs))) { // eslint-disable-line max-depth\n                                log('not querying undialable peer');\n                                continue;\n                            }\n                            const closerPeerKadId = await convertPeerId(closerPeer.id);\n                            const closerPeerXor = uint8ArrayXor(closerPeerKadId, kadId);\n                            // only continue query if closer peer is actually closer\n                            if (uint8ArrayXorCompare(closerPeerXor, peerXor) !== -1) { // eslint-disable-line max-depth\n                                log('skipping %p as they are not closer to %b than %p', closerPeer.id, key, peer);\n                                continue;\n                            }\n                            log('querying closer peer %p', closerPeer.id);\n                            queryPeer(closerPeer.id, closerPeerKadId);\n                        }\n                    }\n                    queue.safeDispatchEvent('completed', {\n                        detail: event\n                    });\n                }\n            }\n            catch (err) {\n                if (!signal.aborted) {\n                    return queryErrorEvent({\n                        from: peer,\n                        error: err\n                    }, options);\n                }\n            }\n            finally {\n                compoundSignal.clear();\n            }\n        }, {\n            distance: peerXor\n        }).catch(err => {\n            log.error(err);\n        });\n    }\n    // begin the query with the starting peer\n    queryPeer(startingPeer, await convertPeerId(startingPeer));\n    try {\n        // yield results as they come in\n        for await (const event of queue.toGenerator({ signal })) {\n            if (event != null) {\n                yield event;\n            }\n        }\n    }\n    catch (err) {\n        if (signal.aborted) {\n            throw new CodeError('Query aborted', 'ERR_QUERY_ABORTED');\n        }\n        throw err;\n    }\n}\n//# sourceMappingURL=query-path.js.map","import { CodeError } from '@libp2p/interface';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\n/**\n * Select the best record out of the given records\n */\nexport function bestRecord(selectors, k, records) {\n    if (records.length === 0) {\n        const errMsg = 'No records given';\n        throw new CodeError(errMsg, 'ERR_NO_RECORDS_RECEIVED');\n    }\n    const kStr = uint8ArrayToString(k);\n    const parts = kStr.split('/');\n    if (parts.length < 3) {\n        const errMsg = 'Record key does not have a selector function';\n        throw new CodeError(errMsg, 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY');\n    }\n    const selector = selectors[parts[1].toString()];\n    if (selector == null) {\n        const errMsg = `No selector function configured for key type \"${parts[1]}\"`;\n        throw new CodeError(errMsg, 'ERR_UNRECOGNIZED_KEY_PREFIX');\n    }\n    if (records.length === 1) {\n        return 0;\n    }\n    return selector(k, records);\n}\n/**\n * Best record selector, for public key records.\n * Simply returns the first record, as all valid public key\n * records are equal\n */\nfunction publickKey(k, records) {\n    return 0;\n}\nexport const selectors = {\n    pk: publickKey\n};\n//# sourceMappingURL=selectors.js.map","import { CodeError } from '@libp2p/interface';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\n/**\n * Checks a record and ensures it is still valid.\n * It runs the needed validators.\n * If verification fails the returned Promise will reject with the error.\n */\nexport async function verifyRecord(validators, record) {\n    const key = record.key;\n    const keyString = uint8ArrayToString(key);\n    const parts = keyString.split('/');\n    if (parts.length < 3) {\n        // No validator available\n        return;\n    }\n    const validator = validators[parts[1].toString()];\n    if (validator == null) {\n        const errMsg = `No validator available for key type \"${parts[1]}\"`;\n        throw new CodeError(errMsg, 'ERR_INVALID_RECORD_KEY_TYPE');\n    }\n    await validator(key, record.value);\n}\n/**\n * Validator for public key records.\n * Verifies that the passed in record value is the PublicKey\n * that matches the passed in key.\n * If validation fails the returned Promise will reject with the error.\n *\n * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`\n * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).\n */\nconst validatePublicKeyRecord = async (key, publicKey) => {\n    if (!(key instanceof Uint8Array)) {\n        throw new CodeError('\"key\" must be a Uint8Array', 'ERR_INVALID_RECORD_KEY_NOT_BUFFER');\n    }\n    if (key.byteLength < 5) {\n        throw new CodeError('invalid public key record', 'ERR_INVALID_RECORD_KEY_TOO_SHORT');\n    }\n    const prefix = uint8ArrayToString(key.subarray(0, 4));\n    if (prefix !== '/pk/') {\n        throw new CodeError('key was not prefixed with /pk/', 'ERR_INVALID_RECORD_KEY_BAD_PREFIX');\n    }\n    const keyhash = key.slice(4);\n    const publicKeyHash = await sha256.digest(publicKey);\n    if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {\n        throw new CodeError('public key does not match passed in key', 'ERR_INVALID_RECORD_HASH_MISMATCH');\n    }\n};\nexport const validators = {\n    pk: validatePublicKeyRecord\n};\n//# sourceMappingURL=validators.js.map","export default [\n    77591, 22417, 43971, 28421, 740, 29829, 71467, 228973, 196661, 78537, 27689, 36431, 44415, 14362, 19456, 106025,\n    96308, 2882, 49509, 21149, 87173, 131409, 75844, 23676, 121838, 30291, 17492, 2953, 7564, 110620, 129477, 127283,\n    53113, 72417, 165166, 109690, 21200, 102125, 24049, 71504, 90342, 25307, 72039, 26812, 26715, 32264, 133800, 71161,\n    88956, 171987, 51779, 24425, 16671, 30251, 186294, 247761, 14202, 2121, 8465, 35024, 4876, 85917, 169730, 3638,\n    256836, 96184, 943, 18678, 6583, 52907, 35807, 112254, 214097, 18796, 11595, 9243, 23554, 887, 268203, 382004,\n    24590, 111335, 11625, 16619, 29039, 102425, 69006, 97976, 92362, 32552, 63717, 41433, 128974, 137630, 59943, 10019,\n    13986, 35430, 33665, 108037, 43799, 43280, 38195, 29078, 58629, 18265, 14425, 46832, 235538, 40830, 77881, 110717,\n    58937, 3463, 325358, 51300, 47623, 117252, 19007, 10170, 20540, 91237, 294813, 4951, 79841, 56232, 36270, 128547,\n    69209, 66275, 100156, 32063, 73531, 34439, 80937, 28892, 44466, 88595, 216307, 32583, 49620, 16605, 82127, 45807,\n    21630, 78726, 20235, 40163, 111007, 96926, 5567, 72083, 21665, 58844, 39419, 179767, 48328, 42662, 51550, 5251,\n    37811, 49608, 81056, 50854, 55513, 20922, 18891, 197409, 164656, 32593, 71449, 220474, 58919, 85682, 67854, 13758,\n    35066, 3565, 61905, 214793, 119572, 141419, 21504, 10302, 27354, 67003, 46131, 32668, 15165, 64871, 34450, 17821,\n    2757, 11452, 34189, 5160, 12257, 85523, 560, 53385, 65887, 119549, 135620, 312353, 115979, 122356, 10867, 193231,\n    124537, 54783, 90675, 120791, 4715, 142253, 50943, 17271, 43358, 25331, 4917, 120566, 34580, 12878, 33786, 160528,\n    32523, 4869, 301307, 104817, 81491, 23276, 8832, 97911, 31265, 52065, 7998, 49622, 9715, 43998, 34091, 84587,\n    20664, 69041, 29419, 53205, 10838, 58288, 116145, 6185, 5154, 141795, 35924, 21307, 144738, 43730, 12085, 8279,\n    10002, 119, 133779, 199668, 72938, 31768, 39176, 67875, 38453, 9700, 44144, 4121, 116048, 41733, 12868, 82669,\n    92308, 128, 34262, 11332, 7712, 90764, 36141, 13553, 71312, 77470, 117314, 96549, 49135, 23602, 54468, 28605,\n    6327, 62308, 17171, 67531, 21319, 14105, 894, 107722, 46157, 8503, 51069, 100472, 45138, 15246, 14577, 35609,\n    191464, 1757, 13364, 161349, 32067, 91705, 81144, 52339, 5408, 91066, 21983, 14157, 100545, 4372, 26630, 129112,\n    1423, 29676, 213626, 4397, 88436, 99190, 6877, 49958, 26122, 114348, 60661, 29818, 293118, 50042, 179738, 16400,\n    163423, 89627, 31040, 43973, 36638, 45952, 5153, 1894, 109322, 1898, 134021, 12402, 112077, 68309, 190269, 69866,\n    31938, 107383, 11522, 105232, 11248, 14868, 39852, 71707, 186525, 16530, 38162, 106212, 11700, 5130, 16608, 26998,\n    59586, 108399, 230033, 43683, 48135, 82179, 2073, 5015, 196684, 189293, 16378, 23452, 8301, 35640, 11632, 214551,\n    29240, 57644, 33137, 91949, 55157, 52384, 117313, 5090, 17717, 89668, 49363, 82238, 241035, 66216, 29066, 184088,\n    97206, 62820, 26595, 4241, 135635, 173672, 8202, 459, 71355, 146294, 29587, 3008, 135385, 141203, 14803, 6634,\n    45094, 69362, 50925, 546, 51884, 62011, 83296, 234584, 44515, 56050, 89476, 87751, 19373, 12691, 149923, 19794,\n    13833, 35846, 87557, 58339, 2884, 19145, 25647, 12224, 11024, 77338, 64608, 122297, 53025, 7205, 36189, 36294,\n    170779, 21750, 7739, 173883, 75192, 35664, 224240, 113121, 30181, 26267, 27036, 117827, 92015, 106516, 55628, 203549,\n    67949, 60462, 60844, 35911, 20457, 1820, 920, 19773, 8738, 73173, 181993, 38521, 98254, 76257, 46008, 92796,\n    5384, 26868, 151566, 22124, 2411, 15919, 186872, 180021, 28099, 152961, 78811, 80237, 62352, 102653, 74259, 184890,\n    16792, 123702, 224945, 29940, 19512, 75283, 14059, 112691, 92811, 233329, 20411, 138569, 53341, 109802, 50600, 134528,\n    66747, 5529, 166531, 31578, 64732, 67189, 1596, 126357, 967, 167999, 206598, 109752, 119431, 207825, 78791, 91938,\n    10301, 27311, 24233, 252343, 28831, 32812, 66002, 112267, 90895, 8786, 8095, 16824, 22866, 21813, 60507, 174833,\n    19549, 130985, 117051, 52110, 6938, 81923, 123864, 38061, 919, 18680, 53534, 46739, 112893, 161529, 85429, 26761,\n    11900, 81121, 91968, 15390, 217947, 56524, 1713, 6654, 37089, 85630, 138866, 61850, 16491, 75577, 16884, 98296,\n    73523, 6140, 44645, 6062, 36366, 29844, 57946, 37932, 42472, 5266, 20834, 19309, 33753, 127182, 134259, 35810,\n    41805, 45878, 312001, 14881, 47757, 49251, 120050, 44252, 3708, 25856, 107864, 120347, 1228, 36550, 41682, 34496,\n    47025, 8393, 173365, 246526, 12894, 161607, 35670, 90785, 126572, 2095, 124731, 157033, 58694, 554, 12786, 9642,\n    4817, 16136, 47864, 174698, 66992, 4639, 69284, 10625, 40710, 27763, 51738, 30404, 264105, 137904, 109882, 52487,\n    42824, 57514, 2740, 10479, 146799, 107390, 16586, 88038, 174951, 9410, 16185, 44158, 5568, 40658, 46108, 12763,\n    97385, 26175, 108859, 664, 230732, 67470, 46663, 14395, 50750, 141320, 93140, 15361, 47997, 55784, 6791, 307840,\n    118569, 107326, 18056, 58281, 260415, 54691, 8790, 73332, 45633, 7511, 45674, 143373, 14031, 11799, 94491, 35646,\n    96544, 14560, 26049, 32983, 25791, 83814, 42094, 231370, 63955, 139212, 2359, 169908, 3108, 183486, 105867, 28197,\n    32941, 124968, 26402, 88267, 149768, 23053, 3078, 19091, 52924, 25383, 19209, 111548, 97361, 3959, 24880, 235061,\n    9099, 24921, 161254, 151405, 20508, 7159, 34381, 20133, 11434, 74036, 19974, 34769, 36585, 1076, 22454, 17354,\n    38727, 235160, 111547, 96454, 117448, 156940, 91330, 37299, 7310, 26915, 117060, 51369, 22620, 61861, 322264, 106850,\n    111694, 15091, 2624, 40345, 300446, 177064, 1707, 27389, 54792, 327783, 132669, 183543, 59003, 17744, 20603, 151134,\n    106923, 53084, 71803, 279424, 319816, 11579, 21946, 16728, 38274, 72711, 5085, 83391, 88646, 40159, 25027, 34680,\n    10752, 12988, 54126, 30365, 18338, 100445, 230674, 44874, 84974, 143877, 123253, 139372, 28082, 91477, 144002, 13096,\n    219729, 46016, 50029, 42377, 14601, 6660, 58244, 58978, 23918, 88206, 113611, 64452, 17541, 41032, 10942, 12021,\n    49189, 10978, 40175, 37156, 10947, 71709, 106894, 112538, 57007, 137486, 150608, 152719, 40615, 7746, 279716, 13101,\n    19524, 28708, 40578, 72320, 1096, 182051, 94527, 51275, 22833, 45164, 81917, 77519, 48508, 5421, 140302, 37845,\n    149830, 5587, 27579, 5357, 428725, 248187, 6326, 206760, 39814, 32585, 89923, 44341, 288753, 284443, 96368, 31201,\n    94189, 119504, 20359, 52073, 103216, 179, 27934, 32801, 96035, 34111, 34309, 101326, 18198, 20704, 210266, 37643,\n    27880, 141873, 106000, 19414, 56614, 167714, 66483, 107885, 86602, 4379, 20796, 75467, 4987, 5017, 118857, 26003,\n    34308, 114428, 29198, 6686, 29697, 73632, 3739, 69795, 16798, 41504, 7207, 30722, 21436, 36735, 28067, 28545,\n    3239, 11221, 36031, 41889, 100010, 19247, 317673, 29495, 174554, 6424, 129725, 53845, 94986, 7955, 59676, 2604,\n    191497, 19735, 102214, 62954, 23844, 11872, 179525, 261436, 34492, 428, 78404, 142035, 16747, 17246, 27578, 37021,\n    33672, 57944, 26056, 135760, 2369, 61674, 122066, 31327, 19374, 157065, 40553, 130982, 69619, 71290, 38855, 72100,\n    92903, 95940, 51422, 165999, 65713, 57873, 50726, 7288, 20272, 2081, 42326, 22624, 81120, 57914, 79352, 19447,\n    1684, 72302, 11774, 302559, 161481, 96396, 13692, 414988, 3721, 79066, 56627, 46883, 21150, 11747, 12184, 5856,\n    113458, 176117, 84416, 52079, 27933, 3354, 59765, 141359, 2212, 216309, 2555, 23458, 196722, 142463, 45701, 44548,\n    28798, 19418, 215, 29916, 9396, 10574, 114226, 84475, 13520, 18694, 34056, 4524, 90302, 62930, 13539, 19407,\n    77209, 7728, 38088, 9535, 2263, 23875, 183945, 17750, 26274, 67172, 10585, 28042, 22199, 7478, 51331, 66030,\n    26774, 192929, 31434, 25850, 50197, 52926, 178158, 4679, 181256, 70184, 229600, 9959, 105594, 72158, 73974, 2726,\n    35085, 78087, 23284, 35568, 51713, 155676, 5401, 27254, 11966, 17569, 223253, 71993, 103357, 111477, 55722, 30504,\n    26034, 46774, 35392, 36285, 214814, 41143, 163465, 1051, 16094, 81044, 6636, 76489, 179102, 20712, 39178, 35683,\n    125177, 54219, 30617, 52994, 25324, 50123, 2543, 87529, 58995, 10688, 125199, 12388, 60158, 125481, 131646, 7642,\n    133350, 65874, 3438, 97277, 101450, 10075, 56344, 116821, 50778, 60547, 98016, 106135, 13859, 14255, 16300, 77373,\n    173521, 8285, 45932, 37426, 4054, 114295, 55947, 7703, 39114, 52, 51119, 128135, 19714, 60715, 9554, 50492,\n    88180, 2823, 118271, 52993, 122625, 97919, 23859, 37895, 25040, 33614, 32102, 20431, 3577, 9275, 15686, 43031,\n    157741, 110358, 1884, 40291, 125391, 13736, 5008, 64881, 87336, 77381, 70711, 43032, 49155, 118587, 70494, 4318,\n    10168, 30126, 12580, 10524, 280104, 104001, 145413, 2862, 84140, 6603, 106005, 13566, 12780, 11251, 42830, 571,\n    179910, 82443, 13146, 469, 42714, 32591, 265217, 424024, 92553, 54721, 134100, 6007, 15242, 114681, 59030, 16718,\n    85465, 200214, 85982, 55174, 165013, 23493, 56964, 82529, 109150, 32706, 27568, 82442, 5350, 14976, 13165, 44890,\n    60021, 21343, 33978, 17264, 4655, 22328, 27819, 75730, 16567, 55483, 14510, 17926, 45827, 150609, 3704, 7385,\n    272531, 161543, 76904, 122163, 52405, 2039, 19165, 41623, 14423, 228354, 3369, 176360, 85491, 7122, 35789, 303724,\n    4465, 13628, 2233, 55311, 118771, 20713, 10006, 221519, 45115, 71021, 35650, 29775, 7337, 10864, 20665, 21142,\n    1746, 15080, 1624, 32449, 10905, 105743, 229797, 7701, 3940, 22997, 178467, 57208, 389057, 39683, 59403, 63344,\n    63125, 54847, 69691, 18336, 56448, 3362, 37202, 18282, 29648, 138224, 35867, 10495, 5911, 28814, 26653, 31514,\n    176702, 26550, 45621, 11734, 4525, 40543, 73944, 121080, 27858, 155561, 14887, 44670, 30742, 8796, 107455, 113472,\n    56369, 75581, 183777, 240095, 133699, 153299, 8768, 160464, 26058, 49078, 103971, 21875, 71486, 44888, 17156, 9678,\n    89541, 123019, 102337, 3972, 83930, 21245, 87852, 109660, 287918, 183019, 686, 10100, 39177, 283941, 11274, 24736,\n    26793, 26214, 25995, 77011, 141580, 4070, 23742, 46285, 46632, 30700, 26669, 19056, 35951, 115575, 174034, 56097,\n    35463, 87425, 24575, 44245, 38701, 82317, 85922, 281616, 100333, 147697, 61503, 7730, 84330, 8530, 59917, 61597,\n    17173, 9092, 32658, 90288, 193136, 39023, 20381, 56654, 31132, 7779, 1919, 1375, 117128, 30819, 11169, 40938,\n    23935, 115201, 101155, 151034, 4835, 11231, 74550, 89388, 59951, 91704, 107312, 167882, 115062, 12732, 72738, 88703,\n    464019, 158267, 57995, 60496, 737, 14371, 123867, 4174, 243339, 159946, 7568, 16025, 134556, 110916, 38103, 191,\n    80226, 88794, 29688, 27230, 10454, 76308, 57647, 77409, 113483, 66864, 14745, 19808, 12023, 46583, 84805, 16015,\n    17102, 2231, 20611, 3547, 95740, 250131, 34559, 108894, 8498, 15853, 159169, 148920, 20942, 2813, 93160, 45188,\n    210613, 45531, 52587, 149062, 39782, 28194, 57849, 60965, 84954, 89766, 84453, 100927, 16501, 27658, 165311, 103841,\n    54192, 207341, 19558, 20084, 319622, 5672, 205467, 98462, 61849, 36279, 13609, 147177, 24726, 165015, 209489, 59591,\n    31157, 6551, 117580, 75060, 141146, 277310, 21072, 22023, 106474, 63041, 137443, 122965, 68371, 5383, 42146, 98961,\n    113467, 30863, 23794, 4843, 99630, 30392, 82679, 13699, 241612, 33601, 93146, 24319, 18643, 32155, 95669, 40440,\n    15333, 34089, 67799, 142144, 58245, 38633, 114531, 117400, 77861, 188726, 5507, 2568, 8853, 10987, 107222, 2663,\n    2421, 11530, 13345, 30075, 41785, 118661, 104786, 17459, 12490, 16281, 71936, 193555, 17431, 5944, 71758, 26485,\n    77317, 20803, 367167, 158, 7362, 93430, 11735, 172445, 46002, 11532, 54482, 930, 62911, 2235, 23004, 179236,\n    4764, 101859, 208113, 22477, 55163, 95579, 14098, 67320, 162556, 90709, 156949, 3826, 57492, 4025, 34092, 87442,\n    104565, 6718, 186015, 28214, 14209, 10039, 107186, 233912, 58877, 81637, 55265, 39828, 6194, 145813, 50831, 105849,\n    4974, 88319, 122296, 10272, 197216, 95714, 51540, 72418, 23324, 91555, 8743, 140452, 250249, 51666, 34124, 7229,\n    38592, 129641, 78169, 174242, 22464, 149964, 51450, 14034, 10026, 95376, 26190, 120062, 14401, 8700, 265, 31386,\n    143573, 7203, 229889, 61567, 4227, 140981, 2466, 72052, 10787, 10062, 30958, 6099, 38471, 30103, 23202, 208101,\n    70847, 467, 58934, 32271, 32984, 36637, 24107, 30771, 17109, 73353, 13650, 2098, 157040, 67366, 66904, 106018,\n    265380, 107238, 18535, 44025, 32681, 144983, 62505, 91295, 56120, 3082, 77508, 10322, 63023, 36700, 81885, 224127,\n    16721, 45023, 239261, 111272, 13852, 7866, 149243, 204199, 32309, 22084, 42029, 38316, 126644, 104973, 14406, 43454,\n    67322, 61310, 15789, 40285, 24026, 181047, 6301, 70927, 23319, 115823, 27248, 66693, 115875, 278566, 63007, 146844,\n    56841, 59007, 87368, 180001, 22370, 42114, 80605, 12022, 10374, 308, 25079, 14689, 12618, 63368, 7936, 264973,\n    212291, 136713, 95999, 105801, 18965, 32075, 48700, 52230, 35119, 96912, 32992, 8586, 16606, 101333, 101812, 14969,\n    39930, 759, 193090, 27387, 42914, 12937, 5058, 62646, 64528, 38624, 25743, 37502, 3716, 4435, 30352, 178687,\n    26461, 132611, 42002, 138442, 35833, 59582, 16345, 8048, 60319, 49349, 309, 47800, 49739, 90482, 26405, 34470,\n    63786, 32479, 85028, 39866, 47846, 11649, 23934, 29466, 2816, 42864, 31828, 7410, 74885, 49632, 47629, 111801,\n    90749, 19536, 18767, 105764, 59606, 21223, 10746, 76298, 22220, 39408, 7190, 79654, 64856, 11602, 82156, 272765,\n    17079, 70089, 245473, 51813, 184407, 384678, 1576, 122249, 5064, 27481, 6188, 25790, 74361, 27541, 318284, 45430,\n    31488, 620, 93579, 45723, 192118, 22670, 51913, 4162, 70244, 35966, 26397, 16199, 50899, 209613, 121702, 287507,\n    2993, 36101, 132229, 67345, 33062, 76295, 118628, 78705, 52316, 34375, 107083, 107454, 44863, 127561, 33964, 3073,\n    154010, 190914, 55967, 39074, 6272, 31047, 5550, 41123, 26154, 98638, 47110, 19998, 148091, 50229, 31329, 59900,\n    195442, 19106, 61347, 73497, 70015, 682, 45850, 25776, 38022, 148951, 6288, 37411, 232526, 109277, 27286, 32342,\n    9262, 5220, 16651, 23175, 46740, 129438, 78614, 121925, 66914, 88710, 127952, 5563, 21500, 34521, 10739, 14863,\n    191006, 62956, 17359, 16749, 67027, 56284, 69134, 43301, 35039, 58883, 54466, 60823, 404451, 75743, 59856, 86979,\n    7923, 34273, 83785, 32142, 7693, 268986, 197428, 282681, 17049, 22346, 22990, 92245, 107180, 3357, 37104, 96724,\n    49153, 7683, 31197, 43267, 82231, 164276, 23696, 20848, 188364, 22309, 24821, 158707, 1018, 22514, 70922, 27792,\n    45589, 59709, 10765, 736, 35218, 63479, 51987, 24275, 63588, 55361, 92929, 81964, 4658, 20122, 12330, 44058,\n    13065, 311456, 72224, 8337, 211229, 38979, 22590, 138478, 52757, 32595, 133600, 8838, 31549, 94412, 43391, 90056,\n    1585, 94802, 127271, 6223, 31889, 137038, 132910, 2165, 57616, 230152, 6080, 10748, 36737, 74579, 134062, 50525,\n    180532, 119270, 34556, 76155, 82394, 52595, 29258, 31435, 87820, 67996, 26943, 183878, 38007, 2410, 13526, 180297,\n    69856, 3503, 187396, 167700, 7838, 16701, 9199, 56267, 3661, 37407, 65994, 23767, 5708, 62508, 221700, 67088,\n    86978, 46776, 84434, 32088, 5612, 9149, 88244, 21685, 95151, 46750, 189612, 2979, 506311, 2594, 3628, 40074,\n    105039, 78243, 28523, 6651, 38058, 71999, 30992, 12764, 68261, 108991, 6165, 26450, 61961, 13400, 22426, 7490,\n    60890, 109623, 2070, 12958, 50355, 67979, 257096, 7213, 42578, 52121, 35716, 65461, 7516, 124758, 39268, 302,\n    64712, 14977, 1467, 219452, 2840, 34229, 11121, 21602, 19270, 63574, 8024, 1532, 17331, 79839, 78885, 52029,\n    180767, 57957, 6069, 91265, 61380, 55767, 8927, 32881, 287603, 22149, 35029, 68876, 6428, 199567, 46926, 13412,\n    104132, 21434, 366616, 45060, 110046, 81924, 128910, 45886, 52821, 130416, 29416, 77342, 21762, 67329, 121432, 79924,\n    11724, 38625, 81006, 102033, 28338, 13326, 3250, 82056, 82526, 38212, 21112, 12382, 111495, 3263, 7414, 86274,\n    93490, 40844, 30224, 45212, 24019, 48411, 71367, 24941, 76729, 57776, 3769, 38114, 202019, 197745, 31953, 237533,\n    33270, 201580, 255648, 100798, 44741, 32241, 98468, 106931, 10085, 15090, 170358, 33154, 66787, 18819, 69760, 25061,\n    234005, 82660, 6295, 131975, 16874, 9076, 4094, 25005, 17740, 40908, 19533, 220019, 44330, 99792, 50040, 19619,\n    13950, 55228, 24423, 31253, 95308, 103177, 184795, 28590, 82285, 5059, 3210, 75525, 49894, 70007, 56178, 10580,\n    36051, 139681, 21617, 98736, 3555, 106306, 164189, 37352, 63915, 47824, 24883, 145530, 61904, 28444, 11483, 19837,\n    145446, 30420, 112972, 85939, 11835, 191233, 2262, 20705, 58630, 1753, 148334, 1197, 144714, 6887, 11223, 107667,\n    60879, 77914, 4151, 57417, 81594, 96681, 169430, 1784, 20444, 95138, 254041, 27038, 596, 7117, 72808, 13759,\n    3353, 126776, 21074, 55322, 27081, 36942, 39547, 139830, 179275, 4453, 713, 8722, 71399, 19204, 25785, 22794,\n    23923, 104114, 11291, 25458, 102309, 88396, 75288, 230440, 206396, 104551, 58447, 130857, 37247, 94734, 31548, 176529,\n    226077, 65159, 20104, 10096, 66881, 94191, 237909, 27109, 37404, 1520, 27421, 25220, 113003, 23423, 24884, 50585,\n    6286, 231877, 150800, 11789, 3226, 90004, 60642, 5053, 202400, 61442, 132531, 175329, 57138, 30116, 103847, 9973,\n    75367, 16452, 32360, 59119, 21246, 10191, 164804, 23305, 61051, 37348, 154530, 13214, 5468, 50403, 66754, 130976,\n    50559, 80515, 14436, 155492, 84017, 5472, 43107, 41240, 2890, 90431, 70188, 382, 76234, 48040, 50211, 281038,\n    237007, 32115, 142178, 1536, 22761, 96429, 1811, 31243, 1679, 49143, 55209, 17402, 235054, 61494, 7462, 77030,\n    34925, 87609, 78002, 9499, 9027, 73289, 201078, 101379, 63544, 27666, 5469, 10642, 30029, 49816, 132979, 95620,\n    58086, 351930, 116300, 2110, 2043, 30845, 6154, 11279, 16727, 4122, 2277, 27281, 4971, 3650, 39060, 61970,\n    65951, 39674, 75686, 38151, 11370, 130809, 177895, 32665, 63725, 122267, 7857, 39618, 118483, 44792, 157755, 178624,\n    136994, 24260, 41308, 22471, 12404, 21707, 12486, 30473, 52781, 50246, 20247, 39065, 909, 56825, 103158, 128603,\n    31542, 1089, 41935, 32744, 12428, 37963, 84420, 33134, 72921, 208449, 42622, 168151, 127335, 147107, 46699, 38216,\n    12591, 94342, 85814, 31423, 24944, 2605, 87542, 67473, 192551, 4496, 56321, 91819, 17630, 6300, 256183, 114569,\n    202090, 33209, 35289, 34897, 24967, 40520, 43470, 5344, 10199, 34810, 14283, 10381, 10017, 62923, 49924, 23233,\n    64539, 13051, 35686, 19698, 11570, 135555, 120868, 44924, 87065, 52318, 52335, 47586, 140906, 245885, 109834, 78668,\n    9065, 46990, 25258, 72022, 61243, 40838, 4545, 146387, 10537, 11557, 17470, 36930, 68104, 46711, 24264, 79401,\n    81043, 18225, 120488, 24746, 84338, 81652, 28266, 13776, 21878, 46973, 1047, 230465, 73357, 95777, 24973, 210160,\n    62210, 58404, 110633, 169651, 6937, 41870, 9909, 26822, 191062, 76553, 27519, 96256, 239070, 2478, 205678, 67955,\n    58532, 20601, 50120, 19148, 78501, 195724, 110740, 8249, 109665, 27446, 30568, 57631, 31425, 49752, 32820, 65504,\n    50079, 3663, 102256, 219898, 23849, 211315, 14645, 4359, 91767, 9528, 12449, 49366, 7941, 49763, 107848, 8930,\n    27086, 50686, 9744, 10447, 81935, 39513, 46514, 1670, 29229, 6172, 22312, 137280, 97759, 9806, 14445, 22976,\n    56458, 73391, 34983, 93760, 174219, 52573, 33149, 59747, 2429, 136277, 75123, 165263, 91040, 7446, 57632, 48633,\n    97140, 246081, 84766, 151684, 79918, 93268, 120346, 54059, 54875, 77858, 32996, 103590, 45276, 11968, 19600, 25849,\n    17159, 132907, 42828, 16817, 4913, 99462, 103303, 27395, 5737, 74184, 20749, 21160, 14377, 77062, 131403, 158735,\n    10999, 27799, 77785, 9320, 34366, 51593, 61070, 33746, 47048, 29268, 36675, 30262, 53297, 9832, 82000, 20188,\n    122292, 39917, 7331, 18160, 68301, 185935, 134830, 15031, 4935, 10004, 165845, 185534, 46923, 30109, 44134, 122631,\n    18874, 22903, 112790, 26561, 18549, 348902, 82871, 140345, 255565, 135390, 63556, 103747, 145055, 179600, 145662, 296111,\n    61661, 211987, 23952, 52342, 126343, 48450, 32919, 44277, 82185, 9591, 62139, 205363, 376969, 394874, 108461, 18040,\n    120885, 14798, 39863, 16571, 16794, 58271, 81025, 55206, 14640, 118656, 6361, 44092, 85970, 6262, 153863, 108244,\n    180200, 72264, 79947, 38044, 10050, 5735, 61221, 80712, 5471, 115689, 11391, 11661, 184257, 20010, 60116, 30320,\n    19327, 134598, 45455, 27542, 18004, 125092, 452272, 1549, 91523, 46567, 180063, 156026, 2608, 11174, 58848, 37788,\n    65907, 80194, 30490, 5786, 40775, 119519, 106241, 11323, 156297, 8425, 61495, 2617, 29675, 2425, 59886, 112582,\n    49142, 59618, 4863, 50597, 86710, 50650, 168632, 27693, 85641, 83643, 18993, 25768, 84284, 28090, 93592, 36627,\n    312804, 43381, 9887, 9402, 100931, 97165, 3311, 173330, 66805, 28935, 4963, 184460, 3201, 78102, 19126, 21607,\n    37496, 24938, 22615, 16153, 32862, 134792, 153318, 61120, 6067, 2812, 12826, 12792, 23825, 37559, 64662, 202250,\n    102694, 155488, 85881, 149193, 46233, 65383, 15521, 106982, 11358, 176786, 25752, 39717, 34208, 24510, 32464, 77742,\n    39371, 72028, 138229, 60688, 71386, 102834, 132477, 2208, 11548, 63670, 271279, 28351, 30338, 38620, 32491, 99845,\n    143885, 152266, 13252, 2825, 178663, 108097, 1775, 78201, 14897, 113573, 163346, 62292, 171129, 22183, 96598, 38733,\n    64971, 166776, 117445, 9968, 146393, 44677, 74867, 20908, 97328, 12761, 25656, 26785, 9148, 112344, 26115, 99176,\n    110121, 22437, 49547, 6180, 79320, 5835, 31392, 43328, 33377, 75870, 119860, 69497, 80273, 7325, 155219, 43167,\n    111173, 28347, 20222, 3763, 71752, 55041, 47252, 14618, 28088, 15012, 97805, 194698, 54636, 2036, 41349, 6173,\n    96604, 61530, 51859, 43782, 13361, 24334, 22668, 24792, 7070, 23441, 16789, 3209, 36211, 208475, 26242, 32880,\n    122181, 182407, 21444, 31060, 88459, 29929, 77907, 12716, 10934, 97005, 20599, 31690, 8403, 58445, 30303, 22700,\n    10336, 86731, 103115, 337709, 72556, 46788, 112566, 47684, 67089, 53548, 36874, 56487, 41387, 125985, 26893, 40071,\n    106683, 73712, 18787, 40105, 72992, 67246, 137276, 50802, 36790, 70328, 138827, 22466, 39263, 183295, 29858, 50975,\n    9322, 57397, 10654, 24364, 30383, 55799, 41600, 23584, 127295, 296610, 129078, 143558, 244131, 86397, 36049, 1085,\n    80677, 3820, 108139, 5476, 34767, 24683, 7758, 13060, 7239, 131671, 250593, 59556, 103392, 29810, 4188, 252323,\n    39404, 116877, 7651, 43600, 40338, 13554, 157253, 39196, 25978, 144387, 61211, 234, 50104, 6129, 10449, 93777,\n    9240, 356378, 274148, 4439, 72970, 3724, 147770, 78680, 62570, 115877, 40027, 40547, 36817, 224392, 64609, 34795,\n    165027, 67440, 2477, 37206, 23431, 50754, 164797, 46018, 94995, 170982, 27051, 7957, 22767, 3674, 27900, 56419,\n    18930, 60701, 41302, 2692, 84749, 339721, 61996, 111094, 80221, 50129, 1045, 8153, 62945, 19202, 8250, 37208,\n    37418, 32560, 79477, 41106, 88569, 33963, 36693, 5892, 30570, 1581, 66471, 49647, 11922, 160717, 29442, 5643,\n    114865, 82962, 95982, 132098, 22633, 22838, 94726, 54556, 28566, 205039, 162340, 33216, 16849, 35847, 221339, 94851,\n    26533, 71469, 1805, 3804, 12935, 45483, 71020, 36310, 65381, 192960, 34240, 35165, 59773, 1248, 46954, 155332,\n    96864, 4246, 388800, 16129, 57133, 74592, 44807, 442014, 38203, 42574, 80818, 91592, 26377, 36424, 65760, 977,\n    77387, 22628, 147610, 28018, 30561, 98454, 6969, 119628, 63648, 18170, 36854, 26601, 64018, 22027, 37279, 51395,\n    152934, 21153, 9430, 58760, 194742, 5330, 55115, 34158, 28917, 174111, 13171, 122326, 1526, 43896, 66094, 25325,\n    4234, 148354, 11450, 275, 18999, 112191, 44365, 22723, 68409, 8733, 57746, 96565, 75007, 14196, 108844, 29475,\n    88599, 177563, 100792, 106156, 86323, 93726, 14248, 135341, 194131, 40126, 47099, 14779, 8272, 39597, 95983, 171398,\n    65882, 28052, 10393, 47213, 40689, 22120, 72212, 106829, 34964, 109146, 753, 648, 21660, 30047, 17527, 181025,\n    5619, 145357, 4085, 216883, 9359, 186951, 24779, 53931, 24545, 36197, 223296, 62628, 168101, 4243, 107313, 30321,\n    26642, 13049, 51059, 31027, 107912, 807, 73550, 26551, 84369, 122422, 165872, 49754, 74213, 234264, 33151, 52014,\n    33100, 87183, 22365, 52500, 40013, 23302, 5652, 72723, 21404, 26107, 48434, 587, 94049, 168493, 96418, 32871,\n    70860, 31709, 25128, 443, 71597, 166253, 15670, 70994, 26341, 133675, 28280, 75491, 54756, 47955, 56028, 26182,\n    11952, 113272, 472197, 64640, 110753, 17919, 337, 50642, 22576, 142, 87371, 53391, 93210, 126694, 15285, 19642,\n    85667, 14148, 1506, 42092, 52962, 33243, 11970, 20734, 135843, 57044, 58880, 13002, 219134, 22876, 64754, 232519,\n    4257, 43120, 321573, 24799, 64526, 124728, 52579, 81472, 70831, 276848, 17403, 74359, 23021, 182101, 74597, 23744,\n    148267, 12055, 7976, 5349, 11772, 67540, 167347, 65318, 18720, 127832, 108238, 22828, 90233, 9987, 259080, 118185,\n    73209, 79270, 13775, 90100, 137742, 90799, 70569, 15699, 19961, 9087, 67475, 57872, 39731, 8810, 134897, 131868,\n    146849, 19898, 3334, 2281, 167061, 91073, 60356, 467742, 74712, 188, 53179, 137679, 92769, 29241, 9537, 132595,\n    80119, 1041, 88962, 5976, 40171, 44911, 102859, 139059, 104558, 98987, 47761, 19272, 71472, 113864, 175377, 73338,\n    10857, 23402, 23758, 1591, 139864, 5644, 4076, 118760, 16427, 134198, 18853, 20291, 100849, 37423, 22038, 36677,\n    19071, 195521, 57445, 11069, 31869, 55718, 66882, 148490, 44, 41296, 75242, 49704, 166810, 9906, 20943, 122258,\n    49112, 105667, 15969, 10344, 6408, 187694, 21399, 72742, 58970, 14867, 14376, 81889, 41856, 23225, 15042, 56993,\n    16074, 131389, 74276, 72407, 53875, 383108, 53597, 37363, 68993, 44854, 122548, 430927, 198279, 38430, 80409, 12245,\n    2981, 628, 2818, 17760, 37437, 238229, 7968, 46892, 2200, 3730, 34190, 65983, 37959, 112291, 87850, 70827,\n    6522, 20750, 73913, 111621, 41652, 19587, 2780, 58668, 25916, 85259, 18200, 168962, 95781, 42445, 102050, 7776,\n    57662, 103313, 47742, 96358, 41964, 66174, 100396, 29069, 204735, 19679, 27978, 7479, 40264, 22534, 61183, 36081,\n    107436, 58223, 14680, 23002, 101311, 24716, 124108, 12908, 5646, 31750, 40380, 14215, 232799, 102772, 14122, 96775,\n    61398, 50917, 12096, 149880, 67833, 598749, 124194, 155871, 49216, 790, 14677, 65319, 56917, 7440, 145744, 95701,\n    12206, 49405, 129269, 76199, 45732, 9767, 11058, 9047, 210885, 11051, 7392, 26307, 2130, 8132, 147526, 20802,\n    232698, 115660, 50060, 59789, 57344, 107623, 80343, 112676, 23291, 9866, 160971, 34032, 118291, 15719, 59730, 164911,\n    28975, 2659, 58046, 78480, 21854, 66209, 53863, 109085, 116045, 29021, 46481, 107552, 22130, 18764, 70254, 31272,\n    11300, 52460, 43933, 84738, 20721, 53869, 190840, 79673, 105300, 7561, 321817, 66924, 13940, 33281, 101046, 183181,\n    32176, 71878, 5678, 62924, 79535, 56646, 40303, 19559, 27703, 93042, 73368, 42187, 3670, 37376, 46440, 7023,\n    36816, 109628, 20680, 5940, 276440, 275233, 170848, 112093, 136996, 14984, 20226, 111441, 77693, 112960, 48577, 39370,\n    55707, 50314, 123404, 26570, 54281, 61372, 123391, 4857, 35928, 246740, 132507, 106646, 44241, 7196, 92258, 9825,\n    37688, 51197, 303141, 5590, 15476, 132986, 10955, 85782, 34486, 26696, 7991, 28813, 18858, 39546, 11703, 11365,\n    38185, 5716, 93555, 11925, 40121, 60002, 6985, 10976, 171384, 3887, 43394, 13337, 56346, 6381, 252336, 39573,\n    75042, 53711, 1028, 31781, 44295, 95925, 131713, 7214, 68125, 43571, 70954, 213234, 1628, 8760, 13391, 65485,\n    17320, 56038, 1710, 25248, 60803, 57399, 19839, 3870, 326, 281556, 50945, 72400, 21460, 316244, 75619, 56246,\n    98775, 481, 13513, 55765, 50427, 7388, 123519, 32929, 57908, 27124, 61316, 101097, 57467, 30228, 48792, 10788,\n    20402, 37318, 50526, 155730, 34456, 158065, 145305, 17832, 43733, 64052, 4506, 35072, 205355, 177028, 184004, 187081,\n    68616, 35938, 83703, 10367, 36892, 93186, 260137, 51934, 89970, 4985, 23445, 26755, 21558, 7948, 78741, 23376,\n    124405, 85594, 68596, 57536, 49351, 12619, 56593, 132668, 99924, 109728, 71844, 71935, 196018, 65464, 17617, 14987,\n    89701, 143773, 33997, 8687, 22701, 33258, 2914, 4436, 72108, 85610, 9671, 49067, 2327, 82988, 1361, 1672,\n    44033, 35777, 30269, 24057, 10605, 82236, 616, 15793, 13919, 47249, 112086, 116698, 9484, 80207, 90574, 33304,\n    68624, 93127, 56101, 42210, 160929, 4827, 38995, 38095, 4701, 125119, 5027, 33680, 9236, 231236, 14135, 87837,\n    23318, 70261, 78893, 30151, 81482, 14332, 1084, 74256, 27532, 46644, 79185, 3148, 62615, 6981, 55672, 31668,\n    36825, 1849, 14536, 37446, 14738, 23779, 43058, 162749, 72199, 1168, 21346, 5592, 85932, 85302, 9668, 18351,\n    57135, 150360, 2080, 228015, 77953, 34670, 119302, 151751, 31009, 106725, 84265, 45214, 59289, 74178, 113071, 263206,\n    111009, 4021, 44449, 188119, 192629, 123592, 392506, 292847, 114487, 12831, 205858, 9852, 20780, 79648, 75767, 357014,\n    97721, 18166, 21005, 67950, 33226, 204009, 16536, 2987, 11335, 66717, 144910, 47950, 17262, 55060, 15063, 2934,\n    51038, 26775, 178497, 66008, 3427, 49433, 128592, 20036, 157553, 63861, 3089, 23015, 51210, 28696, 35933, 49942,\n    71135, 231518, 99620, 17248, 21835, 176536, 20676, 16944, 38700, 165831, 233253, 295625, 36723, 13023, 52745, 10907,\n    19423, 67972, 125868, 95473, 82875, 1183, 108455, 52685, 33417, 64095, 21433, 52438, 33191, 127809, 44505, 211823,\n    7810, 2752, 95548, 162031, 7185, 91196, 47563, 61721, 33359, 17897, 23682, 42806, 178101, 22874, 49707, 199897,\n    75419, 82456, 8618, 11171, 79712, 116847, 18783, 44190, 46564, 5346, 59046, 95032, 7893, 14916, 3214, 26800,\n    24172, 121453, 34362, 10250, 17408, 18888, 4840, 68696, 22831, 13162, 36005, 32512, 14800, 62357, 41723, 45046,\n    27247, 37486, 5372, 2564, 34261, 298500, 66509, 133920, 89138, 31305, 117697, 19097, 108304, 81386, 84106, 23802,\n    46411, 63304, 946, 51417, 41777, 41041, 19501, 115864, 60743, 294354, 37955, 94165, 18116, 1156, 17937, 20645,\n    57114, 90804, 58042, 48643, 92288, 9861, 2557, 88546, 61333, 101008, 12853, 5148, 87856, 4152, 144503, 73841,\n    18718, 9789, 147565, 10846, 42085, 12789, 30223, 8993, 56352, 67203, 2448, 28215, 6052, 23540, 126319, 75933,\n    36689, 80235, 23231, 23561, 21383, 38800, 77548, 102798, 21234, 31468, 158608, 46188, 63960, 191679, 8051, 67014,\n    11185, 170078, 42186, 28827, 34777, 41930, 212079, 12421, 34750, 24111, 110344, 73918, 45171, 70826, 141949, 40063,\n    23979, 24254, 37309, 26724, 27179, 24718, 83648, 54938, 14591, 17425, 29525, 102675, 48975, 48654, 12316, 8929,\n    60640, 41709, 50168, 63264, 89812, 50716, 48632, 38755, 138583, 160123, 55579, 71829, 24230, 233277, 46322, 39650,\n    166388, 34718, 24108, 98252, 7031, 106695, 62498, 18258, 35062, 217827, 78731, 34824, 33354, 19520, 60852, 2432,\n    60224, 8587, 2836, 62955, 702, 20227, 42285, 40560, 95592, 62486, 11094, 53035, 143291, 18842, 46177, 77994,\n    1770, 9657, 107422, 172915, 32655, 128716, 25886, 25164, 156740, 119928, 165875, 85817, 11007, 89110, 33956, 12652,\n    65156, 180266, 8494, 36889, 19958, 20955, 96, 1264, 118288, 135769, 44754, 86671, 5632, 19026, 168220, 289120,\n    33569, 93821, 66144, 70635, 7687, 5642, 2714, 55445, 56636, 71545, 184182, 93133, 7332, 37389, 12643, 52315,\n    22729, 11014, 158742, 17050, 152889, 50178, 34601, 41945, 52136, 9948, 26914, 63548, 95721, 115951, 40759, 8960,\n    158258, 38938, 49232, 48325, 42234, 81523, 253019, 66128, 40978, 20048, 238048, 38760, 62928, 122560, 118532, 43687,\n    137472, 163689, 26680, 9878, 17448, 51035, 16211, 60834, 36749, 29178, 14241, 59868, 150086, 2305, 26477, 42422,\n    34342, 165341, 83279, 33894, 14257, 29928, 12743, 13957, 125571, 89134, 66712, 10952, 16507, 147839, 30146, 7249,\n    16565, 45399, 39874, 114565, 215780, 31990, 230881, 171477, 102, 196546, 44538, 10880, 84948, 281705, 86651, 10617,\n    31395, 2342, 453658, 43569, 60561, 132901, 21845, 17727, 58556, 258242, 22262, 58728, 4008, 77997, 11806, 37431,\n    30599, 81375, 109137, 185787, 114085, 217292, 97453, 169085, 30593, 60212, 11544, 102056, 65580, 2384, 91655, 4855,\n    95725, 7295, 157994, 16228, 20669, 53276, 141590, 105246, 17334, 25440, 76067, 17967, 39321, 38911, 11362, 28559,\n    63807, 21627, 26468, 85816, 40120, 1025, 15234, 58319, 69516, 66512, 124548, 75845, 78873, 22137, 46681, 51242,\n    85683, 32909, 76747, 35555, 43396, 101465, 1765, 73094, 1077, 2962, 39028, 66777, 57831, 42048, 15828, 13962,\n    36041, 63657, 52412, 5242, 58846, 2141, 5506, 219012, 134451, 3936, 182230, 17558, 17153, 152237, 22621, 49377,\n    170216, 35257, 68233, 65374, 6510, 11126, 212151, 7184, 2480, 22517, 3437, 33073, 30156, 16557, 3768, 55067,\n    86829, 91000, 12350, 148650, 66017, 79424, 70885, 49066, 28250, 21369, 51213, 34533, 11510, 3258, 18176, 18465,\n    84413, 6315, 36411, 163765, 4346, 356, 107618, 598, 13727, 285026, 162695, 8749, 14583, 7132, 63521, 184253,\n    32378, 25991, 5604, 30961, 53675, 4874, 84693, 5086, 34811, 26978, 56564, 7904, 33519, 51221, 113942, 69253,\n    6664, 125563, 22055, 220680, 102008, 742, 51930, 19494, 176108, 44424, 35123, 13025, 75685, 11759, 74335, 22250,\n    181453, 131147, 16984, 132115, 154311, 11991, 76452, 52609, 85351, 196, 30969, 9198, 74919, 2529, 56838, 71779,\n    29187, 116304, 3504, 62330, 41190, 86153, 28393, 254926, 104228, 105189, 13264, 84359, 3574, 12415, 8534, 57147,\n    10175, 188174, 59504, 60932, 66318, 16407, 107921, 17638, 99103, 49278, 28403, 39786, 145865, 8462, 3558, 43406,\n    142271, 29139, 21989, 36552, 93955, 72365, 7176, 13556, 106185, 37957, 321774, 17782, 129017, 51154, 27938, 24952,\n    1935, 39366, 2791, 33489, 41582, 56078, 24558, 9311, 5449, 218786, 27808, 190429, 68013, 36020, 86003, 29735,\n    3404, 87348, 119357, 115714, 2324, 86796, 81973, 40992, 43376, 93621, 28784, 16808, 36367, 2517, 2909, 191926,\n    24978, 55303, 53308, 205724, 60068, 3098, 21375, 64784, 23949, 26579, 63121, 12319, 80145, 39967, 97861, 6757,\n    70143, 67642, 37082, 34698, 69140, 122883, 46151, 62187, 80934, 429, 19437, 135071, 137885, 222647, 13331, 154065,\n    327, 61778, 74257, 40116, 37493, 14855, 85079, 237641, 42342, 102164, 199965, 71204, 4662, 29368, 5042, 113914,\n    122214, 8955, 13149, 102503, 43173, 5659, 163787, 69003, 307084, 63392, 171080, 21390, 81918, 86666, 36622, 24126,\n    28887, 5736, 28054, 207170, 163428, 79891, 346467, 95363, 38980, 111806, 80828, 9200, 19288, 294896, 114468, 87405,\n    111715, 141705, 7015, 72754, 68463, 48738, 243147, 33397, 101210, 37051, 98801, 82847, 20397, 4940, 185559, 18716,\n    54718, 83491, 11725, 40803, 1128, 12128, 23060, 5174, 7745, 67007, 46701, 1571, 27807, 180186, 256996, 18975,\n    16837, 7877, 212758, 250379, 15440, 87954, 57755, 24719, 124057, 83461, 258, 50864, 8874, 29038, 71289, 31627,\n    15429, 9005, 4061, 113851, 107716, 82819, 13651, 79656, 117851, 17539, 111446, 12938, 39724, 190787, 4352, 15402,\n    21070, 62708, 8539, 23777, 73853, 13552, 38810, 86117, 16285, 56400, 1718, 75342, 142863, 29033, 378, 110113,\n    180321, 32586, 23606, 26393, 160984, 207987, 23783, 8406, 16904, 24596, 47274, 11693, 46539, 60524, 78595, 48423,\n    31718, 20170, 9009, 146268, 15183, 191060, 172765, 1349, 138436, 37365, 10970, 40509, 225817, 20021, 70394, 152138,\n    21541, 66559, 66544, 89352, 2725, 17258, 91345, 7313, 3815, 115868, 8660, 40362, 4071, 103524, 39388, 118275,\n    21950, 6549, 38226, 32754, 209574, 29201, 43495, 18028, 20296, 40597, 18370, 47520, 202450, 24134, 2219, 8195,\n    69545, 38041, 136934, 46374, 19041, 159811, 84865, 58620, 846, 98749, 13569, 30714, 97246, 32186, 4479, 27355,\n    92973, 35214, 151491, 75963, 37631, 1561, 27200, 238083, 23182, 60756, 12291, 25766, 39355, 102333, 87362, 65741,\n    59906, 19538, 201575, 48772, 102938, 24438, 292580, 39964, 66366, 9004, 61379, 50548, 37622, 38732, 28379, 68180,\n    76622, 17488, 69849, 5963, 7219, 48143, 43413, 55358, 540, 58691, 29506, 19245, 52193, 48621, 5518, 13048,\n    118625, 44755, 191081, 42061, 89197, 2259, 60665, 66994, 71210, 51232, 3585, 142096, 55024, 7892, 8345, 58653,\n    463307, 65658, 64319, 137941, 136323, 53499, 12746, 43492, 6978, 95163, 29925, 60175, 5128, 7352, 41463, 184756,\n    121146, 20473, 18426, 4598, 5309, 54580, 14277, 121151, 10691, 56711, 43880, 63409, 76682, 11830, 172218, 264898,\n    32632, 66536, 81062, 31649, 25788, 92774, 60222, 11100, 63159, 9432, 224657, 25240, 53613, 152, 138620, 163829,\n    2397, 85345, 12501, 37507, 64932, 38575, 43522, 65789, 80198, 78796, 35226, 3851, 108891, 73311, 3060, 28391,\n    93671, 39663, 46142, 30982, 66041, 37281, 68157, 26553, 71872, 81142, 211527, 39747, 118119, 22695, 2859, 11066,\n    20232, 168911, 7933, 197005, 17066, 111071, 44434, 133994, 120798, 12766, 227798, 45756, 132852, 29917, 36076, 55352,\n    65281, 129800, 41958, 18944, 84678, 18580, 168093, 132621, 39997, 54092, 27740, 32354, 3770, 114118, 103242, 43918,\n    15899, 18574, 145944, 3190, 123469, 219903, 24169, 100571, 62403, 16776, 92779, 14535, 17168, 16475, 14304, 37231,\n    1712, 28218, 242754, 61688, 28980, 1318, 51359, 222657, 99200, 67989, 31772, 23932, 35351, 201251, 49041, 27306,\n    19128, 40135, 3986, 77333, 19649, 120683, 151927, 21081, 7076, 78375, 77501, 101599, 8011, 89585, 96715, 58179,\n    5378, 102138, 106793, 26051, 217276, 4197, 16297, 27014, 46721, 13322, 22806, 5278, 29629, 70632, 9647, 71519,\n    58818, 40603, 128530, 8903, 36770, 56900, 31483, 26935, 43845, 34265, 34920, 87658, 6114, 84767, 64250, 47318,\n    50720, 19264, 162514, 33357, 13117, 6705, 46696, 75032, 71054, 87004, 42035, 69138, 11903, 99854, 102328, 19611,\n    34525, 69312, 6431, 49842, 101600, 133178, 108751, 41829, 89939, 225664, 48916, 99556, 9195, 130387, 5960, 36857,\n    116724, 53518, 94002, 39077, 53996, 6945, 22261, 64291, 8314, 152785, 57588, 16522, 9091, 5048, 87671, 35441,\n    39509, 1945, 12423, 158923, 178413, 37549, 14095, 1475, 73188, 62878, 4819, 24012, 68534, 42606, 4010, 120809,\n    57497, 59564, 101758, 103718, 32701, 80116, 12345, 95834, 46918, 21468, 53213, 15665, 31200, 3867, 5140, 96013,\n    250744, 21016, 10069, 13968, 35449, 180829, 27683, 39704, 59956, 22893, 3115, 26293, 32785, 75934, 62445, 141162,\n    62720, 2018, 83638, 19949, 114012, 95006, 3330, 99829, 130935, 309272, 9565, 55874, 121727, 37017, 23586, 319858,\n    40970, 27602, 8625, 112329, 61060, 100088, 118525, 25922, 16232, 1907, 60671, 51583, 44553, 80993, 5262, 94679,\n    8676, 940, 20736, 11823, 3020, 16476, 12340, 152600, 97416, 3703, 25744, 66826, 16245, 16876, 46446, 84798,\n    74227, 176020, 45192, 61955, 75496, 23946, 23626, 40372, 26036, 6149, 11822, 30582, 16541, 41914, 82385, 232823,\n    40921, 80773, 14930, 3631, 7517, 39619, 4348, 36180, 126106, 138939, 62611, 1477, 113512, 47321, 25052, 14546,\n    118881, 29060, 23589, 128322, 36795, 18401, 137921, 104699, 267929, 36194, 172791, 18113, 4766, 188215, 30083, 332586,\n    94089, 5805, 77909, 22194, 68234, 154976, 43220, 40660, 70001, 184893, 138095, 11128, 103010, 22663, 5108, 212615,\n    8485, 5565, 49222, 54614, 26530, 42639, 16319, 55062, 152662, 105595, 21114, 22216, 10294, 68158, 10436, 86950,\n    7206, 62115, 3977, 3657, 59874, 456, 118617, 18156, 106663, 112229, 80992, 17442, 8217, 55551, 5133, 34344,\n    251927, 51153, 39364, 201321, 7816, 66803, 23057, 156724, 145664, 14276, 95705, 979, 2796, 6875, 13429, 212525,\n    50602, 26276, 28284, 3424, 19465, 52397, 46963, 31420, 51399, 206476, 92317, 48851, 637, 100820, 83349, 10317,\n    60227, 21972, 6908, 282439, 32857, 224767, 95629, 83882, 42106, 87338, 69757, 29840, 68709, 37665, 45244, 114577,\n    49188, 175943, 54009, 186746, 106158, 70168, 3358, 234002, 50555, 9221, 129338, 9562, 20118, 32923, 78479, 118280,\n    65752, 4977, 10474, 102174, 60947, 129006, 10570, 83451, 8598, 8078, 159367, 123785, 80438, 16742, 5905, 5281,\n    181513, 42402, 6977, 163136, 93179, 42191, 14968, 50421, 112401, 105440, 33456, 57347, 121611, 4221, 94954, 36517,\n    24046, 27796, 6255, 33394, 72990, 135408, 116627, 1233, 57874, 25654, 95419, 68156, 401399, 313338, 55208, 45573,\n    93124, 119251, 47200, 38196, 11909, 130667, 45391, 73904, 64964, 167846, 4137, 115606, 52036, 62214, 7969, 160925,\n    7187, 1132, 134835, 40309, 73195, 64494, 80472, 444841, 61111, 26500, 45323, 40743, 53625, 52797, 22659, 15631,\n    29739, 36706, 28841, 39147, 102836, 26794, 10536, 14845, 87305, 45874, 12241, 127587, 83833, 57183, 79722, 30844,\n    41304, 84655, 20825, 92500, 3722, 25655, 27811, 10157, 81634, 31362, 34088, 92487, 70123, 22190, 185100, 72658,\n    139035, 192523, 88241, 2078, 230490, 44528, 85638, 100198, 22088, 29982, 291233, 241062, 13865, 4445, 137791, 37835,\n    107218, 31726, 19718, 38234, 72528, 23046, 19177, 66695, 5109, 17251, 28077, 5617, 21554, 47839, 72425, 133825,\n    1486, 73065, 181275, 141508, 21768, 62971, 63082, 2512, 34200, 9904, 120309, 6392, 91243, 68416, 268253, 41199,\n    116757, 138551, 185526, 41246, 28986, 4093, 19057, 17295, 4148, 245766, 122360, 35356, 112075, 20301, 75441, 10998,\n    7977, 19769, 62922, 937, 63547, 100196, 26427, 157820, 20983, 236696, 22935, 8140, 90315, 156004, 47204, 140973,\n    7726, 45097, 52725, 22636, 23436, 257282, 105247, 522, 88389, 216031, 202204, 46812, 211666, 19693, 68828, 81691,\n    45925, 11256, 30292, 372, 5236, 167826, 88328, 232776, 151611, 5360, 82104, 18841, 80393, 25465, 18285, 20320,\n    72377, 31730, 33160, 45803, 38715, 27705, 37379, 24163, 18360, 103586, 4015, 32305, 269494, 91252, 20080, 36567,\n    54650, 7797, 57073, 12650, 31164, 42209, 6375, 261663, 105528, 81661, 106002, 2800, 5375, 17247, 43151, 4442,\n    15727, 194619, 100855, 144898, 62320, 78465, 39929, 16454, 1967, 28311, 61363, 17219, 9395, 8745, 121445, 76939,\n    80385, 162380, 22009, 54191, 44248, 16299, 122830, 48151, 74429, 78291, 64755, 14238, 44966, 2511, 17712, 67954,\n    93583, 829, 105899, 49935, 84750, 11591, 33185, 85447, 42717, 27409, 208542, 28965, 62052, 52525, 5597, 25694,\n    65594, 16343, 63224, 276188, 12475, 9331, 127507, 38522, 57287, 24128, 133161, 79723, 105548, 133695, 48917, 27558,\n    43278, 46520, 13778, 141954, 110785, 83366, 17715, 46317, 105763, 66298, 147013, 41086, 94180, 16478, 220447, 44611,\n    730, 19722, 78975, 117889, 125643, 26254, 16574, 18480, 65006, 15806, 38549, 246418, 46052, 36056, 8440, 34984,\n    30170, 3163, 59800, 4458, 115442, 4283, 41970, 33507, 104078, 1653, 22, 121158, 276486, 3655, 6338, 24048,\n    133421, 23641, 2161, 24422, 36006, 8086, 10675, 181474, 12307, 29514, 59143, 14729, 52509, 87128, 122470, 19446,\n    80852, 33314, 24573, 119864, 14237, 9652, 57779, 6612, 51851, 15284, 98871, 90581, 124466, 156831, 21190, 22015,\n    71380, 161906, 87247, 69201, 18392, 17908, 108470, 72962, 40719, 14338, 17911, 95260, 43339, 20610, 78916, 20710,\n    72451, 11315, 31448, 17263, 58853, 178878, 48111, 116002, 45497, 80506, 82605, 85880, 36300, 121755, 25215, 36118,\n    301929, 88728, 405223, 276136, 553, 34704, 212438, 49970, 78329, 922, 20711, 25036, 257130, 38295, 145369, 18128,\n    15385, 30829, 55656, 48345, 8012, 3561, 28004, 122041, 192900, 58338, 112508, 41085, 29976, 87040, 47117, 23905,\n    4336, 92061, 138880, 97407, 42083, 172121, 6256, 25192, 172671, 5, 93568, 1420, 12677, 31605, 56743, 40620,\n    6015, 78415, 231077, 31298, 80026, 13902, 19048, 24924, 170586, 32955, 176119, 87859, 36731, 6773, 27711, 24658,\n    26475, 115216, 133207, 93250, 95820, 88522, 8317, 5714, 124047, 55219, 86860, 19677, 23961, 22928, 162209, 8904,\n    225992, 359835, 56084, 96201, 29392, 96558, 86071, 93643, 55114, 13347, 8183, 95129, 82012, 2017, 123336, 34219,\n    115554, 157159, 47747, 101684, 41008, 18735, 193781, 104151, 226906, 7552, 179874, 124113, 31159, 21162, 44010, 14771,\n    51268, 166128, 31382, 73124, 77438, 92830, 205709, 12113, 1292, 38937, 13114, 1334, 2118, 15597, 69581, 14449,\n    21934, 76618, 48728, 67038, 14967, 51495, 24243, 87736, 147249, 26720, 11119, 46063, 43749, 5843, 44147, 152629,\n    133428, 65703, 14269, 45604, 57982, 28672, 55616, 45957, 8438, 95433, 37698, 220862, 132034, 39456, 61870, 4161,\n    26501, 73560, 56418, 9845, 4654, 20916, 10456, 88920, 119358, 9015, 65931, 96507, 48029, 38534, 21676, 109081,\n    43078, 34943, 25089, 6131, 28766, 23665, 5477, 10255, 16695, 67, 45778, 42443, 42770, 29534, 23733, 100513,\n    62617, 42630, 48746, 14191, 43753, 50295, 26007, 8792, 57243, 43119, 54725, 164253, 58250, 112304, 131796, 25165,\n    4651, 3188, 24831, 47748, 3705, 19540, 13211, 102095, 5593, 18699, 23666, 32005, 117571, 33541, 60584, 74573,\n    86311, 99443, 25172, 27222, 168938, 7143, 11853, 53560, 18834, 19960, 86522, 28217, 53266, 117700, 72989, 34323,\n    18721, 66450, 34346, 74056, 47217, 202002, 46269, 9429, 68582, 75458, 37823, 82843, 96652, 32549, 145144, 27958,\n    19820, 158086, 31955, 201406, 135379, 31207, 192545, 12950, 51704, 9094, 248263, 76147, 64028, 110009, 79407, 89345,\n    99284, 223492, 47966, 26848, 15359, 201137, 2861, 110507, 71231, 72297, 31851, 118777, 71039, 151051, 240855, 16333,\n    50766, 14727, 7939, 4149, 80908, 418780, 88378, 59276, 1327, 7284, 38576, 79814, 65820, 42199, 84860, 49574,\n    62596, 12396, 70598, 40117, 8648, 7994, 16836, 7630, 14047, 359699, 106878, 525, 29037, 28064, 13380, 11675,\n    50669, 74216, 103539, 180314, 27449, 56299, 172344, 19274, 7301, 246099, 32043, 19422, 36506, 129317, 6806, 30140,\n    4614, 46639, 66926, 932, 86600, 6322, 27847, 233103, 10541, 39025, 34887, 3517, 12972, 26220, 2031, 66561,\n    115015, 48658, 47596, 12714, 33845, 3893, 16165, 35237, 89983, 14769, 11962, 147224, 47018, 29977, 27979, 5552,\n    82338, 86023, 131368, 1218, 24853, 237840, 132193, 15455, 40873, 3668, 65351, 53388, 15229, 59889, 272245, 47934,\n    11858, 34347, 18038, 90853, 86981, 300602, 19343, 114181, 29362, 84921, 6095, 106059, 79472, 38015, 1206, 48741,\n    6208, 80000, 21916, 17423, 6002, 108083, 24479, 34931, 56661, 9511, 26995, 100694, 163853, 35997, 81254, 58321,\n    18919, 171890, 86877, 91341, 74503, 70477, 53412, 7027, 59281, 39892, 131302, 5864, 15947, 61301, 67466, 162369,\n    47956, 27874, 35624, 282324, 21270, 111847, 102548, 41482, 30955, 116737, 28264, 8592, 55458, 22301, 75090, 29821,\n    30697, 51709, 3041, 19208, 8038, 24634, 30467, 87509, 126428, 19389, 18814, 152686, 20701, 83474, 45832, 80891,\n    105808, 11378, 153223, 120770, 98186, 150633, 49838, 9141, 12755, 30962, 5260, 74490, 21256, 31678, 65062, 33326,\n    289838, 187831, 20595, 89768, 2805, 58535, 10844, 70085, 12090, 2451, 138068, 98544, 24461, 4511, 6754, 41684,\n    28203, 3383, 65355, 82833, 30161, 83924, 234361, 128424, 28921, 222594, 33975, 125491, 34069, 11508, 67464, 144226,\n    41850, 98703, 34371, 7901, 21254, 38398, 65651, 23549, 53883, 213340, 123269, 12028, 71764, 177701, 28758, 2623,\n    68395, 11549, 15232, 68603, 9660, 63116, 36079, 57093, 31198, 20475, 48467, 89984, 35619, 186847, 107469, 31389,\n    43631, 73867, 41949, 68841, 114250, 1605, 30564, 63403, 17588, 27680, 99533, 12641, 70325, 50428, 73426, 78379,\n    11855, 91651, 72081, 91720, 60198, 15743, 12065, 83398, 140046, 6761, 46598, 45900, 5068, 886, 62448, 148968,\n    37347, 19405, 9680, 15819, 43496, 63370, 75667, 163700, 37639, 3633, 22774, 34341, 183131, 134335, 37200, 23915,\n    7054, 14194, 12970, 26438, 13350, 285521, 25594, 8219, 104410, 91039, 168804, 138480, 149734, 15907, 33818, 61132,\n    60082, 4622, 110187, 56736, 13551, 73571, 3945, 73463, 65498, 17758, 263266, 17593, 2710, 27585, 54469, 38200,\n    45367, 63754, 28881, 3473, 12791, 98287, 31895, 65787, 4463, 94536, 24951, 36332, 59901, 28803, 52130, 86403,\n    7668, 181822, 74831, 18977, 9850, 177206, 145485, 109798, 7292, 31421, 26280, 77211, 58511, 12507, 127004, 11113,\n    147, 8729, 56208, 43066, 79926, 129937, 31345, 83947, 39915, 46146, 98763, 42566, 1337, 13192, 18323, 105163,\n    80570, 117753, 16555, 72883, 11077, 159438, 40764, 70933, 83329, 26066, 12276, 72059, 21655, 173836, 126713, 69454,\n    153482, 91585, 70644, 102558, 110483, 6764, 127864, 190133, 3961, 101798, 20945, 71138, 82402, 90884, 69669, 44753,\n    923, 16939, 59700, 164258, 25969, 27082, 31399, 43846, 6306, 246093, 51342, 6153, 151581, 202801, 182731, 56475,\n    162188, 89426, 141356, 14355, 121815, 27536, 28023, 65257, 77523, 106668, 127314, 24947, 12790, 38796, 169698, 23555,\n    10725, 44573, 183083, 42088, 62716, 43265, 105958, 32050, 44067, 50118, 1668, 3874, 6243, 318411, 16599, 1691,\n    94999, 52378, 28671, 216728, 123258, 2059, 34969, 69225, 5913, 136280, 171443, 141515, 91662, 22175, 135282, 80020,\n    92270, 1663, 4808, 4482, 3495, 34691, 5226, 109830, 108512, 17342, 107488, 11606, 123190, 100247, 29666, 146527,\n    113014, 15794, 30894, 13224, 39585, 243192, 22351, 9903, 7836, 47699, 11078, 25468, 122291, 48821, 26780, 122679,\n    75521, 81450, 630, 4895, 92900, 55074, 74293, 17441, 3563, 111657, 103102, 51613, 12318, 52370, 36191, 68245,\n    34269, 40445, 41354, 122901, 168604, 182500, 62012, 42557, 11259, 24428, 115113, 86345, 12362, 3909, 78430, 86852,\n    134602, 20459, 47853, 93879, 22577, 7659, 3688, 38555, 13349, 17381, 56715, 91639, 12493, 10895, 92438, 3142,\n    37057, 28928, 2004, 36427, 32268, 34222, 209974, 10432, 67436, 41989, 173518, 107930, 27079, 62729, 30908, 55558,\n    5828, 45031, 14902, 53546, 8204, 144263, 60255, 14520, 88212, 86582, 109589, 69356, 8064, 47449, 8505, 66558,\n    16886, 4844, 52817, 111260, 215129, 12941, 91118, 650, 20770, 6273, 73089, 40618, 62790, 2873, 35002, 14023,\n    97208, 19386, 102646, 36993, 143736, 135457, 35385, 113601, 17893, 32627, 84439, 100619, 56016, 6581, 57264, 172160,\n    45452, 111710, 203627, 70131, 24100, 322787, 1996, 35665, 70078, 22358, 90922, 83658, 4097, 63200, 58499, 14542,\n    99153, 52159, 6615, 12414, 63415, 31986, 16823, 1579, 65405, 137809, 8841, 16898, 48082, 259, 33014, 42375,\n    12260, 179850, 73667, 91389, 98882, 29532, 17311, 326251, 41092, 5928, 20742, 44964, 48019, 43505, 9317, 49265,\n    6643, 192712, 48424, 163487, 19861, 20113, 70848, 31928, 105333, 23685, 78563, 14638, 54755, 7158, 24142, 44018,\n    20774, 125255, 20331, 24280, 10163, 1285, 2336, 39851, 4299, 117269, 46714, 63816, 87779, 159624, 11731, 9971,\n    990, 137317, 108831, 50994, 74554, 162680, 23640, 131597, 146962, 170620, 34829, 91205, 21184, 1913, 63616, 18427,\n    93136, 156592, 17519, 67565, 115882, 138220, 78622, 88535, 18115, 2711, 33554, 109492, 54298, 971, 24914, 25863,\n    36363, 45715, 27099, 194995, 14299, 178181, 111488, 72395, 322385, 157719, 130787, 11897, 81843, 83999, 11369, 49280,\n    118604, 40922, 61332, 110343, 53407, 75639, 40582, 300440, 54722, 25637, 13694, 48248, 48278, 194521, 56203, 52779,\n    48783, 72627, 10953, 376, 16733, 280238, 26351, 230789, 15132, 25168, 137270, 3588, 63704, 73376, 94031, 74284,\n    19443, 159557, 9697, 39901, 13351, 119050, 15406, 146455, 3460, 29556, 75195, 37673, 102524, 92329, 47289, 98413,\n    15311, 100684, 56345, 7116, 95480, 11590, 7200, 167, 23610, 58426, 17730, 136656, 27944, 53151, 2701, 8824,\n    103124, 3017, 90744, 113588, 53216, 79736, 65940, 26931, 498, 29568, 80540, 143543, 21292, 1740, 59268, 16561,\n    180816, 42323, 50174, 40890, 52866, 10703, 57169, 4700, 17191, 4424, 93511, 49698, 166650, 26972, 48631, 165169,\n    82879, 69326, 202970, 4007, 2376, 231325, 139592, 22119, 62851, 37504, 68816, 58345, 67398, 186643, 43331, 277416,\n    53749, 15746, 23102, 17432, 4793, 151138, 48822, 54265, 48203, 198688, 14305, 54287, 2291, 18018, 113378, 123260,\n    7180, 97549, 87027, 120085, 2920, 76080, 8190, 102005, 5641, 64580, 14955, 59802, 54028, 58884, 19367, 81779,\n    412567, 85957, 97053, 103637, 78871, 29364, 27637, 141728, 4767, 30686, 112738, 130146, 42745, 12730, 105040, 14844,\n    232, 210944, 36581, 152317, 135543, 29744, 3129, 55647, 58149, 46319, 27265, 17499, 28005, 59948, 7170, 34138,\n    5702, 293047, 110892, 408, 91760, 218674, 18469, 46095, 81403, 14389, 4610, 35672, 73060, 11006, 74848, 104820,\n    118143, 190357, 20043, 105358, 141735, 5115, 27093, 45924, 123073, 52599, 29433, 9616, 238350, 78610, 24851, 58858,\n    26769, 31969, 24613, 18294, 4982, 32735, 39639, 143563, 112073, 202205, 12567, 4873, 88601, 44897, 81503, 101648,\n    81362, 34662, 85277, 17574, 48173, 21435, 221188, 40215, 39576, 80786, 26544, 64668, 81841, 10731, 37733, 247986,\n    149188, 127703, 495, 18382, 54388, 72446, 43071, 30974, 198723, 89608, 41360, 190, 33045, 8386, 31658, 19992,\n    237838, 119015, 137622, 50890, 100913, 6460, 116233, 267230, 26621, 104129, 65114, 14190, 41542, 14888, 85962, 23342,\n    23041, 26453, 43725, 71809, 45186, 4770, 46452, 53894, 56616, 221286, 18973, 9038, 109299, 55365, 19366, 26863,\n    18808, 60909, 69353, 41738, 83463, 12100, 68561, 72860, 3980, 13796, 49340, 12332, 31311, 27418, 4255, 53430,\n    18976, 45523, 510, 14224, 30477, 26581, 4530, 3651, 101663, 139840, 22709, 150861, 31996, 63923, 120623, 262522,\n    3076, 10528, 2929, 14672, 130238, 18087, 9816, 121894, 100308, 25085, 55111, 14565, 18952, 53293, 2042, 369988,\n    23674, 61789, 133529, 28783, 108293, 35477, 47119, 36448, 71049, 40015, 33055, 78598, 198442, 1833, 159937, 40654,\n    77444, 189245, 113153, 8621, 18599, 38553, 35223, 166072, 2375, 11659, 21786, 89523, 6032, 12116, 63046, 159398,\n    18454, 3678, 32521, 47626, 11411, 103527, 38896, 42946, 15696, 26370, 10185, 8413, 37080, 165583, 4331, 63555,\n    14907, 72220, 50056, 6623, 62236, 36565, 49783, 10049, 17503, 100581, 55951, 146244, 24724, 9626, 17969, 25524,\n    109300, 173965, 99994, 101056, 46459, 43647, 53737, 277968, 8347, 123521, 74858, 33829, 44762, 77574, 877, 81377,\n    222525, 123532, 30602, 43881, 53145, 2973, 16284, 81940, 61281, 127044, 63620, 9875, 14756, 114829, 19032, 9202,\n    52759, 119141, 23928, 120551, 19607, 3599, 33401, 76821, 73233, 117430, 39968, 36539, 7071, 5446, 121735, 194059,\n    15206, 45283, 6706, 15603, 65615, 1207, 165723, 92275, 34773, 104447, 8396, 32353, 205240, 164323, 13600, 60555,\n    79205, 25532, 22907, 33410, 57480, 107111, 69630, 32137, 47832, 70913, 33161, 20321, 2371, 117348, 10714, 86246,\n    1625, 11763, 17900, 268, 78457, 99175, 97940, 101092, 86660, 32221, 14041, 128504, 125080, 53744, 124263, 31017,\n    13897, 403, 31859, 21964, 5633, 111630, 5547, 77329, 17961, 18241, 84995, 25984, 12983, 67491, 62168, 47262,\n    5241, 297, 51191, 7351, 8967, 147212, 82060, 16821, 782, 11033, 82431, 62957, 5026, 43459, 77963, 203477,\n    53528, 6247, 191852, 87774, 74164, 215654, 13467, 1522, 219964, 28589, 244104, 16242, 117821, 67725, 72570, 156792,\n    17186, 15979, 26990, 44128, 193014, 35276, 57125, 16212, 166451, 68017, 6905, 77608, 16364, 53777, 75921, 76426,\n    37975, 26203, 269296, 64099, 84122, 12077, 38533, 830, 4407, 20139, 963, 43028, 38902, 42911, 37503, 83343,\n    85045, 16979, 1165, 60835, 137387, 58380, 86990, 110066, 134540, 56331, 193845, 81238, 17922, 163093, 38744, 110641,\n    12502, 56404, 34862, 26865, 125964, 12965, 111648, 25547, 7771, 27196, 136980, 9555, 29551, 107158, 57885, 18831,\n    37705, 35505, 101742, 13970, 102109, 62548, 124657, 23328, 11124, 89592, 146376, 248050, 6241, 22033, 18337, 80685,\n    29898, 11908, 216623, 67721, 106162, 146610, 21377, 15085, 91552, 42041, 62560, 122532, 125336, 102365, 121537, 142559,\n    29693, 223919, 11515, 110495, 18776, 22494, 5895, 185059, 103592, 229351, 51220, 100102, 37027, 257855, 29359, 54123,\n    36066, 106493, 12244, 79258, 32002, 432, 56205, 94836, 90182, 6726, 14762, 29391, 48938, 26864, 38083, 60364,\n    3310, 60192, 14766, 205567, 57504, 110760, 22649, 24666, 46333, 21517, 3430, 13135, 28873, 27052, 158809, 11597,\n    20529, 6695, 23138, 22960, 37137, 45574, 6545, 305877, 43423, 26153, 24769, 59844, 14501, 10430, 134352, 56169,\n    13213, 103432, 49523, 35181, 13435, 12408, 129475, 64620, 230854, 77390, 51990, 15653, 83248, 33466, 44571, 117828,\n    51481, 2187, 10559, 68019, 18021, 54895, 48247, 18354, 33737, 4554, 108595, 37288, 39767, 116707, 9175, 3726,\n    108877, 21616, 83684, 49862, 1938, 8543, 276466, 20134, 108498, 48770, 102254, 31914, 131520, 185291, 100559, 51890,\n    209, 19526, 76471, 50544, 71814, 99351, 8172, 198526, 28816, 20419, 9109, 98389, 136777, 76479, 75596, 30635,\n    165417, 48216, 120220, 25955, 211071, 39314, 24308, 32164, 2559, 146280, 43403, 9233, 17947, 90585, 1786, 86920,\n    125662, 2457, 64741, 32152, 32918, 122882, 78538, 44001, 31723, 56426, 23375, 103172, 88177, 145697, 52506, 49319,\n    68016, 31664, 41488, 18486, 110400, 7030, 28241, 986, 109199, 19900, 42147, 56864, 65287, 49183, 7858, 24000,\n    30453, 840, 16673, 25907, 68916, 89927, 6309, 158335, 36407, 199737, 130464, 13137, 59603, 201778, 195292, 21015,\n    42466, 179062, 172561, 89492, 11075, 180407, 31868, 72493, 20998, 60217, 9865, 19530, 39274, 130266, 54539, 21623,\n    12535, 13505, 40641, 73375, 4087, 85633, 2153, 3117, 70680, 55788, 92096, 47509, 98493, 37490, 271936, 151475,\n    3032, 16171, 96642, 34106, 78425, 125761, 19591, 3366, 19316, 54508, 24183, 50786, 194248, 91528, 33253, 34622,\n    108355, 41741, 705, 3814, 3883, 108929, 13203, 67831, 10142, 59754, 68208, 29128, 84820, 56880, 38794, 24972,\n    48571, 40821, 40476, 18137, 164254, 24064, 236309, 79181, 11282, 395, 39169, 2013, 51587, 28551, 9645, 701,\n    109513, 115899, 113566, 12762, 62045, 58322, 103726, 41343, 40866, 244102, 143816, 2490, 70346, 40973, 52618, 15412,\n    30720, 104315, 38917, 42027, 93676, 17513, 107418, 20706, 123890, 13399, 97727, 24044, 87962, 65606, 44250, 98044,\n    65276, 74790, 101473, 19350, 91570, 1326, 87790, 172042, 7577, 100813, 86896, 85891, 41512, 108130, 27794, 14875,\n    71431, 12835, 156250, 58135, 3759, 22476, 42176, 115873, 34686, 56523, 73643, 108505, 51491, 20838, 12721, 32863,\n    45700, 29496, 13700, 34294, 55360, 29206, 155942, 123812, 7706, 163234, 203, 132720, 49358, 144431, 8130, 175788,\n    35818, 3270, 76832, 25710, 54095, 97274, 28779, 94621, 74396, 19092, 128242, 58067, 20885, 14670, 93255, 15107,\n    63291, 23654, 126900, 129421, 59294, 262659, 9798, 3251, 67344, 28600, 44629, 50672, 29072, 26999, 31526, 23183,\n    49175, 165843, 175455, 17282, 175411, 32022, 45989, 30298, 90690, 78118, 83156, 23749, 35636, 31317, 7069, 80381,\n    94561, 133756, 14960, 97404, 6138, 41065, 78041, 32843, 16601, 34123, 9559, 146529, 123377, 96395, 54441, 42012,\n    84257, 123541, 10745, 22139, 106459, 11720, 150883, 172651, 154996, 110538, 4728, 53447, 25704, 2009, 71152, 119354,\n    21166, 66604, 1429, 216162, 8637, 122250, 63520, 27180, 29172, 36124, 276428, 107787, 77184, 4680, 14952, 104903,\n    24418, 14793, 51561, 52931, 8371, 26342, 48526, 7118, 92066, 67280, 40653, 8847, 34597, 105438, 14198, 50163,\n    61188, 146286, 50315, 41205, 170829, 161496, 585, 197359, 95056, 1687, 365794, 91349, 48507, 5804, 49263, 5146,\n    104902, 96365, 117343, 132222, 46084, 96919, 16875, 8073, 262381, 79982, 52663, 13928, 16056, 153908, 15145, 109256,\n    132308, 18763, 24904, 167644, 13618, 40750, 18686, 147124, 114709, 150038, 52849, 2938, 12568, 48617, 8778, 5459,\n    44202, 44591, 74914, 17183, 248689, 13878, 7822, 80060, 23116, 194037, 18487, 2067, 7798, 43077, 33678, 244028,\n    31320, 74273, 2794, 19466, 8218, 36280, 183997, 48124, 19416, 29656, 19280, 98734, 7715, 18311, 30701, 133602,\n    150307, 126956, 7378, 2933, 79903, 13178, 12593, 86571, 26604, 92446, 13574, 44205, 65699, 427599, 21118, 8245,\n    14407, 27877, 47936, 33542, 7916, 26460, 117762, 21596, 37818, 2249, 127359, 209394, 60044, 47677, 308089, 36791,\n    154971, 31417, 6998, 150042, 174360, 12255, 43009, 29335, 48739, 3912, 101398, 53340, 2580, 146939, 151295, 45360,\n    125275, 15273, 45383, 27456, 48761, 23314, 8750, 60801, 85823, 104759, 27894, 123685, 66968, 39480, 26917, 55290,\n    83305, 2696, 98390, 57569, 145853, 340733, 4919, 20024, 52268, 30884, 7413, 203685, 70989, 112855, 4129, 50536,\n    349518, 68205, 332641, 159581, 135361, 236026, 37563, 176404, 64899, 6578, 122033, 63871, 1850, 85234, 82089, 66124,\n    74145, 121098, 107351, 12687, 36881, 117334, 13136, 14698, 85933, 93866, 18047, 32620, 310, 15094, 46000, 88451,\n    23632, 36645, 27940, 87618, 80520, 58892, 20976, 27702, 140090, 96075, 67841, 103292, 238964, 87778, 107338, 17019,\n    83427, 67522, 7302, 8261, 47570, 116787, 8730, 80484, 61772, 174422, 56005, 131193, 52875, 14588, 28471, 59817,\n    9586, 15720, 158155, 51307, 109734, 15196, 11025, 59331, 3884, 52626, 102602, 84797, 25158, 27314, 4437, 20488,\n    76214, 189248, 35023, 114952, 157376, 2827, 62439, 102878, 129749, 36405, 10329, 109339, 108633, 36662, 1254, 13267,\n    5470, 87105, 58004, 15397, 10434, 159667, 21864, 52022, 179464, 3013, 32147, 31496, 116832, 18494, 105502, 129227,\n    107267, 50033, 13481, 9954, 24267, 22141, 16257, 116154, 36185, 950, 115685, 11305, 176708, 2048, 178671, 112573,\n    287867, 162328, 497663, 95170, 50979, 193861, 50987, 30368, 136257, 31830, 46549, 15119, 169876, 23788, 17462, 249887,\n    57377, 1949, 35448, 14791, 43769, 210091, 3783, 34612, 282103, 88380, 245190, 5457, 20491, 98908, 11402, 86899,\n    117916, 16028, 162584, 60644, 320177, 156096, 31065, 55876, 22000, 77655, 9992, 23397, 13757, 317623, 63978, 215255,\n    2443, 17648, 93231, 27388, 104529, 93807, 55505, 140477, 12046, 112040, 70887, 40152, 94365, 112353, 25063, 114679,\n    266061, 71248, 119555, 15589, 2244, 617, 14129, 211431, 70110, 100652, 7777, 4383, 85911, 89221, 21010, 120615,\n    58357, 86405, 37554, 41647, 18, 15143, 69662, 60491, 14714, 186134, 148344, 42347, 5410, 168175, 44535, 42449,\n    343894, 129417, 99682, 20659, 27272, 140483, 63455, 222159, 17536, 13722, 42637, 62324, 11976, 114691, 148109, 2283,\n    32057, 182393, 4295, 147364, 33705, 2075, 44303, 30274, 28331, 63740, 69740, 29148, 10346, 44862, 33716, 73937,\n    153333, 12930, 38784, 247159, 2515, 41053, 20256, 83368, 256189, 54639, 115240, 5096, 24661, 175419, 153552, 26516,\n    141, 138176, 63885, 34115, 47222, 55709, 2765, 28479, 38875, 236608, 12229, 22921, 77291, 54426, 45388, 2860,\n    57787, 114579, 295139, 105782, 17826, 71066, 19119, 54364, 69385, 16568, 12323, 28057, 33346, 34919, 124763, 155533,\n    101386, 31644, 8627, 49001, 303600, 29868, 63213, 9103, 77280, 71333, 9696, 138789, 37059, 24823, 5057, 21352,\n    32368, 114208, 56803, 19424, 10445, 58514, 8661, 209508, 26187, 171838, 10460, 63454, 14016, 122504, 41328, 21329,\n    46618, 32493, 38225, 7855, 31763, 7945, 29876, 8734, 6438, 24205, 97490, 139977, 130740, 47323, 33195, 85390,\n    57194, 13813, 60600, 21313, 96251, 7699, 27584, 170521, 139271, 1363, 4402, 336738, 129223, 84983, 69150, 13147,\n    3590, 163929, 207225, 155260, 55916, 20288, 4503, 8398, 98490, 11773, 27512, 37113, 84976, 86558, 28365, 11756,\n    116005, 182148, 13733, 115313, 47644, 67208, 85069, 9347, 14995, 226141, 14704, 101835, 41159, 35314, 13113, 63526,\n    214039, 29978, 50446, 83339, 17440, 129441, 72522, 118641, 97816, 24907, 73844, 15717, 118884, 167255, 96509, 162793,\n    30847, 36849, 51297, 78974, 77793, 10427, 1873, 2972, 9999, 35074, 28190, 64297, 146836, 46298, 60038, 163007,\n    108919, 61219, 2403, 75022, 127339, 4233, 110389, 69022, 9833, 128097, 88016, 79390, 222936, 22570, 94657, 28462,\n    56956, 38803, 81536, 30474, 152794, 19566, 16481, 147408, 74574, 81895, 20731, 1918, 1366, 76367, 187321, 54494,\n    24366, 21690, 61696, 33283, 107477, 77499, 31112, 414383, 74362, 18463, 218441, 120929, 59848, 258629, 201924, 69269,\n    454, 19989, 13054, 59894, 3623, 58908, 20681, 35723, 78523, 102680, 38988, 184112, 108087, 50944, 132704, 52966,\n    21699, 18860, 96349, 201411, 82697, 85395, 95658, 5093, 6427, 177894, 44191, 32755, 26961, 155739, 6249, 31310,\n    81030, 26574, 84311, 120155, 86730, 113535, 7424, 48888, 13516, 45747, 98098, 20077, 183995, 81945, 43210, 26704,\n    40420, 75831, 45648, 11180, 6855, 57927, 65528, 124096, 34851, 2598, 156633, 107572, 127352, 38169, 123845, 60142,\n    62722, 105584, 232364, 23211, 68120, 1601, 22169, 89299, 747, 258039, 80572, 7258, 152249, 11862, 101204, 8834,\n    121434, 33761, 19175, 133142, 46343, 40178, 48723, 3589, 41977, 30210, 38868, 62257, 10087, 82658, 87827, 90646,\n    16415, 47552, 351723, 28298, 72225, 91146, 272760, 1701, 11295, 1652, 109651, 300747, 51863, 198800, 29446, 11794,\n    32345, 37538, 22356, 33102, 37590, 113544, 37970, 11478, 179743, 25454, 103417, 59905, 221970, 105196, 145604, 7817,\n    164809, 102360, 16974, 75840, 255333, 56902, 6659, 1954, 645, 59400, 67769, 7689, 18675, 5215, 13793, 20536,\n    27852, 3387, 29523, 259718, 16860, 94625, 43143, 29245, 15848, 233581, 22685, 63631, 78557, 22836, 133302, 84513,\n    1348, 51826, 47129, 98836, 58284, 1830, 1749, 94642, 10933, 6145, 12506, 10975, 13879, 103781, 144434, 10268,\n    28409, 32346, 52968, 121567, 107374, 77268, 23686, 35097, 10501, 155275, 15303, 47136, 21102, 168741, 55332, 90385,\n    15996, 84817, 681, 137803, 25054, 142275, 6163, 38175, 8056, 124296, 240642, 65621, 4934, 178205, 16101, 62803,\n    60964, 18230, 100622, 76465, 44689, 14545, 9543, 47514, 16852, 93380, 28048, 12047, 107106, 37575, 101485, 77047,\n    57326, 34819, 96137, 76916, 6469, 46264, 115983, 75768, 87668, 69942, 13027, 165, 8373, 114231, 26434, 52844,\n    42799, 182044, 23580, 146254, 38081, 43236, 33883, 146220, 382894, 14606, 46035, 36481, 166621, 35417, 95382, 2957,\n    59384, 60428, 36358, 66343, 75378, 22267, 22950, 83528, 17577, 56474, 25285, 4619, 179691, 75355, 95836, 53295,\n    34588, 171410, 4487, 14679, 84208, 44015, 18562, 109133, 54101, 11531, 86052, 174479, 303157, 28095, 9953, 35642,\n    14564, 39802, 16145, 77606, 117406, 53038, 121117, 53624, 22062, 1212, 7632, 127157, 237292, 189087, 10478, 127345,\n    102515, 181997, 86752, 87623, 10966, 121602, 68783, 68681, 83042, 114380, 138349, 191305, 67176, 50085, 39016, 1427,\n    42384, 1412, 67118, 122616, 72389, 25260, 2237, 13576, 137346, 19938, 20304, 2191, 68759, 5373, 61364, 238507,\n    75814, 23931, 69565, 38993, 131741, 38364, 12528, 87762, 5679, 129853, 5310, 186831, 32653, 90338, 260176, 389531,\n    108118, 26843, 43985, 50175, 30563, 25106, 56965, 18130, 140428, 4542, 165503, 117991, 24219, 229605, 1819, 129663,\n    1240, 3797, 76093, 18398, 71339, 51919, 93043, 27175, 47060, 216257, 6483, 35051, 1217, 16512, 80798, 129064,\n    13225, 69339, 8548, 237079, 72298, 2575, 34280, 51379, 117910, 55671, 53345, 247552, 29486, 39328, 140821, 34681,\n    57045, 60177, 5004, 90269, 78522, 2479, 322607, 48474, 61296, 13057, 31558, 4678, 59271, 6699, 27044, 31988,\n    35944, 12503, 83480, 4389, 136508, 3781, 114121, 70279, 4488, 155829, 42214, 2898, 68191, 75695, 305850, 45041,\n    74344, 106509, 30087, 17429, 93292, 12477, 290, 23080, 114802, 35714, 18751, 26554, 105424, 17775, 2144, 2412,\n    100610, 65192, 113975, 52975, 180272, 135050, 129815, 76238, 106483, 21440, 63186, 4260, 46189, 9711, 28249, 4169,\n    23429, 23390, 8324, 141585, 63809, 67668, 38457, 38063, 39226, 59972, 1189, 203916, 62368, 14403, 16949, 61767,\n    85801, 1739, 40147, 35049, 76757, 33124, 62102, 15780, 103593, 103009, 53484, 22952, 67973, 114645, 6566, 5245,\n    50462, 7601, 8288, 3513, 194571, 80276, 1908, 54592, 5124, 58571, 2513, 6800, 273997, 193904, 1119, 17991,\n    117245, 2508, 129156, 82366, 26278, 71465, 63341, 56943, 39662, 106116, 94966, 156875, 9736, 2204, 122308, 94418,\n    27134, 1280, 24539, 49022, 45314, 3764, 50904, 46424, 30699, 28087, 293839, 9400, 33646, 40165, 822, 147499,\n    50263, 116179, 29085, 11863, 31314, 5578, 17797, 5104, 12454, 1604, 15342, 219206, 10232, 67800, 94261, 25872,\n    13565, 90339, 78971, 75377, 26649, 41184, 47695, 11514, 35369, 20767, 14227, 41953, 309396, 148270, 147938, 33074,\n    14453, 27499, 109019, 39018, 25738, 240196, 158931, 52820, 8612, 95853, 21524, 137010, 84901, 70869, 70021, 116794,\n    48404, 38771, 6732, 1070, 70990, 187297, 49140, 5238, 576, 3564, 253975, 16027, 16483, 2811, 37775, 19034,\n    25259, 4053, 2000, 70083, 95774, 19713, 33431, 92703, 91314, 42381, 288770, 48194, 95985, 3991, 77418, 13406,\n    241328, 245086, 56533, 35275, 62725, 9246, 51924, 70181, 95331, 16163, 31410, 79016, 39312, 120878, 119371, 275987,\n    80124, 27712, 9186, 220, 23598, 146167, 85209, 68238, 282190, 57048, 31273, 30555, 80913, 17594, 75779, 59160,\n    135002, 101219, 189377, 29225, 96735, 60126, 62522, 104000, 27620, 86814, 17240, 147533, 11001, 5425, 43682, 410,\n    49460, 87270, 69480, 46315, 59448, 1816, 76201, 9431, 11788, 87960, 29063, 65539, 47347, 11678, 33846, 7008,\n    196704, 9895, 6753, 8633, 120892, 59970, 572824, 115934, 6646, 202559, 892, 48351, 37611, 251282, 57823, 67263,\n    57750, 26527, 34485, 90747, 7685, 88370, 6144, 64182, 1709, 41969, 21458, 62327, 181657, 49247, 225330, 122600,\n    114574, 107124, 85361, 111833, 63243, 71420, 15655, 191178, 72430, 18063, 51425, 54002, 12364, 53225, 86557, 18193,\n    97580, 41232, 138398, 67821, 128724, 8944, 233212, 101353, 52099, 42127, 14006, 120107, 32789, 32132, 3498, 18123,\n    33758, 56058, 5779, 128760, 59888, 98869, 18445, 84702, 51911, 13234, 218379, 20093, 39031, 8074, 70195, 20708,\n    23462, 24355, 131384, 60189, 26390, 10403, 41060, 7140, 10781, 49410, 42261, 87202, 82566, 41663, 43105, 60276,\n    2768, 5733, 74176, 28329, 2297, 145430, 131632, 83615, 122915, 105441, 655, 224102, 5284, 136426, 67763, 16294,\n    188511, 32538, 61049, 27893, 3394, 13951, 159099, 28542, 17930, 145360, 9492, 190122, 32285, 78855, 26440, 13570,\n    58648, 73908, 4239, 124561, 2444, 74172, 53131, 11468, 10794, 73566, 11623, 35343, 64710, 30481, 4163, 10328,\n    38309, 29901, 10538, 154377, 76132, 92405, 24839, 11679, 3465, 13449, 11637, 7824, 2337, 57754, 1260, 14458,\n    41118, 19878, 38661, 13416, 159180, 37074, 163164, 54137, 28627, 52134, 184900, 8520, 40385, 29546, 30502, 22386,\n    66527, 107458, 6850, 24022, 47983, 30603, 35083, 8934, 304066, 39500, 9, 28261, 33026, 77251, 9374, 44833,\n    116312, 34990, 29236, 63563, 125639, 135405, 165398, 159055, 55690, 88141, 69643, 236964, 31983, 25572, 20436, 36746,\n    60896, 31850, 16179, 11828, 5888, 3043, 66368, 9750, 31167, 7915, 53111, 36430, 1333, 64344, 93659, 20061,\n    60596, 180191, 51630, 6792, 30244, 43509, 101058, 22409, 420, 44210, 109783, 43223, 27030, 72477, 72831, 32679,\n    29235, 7675, 47556, 12258, 39907, 149412, 84926, 118247, 24692, 71717, 105038, 86009, 45941, 41189, 89453, 29856,\n    52543, 30627, 226798, 67303, 59230, 67415, 34408, 1367, 99685, 16867, 128419, 52147, 4111, 125381, 117881, 16173,\n    44093, 102224, 31575, 23234, 24870, 83790, 127407, 239098, 3200, 994, 1255, 100903, 242275, 117266, 55116, 38205,\n    16140, 29662, 11307, 40414, 208793, 123355, 56470, 4862, 75600, 30119, 58218, 70828, 24075, 26974, 7802, 192353,\n    4851, 5475, 78720, 66596, 3409, 28573, 64396, 30381, 30690, 59859, 88256, 5406, 99945, 103064, 34463, 37727,\n    24238, 86643, 60088, 4057, 23741, 5967, 162904, 38240, 28356, 93858, 25510, 122879, 6897, 3278, 7057, 11971,\n    4400, 35461, 211413, 21395, 59615, 39471, 87233, 55795, 128426, 3051, 22470, 41950, 14705, 3974, 180108, 80476,\n    78442, 204996, 91987, 15634, 67610, 139015, 142373, 35611, 51134, 10387, 4353, 153456, 57749, 181039, 14183, 68447,\n    151532, 21107, 36452, 20551, 3186, 46247, 46383, 129666, 88736, 140662, 146243, 2066, 8360, 7978, 64818, 106963,\n    17896, 47801, 10723, 114821, 223295, 74192, 3293, 3393, 16987, 74064, 11277, 91622, 4270, 29828, 27951, 387869,\n    103235, 1374, 61988, 120083, 477, 145892, 128378, 11779, 211263, 61354, 18221, 17869, 46530, 83061, 108538, 157981,\n    90608, 67199, 95080, 49064, 195814, 12302, 66307, 10348, 231346, 160732, 112859, 63633, 146558, 21271, 31037, 198802,\n    47622, 12862, 95710, 3910, 77850, 73961, 85585, 34752, 61000, 4082, 24595, 103679, 71107, 8208, 79568, 150019,\n    16615, 24961, 139857, 32664, 197366, 4559, 54735, 32696, 4126, 162019, 75698, 13916, 70108, 159638, 19834, 9349,\n    24675, 175560, 49643, 18206, 52459, 27992, 10809, 88865, 401975, 133172, 29000, 34558, 30915, 3658, 25834, 42430,\n    36562, 125265, 18182, 10155, 40149, 97082, 208980, 19575, 60853, 90529, 66545, 9600, 789, 46420, 2317, 88593,\n    55595, 98980, 115302, 5742, 169155, 1073, 177901, 3472, 11189, 63711, 78643, 65472, 50459, 127979, 93, 42202,\n    67053, 21720, 157650, 11145, 141378, 42033, 22824, 85705, 79114, 35584, 15974, 1510, 54172, 28562, 12451, 104226,\n    19190, 97151, 73024, 20948, 5151, 81741, 21499, 29006, 84183, 198074, 54003, 45120, 170125, 26240, 35177, 28389,\n    64863, 79974, 60778, 176915, 232183, 45342, 2038, 80253, 41564, 40703, 32689, 5430, 100689, 5366, 23007, 134279,\n    14266, 26712, 73993, 24934, 64242, 52113, 102887, 61801, 46415, 201049, 54251, 62133, 122757, 164883, 30815, 139966,\n    2319, 30842, 766, 13362, 10287, 134518, 86111, 81665, 82440, 28333, 43019, 18963, 8804, 161944, 23439, 102144,\n    101145, 80029, 39052, 248708, 30350, 117340, 11878, 128467, 974, 138625, 63961, 5237, 74778, 61834, 67040, 43814,\n    13690, 65947, 33809, 232476, 115258, 181745, 28824, 94013, 9510, 10246, 93722, 81976, 7217, 114383, 3493, 16014,\n    69045, 72692, 12145, 80981, 9507, 6692, 1620, 60820, 330444, 35474, 33962, 4797, 7053, 295463, 46445, 27026,\n    12491, 77988, 49524, 35675, 90947, 29114, 166705, 101385, 133782, 32704, 6186, 84595, 176031, 185623, 45966, 151302,\n    63069, 1699, 107491, 947, 15458, 74452, 196212, 6046, 10498, 12163, 10239, 35191, 243951, 9277, 9090, 29539,\n    54460, 22820, 26514, 112549, 60372, 51753, 48756, 21812, 70861, 260326, 41, 44222, 10441, 16961, 48148, 138771,\n    216194, 5914, 52153, 53400, 212036, 56519, 26245, 10117, 45888, 15294, 138019, 90913, 26368, 43842, 42111, 23348,\n    6082, 194845, 161089, 156206, 51546, 11647, 30759, 302912, 262094, 8635, 78876, 26535, 35283, 54183, 31183, 85484,\n    147873, 12989, 5197, 6356, 72894, 65347, 20150, 27370, 73787, 1493, 45918, 12366, 190217, 20724, 13858, 10981,\n    67449, 81213, 7553, 14115, 72242, 271517, 11842, 48310, 88743, 143726, 22177, 3290, 243231, 58452, 62937, 12592,\n    1654, 40066, 33477, 13751, 9921, 128442, 15868, 7106, 75236, 83773, 10775, 36938, 10482, 170465, 17368, 17469,\n    161508, 32752, 98340, 800, 19824, 264456, 3901, 87319, 2867, 26782, 9630, 113102, 185815, 24197, 44584, 86366,\n    40224, 3636, 140916, 31731, 267731, 9567, 53678, 72984, 29389, 27963, 17106, 50282, 284911, 60170, 8322, 12608,\n    23374, 89652, 5268, 39044, 229766, 8869, 151350, 31436, 177342, 12269, 183212, 120418, 116270, 2843, 78888, 69192,\n    7865, 184099, 1086, 129897, 18383, 70508, 20242, 18508, 229924, 124569, 35749, 50589, 55626, 9884, 83115, 40971,\n    30671, 18135, 14452, 38861, 17844, 201826, 5549, 26413, 17189, 13561, 38539, 10679, 143331, 3314, 36785, 171194,\n    49685, 187713, 67506, 4618, 104039, 17060, 195080, 50648, 33159, 19238, 67559, 134840, 28599, 157523, 17130, 38064,\n    117398, 94355, 31918, 13575, 34538, 40326, 13997, 3494, 348283, 62481, 26862, 3603, 104426, 244363, 153709, 112487,\n    304612, 199674, 41239, 35545, 54869, 293005, 28223, 26277, 26899, 4533, 18518, 15492, 38587, 80488, 70485, 160395,\n    263, 60162, 11382, 222152, 4696, 250751, 51921, 182609, 10707, 48463, 46243, 1227, 49111, 111564, 46502, 33342,\n    56846, 68541, 63559, 858, 139927, 16654, 229375, 76759, 26478, 33205, 95828, 23399, 92945, 2637, 35630, 28470,\n    143992, 50214, 14174, 21456, 166191, 65665, 1711, 21594, 78019, 97599, 111701, 36, 147151, 110246, 189022, 43021,\n    30397, 40757, 131935, 42065, 73335, 48039, 26596, 28984, 15102, 2361, 7421, 202167, 69744, 43766, 52826, 3642,\n    83304, 33873, 75140, 63169, 192389, 36551, 92748, 13039, 123959, 233220, 21738, 84447, 77230, 20228, 187852, 19095,\n    25799, 92136, 108774, 29237, 53947, 2299, 118106, 2687, 8830, 42331, 202924, 33667, 2023, 73763, 30704, 19363,\n    19779, 16737, 35629, 48081, 24068, 101013, 162338, 291912, 13749, 24745, 328289, 167679, 70086, 48299, 23306, 16732,\n    17801, 43322, 54589, 3586, 63653, 43624, 53474, 925, 109177, 251316, 43805, 13082, 19511, 86565, 142182, 92461,\n    17117, 101033, 103319, 64589, 4022, 4351, 235897, 5352, 82705, 107142, 46391, 156084, 5860, 61365, 10558, 13045,\n    7717, 18357, 33922, 12590, 33065, 6928, 46993, 783, 46937, 67846, 8952, 26295, 6107, 119656, 18799, 17458,\n    50747, 4229, 179559, 112727, 118080, 20683, 41464, 125468, 51560, 49749, 44231, 7359, 35339, 62988, 136487, 67015,\n    5208, 29150, 24956, 105186, 48858, 6143, 18097, 6972, 16404, 73489, 58742, 97196, 36357, 164616, 5834, 32267,\n    13746, 147733, 15113, 132091, 34127, 106298, 39729, 106426, 22294, 9780, 15602, 36213, 71502, 42808, 66802, 599,\n    60755, 5851, 39120, 67363, 108623, 126368, 72770, 91263, 32486, 30596, 151717, 7951, 52002, 43103, 11768, 68942,\n    40901, 39344, 24037, 127500, 116890, 48403, 16926, 86750, 17745, 48648, 159545, 34460, 58419, 5634, 114317, 67865,\n    31462, 23352, 24010, 98185, 125708, 69686, 68337, 13610, 26271, 70691, 2980, 4768, 27225, 102402, 75453, 28106,\n    8104, 6931, 1176, 6274, 6475, 112635, 22498, 6176, 238686, 26832, 28893, 90319, 14441, 15682, 15087, 39517,\n    45270, 109134, 104440, 45965, 47645, 81772, 7876, 52683, 87720, 12898, 4505, 185665, 2769, 113401, 15664, 57592,\n    105229, 137381, 97059, 119268, 6876, 43309, 33886, 128363, 35476, 144249, 67013, 143587, 83367, 25703, 91436, 59347,\n    53236, 2289, 16519, 19844, 46309, 58558, 99834, 23313, 218816, 231303, 36388, 51333, 183535, 109792, 139277, 54306,\n    90139, 18235, 8275, 32710, 37677, 82464, 86025, 92204, 88842, 117723, 37570, 128723, 234242, 76350, 73795, 34896,\n    148247, 58424, 11105, 11744, 45746, 63372, 17118, 49772, 199520, 81902, 38004, 22911, 33752, 3125, 1995, 53792,\n    4689, 26909, 108150, 146062, 69674, 41811, 161444, 84855, 8999, 28561, 16731, 93937, 3189, 21967, 24890, 22943,\n    1356, 145300, 51569, 28802, 517, 118679, 31703, 40607, 48098, 108854, 25003, 10233, 73969, 177495, 5248, 24516,\n    215347, 146192, 48712, 60626, 69188, 40735, 5866, 586, 101541, 6509, 47590, 52129, 5969, 222045, 110933, 25733,\n    24223, 65339, 62812, 2414, 155418, 35819, 16022, 78423, 43138, 20995, 128255, 240673, 46745, 236093, 72176, 57085,\n    97841, 61248, 107, 36068, 193177, 105427, 55726, 215229, 20446, 47228, 100420, 87091, 14429, 121708, 23605, 21157,\n    187721, 21880, 2997, 203976, 99166, 95068, 25877, 7724, 98925, 83401, 4829, 13182, 18229, 13718, 239662, 38653,\n    116505, 153497, 30589, 89029, 38962, 181302, 43853, 78872, 180301, 4786, 248240, 7401, 106136, 112590, 77745, 19731,\n    60880, 77789, 125748, 135487, 5975, 48627, 34084, 12419, 215770, 47557, 254582, 10364, 106495, 21856, 67539, 88981,\n    38805, 21428, 48732, 42316, 12149, 16078, 52808, 25327, 51322, 33850, 51147, 12253, 122354, 46077, 56483, 254553,\n    115417, 81834, 150991, 94662, 86668, 7381, 12841, 100650, 18218, 15741, 22372, 68294, 50705, 15535, 84660, 61887,\n    22553, 72299, 31361, 24824, 17743, 46820, 64288, 31582, 77006, 111674, 116384, 30760, 80920, 86149, 77192, 51979,\n    79691, 60342, 122805, 103800, 240873, 160744, 233114, 78962, 54920, 8608, 3484, 316104, 72548, 24337, 5088, 230040,\n    21926, 10172, 36838, 26, 86221, 83458, 102176, 12062, 17571, 41929, 41170, 28428, 68239, 41750, 103930, 2634,\n    18313, 53019, 34825, 97837, 63115, 24606, 73157, 152474, 14715, 91439, 37033, 109806, 140259, 30668, 174760, 380,\n    135597, 95673, 136073, 65073, 134249, 13829, 17279, 122305, 4420, 46444, 10237, 64848, 203623, 70728, 10349, 182885,\n    65075, 24519, 25783, 40318, 34139, 22222, 63394, 55266, 102764, 41422, 20126, 65100, 90408, 53640, 35128, 48932,\n    11192, 38935, 96839, 34782, 39492, 19396, 41332, 6250, 5511, 19492, 51304, 25936, 104466, 54099, 73771, 86115,\n    5080, 7669, 30891, 111700, 13931, 25276, 72289, 135447, 14820, 258641, 25265, 31005, 281179, 75286, 393, 95359,\n    14623, 13584, 6680, 101227, 80173, 44933, 76666, 54542, 13244, 39348, 458, 25379, 109451, 134348, 81143, 6959,\n    65554, 12027, 51311, 8716, 57589, 140731, 28467, 23316, 17272, 30458, 25980, 55229, 77197, 83798, 28302, 114784,\n    7428, 34548, 26241, 14712, 39336, 103304, 18928, 54080, 12870, 334, 87722, 15208, 16895, 142098, 114262, 39820,\n    83913, 57817, 28682, 7721, 14900, 108672, 11250, 62246, 42849, 415188, 1724, 26555, 24549, 25505, 26443, 107450,\n    145899, 61035, 43528, 6901, 60726, 65906, 267741, 21338, 147590, 42079, 18924, 73017, 135236, 15393, 5206, 4026,\n    84185, 1531, 5988, 113890, 82647, 303391, 7386, 69844, 71611, 189865, 76523, 31877, 13315, 19314, 198575, 32821,\n    1928, 67641, 25913, 104475, 103489, 3297, 70391, 18406, 15446, 113347, 19295, 93790, 27856, 1792, 167471, 116449,\n    8541, 4408, 41757, 63233, 25765, 86680, 64501, 27034, 24816, 34975, 6079, 4486, 49693, 36229, 16917, 21581,\n    62426, 27862, 11612, 54284, 35702, 194034, 355, 24277, 48262, 87411, 70504, 310164, 118018, 12516, 47559, 43502,\n    57433, 107139, 9290, 66533, 80863, 14634, 34312, 91725, 28606, 21342, 67241, 72355, 43244, 375789, 37402, 174015,\n    105070, 8342, 44167, 67494, 1890, 16365, 11723, 271002, 1865, 47918, 8350, 45564, 27742, 25110, 125803, 8553,\n    49504, 81925, 62211, 4534, 15491, 19011, 80373, 206920, 667, 102405, 128623, 245524, 5553, 113309, 192739, 65766,\n    19567, 22832, 261958, 29679, 21293, 71134, 20962, 105123, 24721, 860, 21752, 33448, 18372, 157167, 94822, 35770,\n    173224, 232737, 75729, 28937, 46828, 28062, 25453, 5207, 140366, 36665, 30652, 6169, 67920, 150458, 92040, 23186,\n    184604, 92330, 20891, 176492, 49427, 27828, 38305, 42495, 143982, 49560, 25503, 90043, 29747, 65328, 47830, 12932,\n    11068, 77721, 9003, 25213, 94205, 140426, 46090, 89945, 138173, 192691, 33329, 112232, 129905, 35709, 27514, 1841,\n    19957, 31411, 127476, 53572, 17497, 173549, 55063, 175135, 19841, 69314, 5192, 237921, 117660, 150697, 4060, 273045,\n    50414, 98940, 65348, 153665, 164423, 58804, 156695, 48994, 213928, 86036, 28608, 8355, 39574, 34540, 16927, 135680,\n    18374, 151587, 10830, 53805, 16878, 16623, 4282, 48030, 8537, 14986, 46102, 13062, 72897, 72, 33050, 108227,\n    39451, 45935, 651, 113320, 40535, 95176, 57450, 48843, 5003, 19019, 10407, 211163, 3848, 1068, 4988, 32091,\n    30095, 41692, 15099, 43602, 107434, 50744, 7627, 171349, 16313, 150832, 352665, 207750, 33937, 38256, 51091, 156000,\n    87889, 90663, 84175, 24908, 114900, 50365, 31494, 83829, 5398, 169342, 47521, 54818, 18935, 8356, 43094, 41212,\n    174536, 10082, 92550, 6678, 60614, 23355, 69721, 14796, 34149, 128830, 58187, 3179, 208, 40325, 28399, 225029,\n    401412, 51150, 31580, 207268, 6657, 10993, 69818, 64282, 289845, 23308, 12961, 38447, 6681, 52944, 31855, 2572,\n    47646, 120728, 179148, 37240, 45196, 218274, 4816, 3695, 21961, 50084, 35209, 18073, 51452, 27004, 6100, 33941,\n    1377, 84831, 171214, 85, 141510, 9078, 99227, 32610, 6417, 11718, 49868, 65579, 87902, 73018, 49062, 46280,\n    61742, 21512, 40862, 107733, 15941, 29168, 157765, 144919, 14487, 5767, 158014, 140070, 7241, 573, 71584, 16921,\n    223566, 40331, 179473, 35081, 47926, 140885, 41508, 52104, 59180, 42310, 32811, 29048, 123517, 102413, 80208, 10104,\n    14746, 12649, 153641, 126022, 37965, 113017, 4171, 83, 142592, 2809, 6362, 50416, 71323, 116894, 260776, 16204,\n    1524, 5760, 30351, 12658, 20703, 54403, 36083, 45408, 74772, 4946, 14485, 50759, 111222, 10890, 2195, 167147,\n    92962, 130534, 16283, 177256, 35016, 15472, 210156, 151187, 73922, 117691, 43250, 52051, 37392, 24811, 24358, 30830,\n    5775, 818, 21969, 1476, 127322, 151783, 58392, 31021, 106913, 65215, 89407, 90802, 28531, 11690, 20234, 95249,\n    44602, 37256, 18707, 11928, 5161, 4410, 26571, 51903, 49768, 22008, 25252, 65780, 209499, 68769, 203726, 13249,\n    137363, 48845, 86823, 6658, 5674, 31881, 1083, 1823, 108676, 34518, 166752, 13791, 14287, 91576, 91429, 8665,\n    11529, 26401, 16191, 91972, 30964, 5254, 28486, 54697, 79613, 66520, 18447, 22870, 45203, 194466, 22822, 51703,\n    12278, 76716, 44595, 73455, 33546, 12235, 144843, 36154, 51247, 11116, 33040, 3180, 225753, 60864, 1972, 28469,\n    12891, 28879, 10338, 144157, 56294, 353058, 38302, 41447, 87532, 110616, 27065, 168438, 6557, 1213, 50804, 144643,\n    24817, 2390, 136531, 38174, 247513, 16190, 4059, 122791, 131994, 137430, 39506, 57650, 16305, 5188, 54309, 106128,\n    20628, 88071, 67394, 395446, 250285, 66176, 91254, 1399, 114196, 43915, 60230, 44853, 27206, 106353, 43013, 18733,\n    345105, 226453, 51202, 16607, 57106, 117175, 35492, 10476, 89598, 127439, 15187, 39624, 13688, 61570, 10615, 31111,\n    59370, 6238, 175252, 32143, 224492, 41388, 95408, 34384, 148238, 78307, 38959, 9340, 160091, 61443, 15737, 11216,\n    41244, 170, 38299, 102443, 113097, 26382, 14027, 33707, 3957, 76300, 66160, 19431, 18900, 6952, 1717, 108656,\n    82206, 188021, 257335, 27295, 43999, 41210, 31777, 46956, 57457, 12657, 11489, 15697, 48060, 204748, 53583, 82422,\n    284790, 30503, 137341, 8120, 19615, 220311, 15991, 10217, 63424, 9808, 67431, 70976, 98221, 4491, 15177, 28535,\n    144789, 751, 13230, 2394, 1504, 33977, 132104, 30316, 22230, 931, 97193, 185240, 24826, 22687, 174322, 15307,\n    22988, 1390, 188745, 180325, 29580, 59068, 74903, 18994, 29195, 79, 15436, 7622, 38462, 11566, 138710, 44828,\n    45774, 37768, 99236, 68137, 84083, 19282, 22698, 17134, 74807, 126662, 173497, 46248, 16938, 119735, 3212, 28292,\n    213652, 49013, 9975, 32180, 45660, 86250, 4801, 68788, 95490, 77482, 113751, 11994, 44624, 94452, 46839, 128497,\n    100316, 5798, 58588, 73184, 202987, 65417, 37790, 88524, 1606, 43156, 97964, 105717, 34947, 11203, 100060, 37742,\n    130074, 93653, 107799, 94311, 196106, 41347, 8035, 10780, 16390, 27883, 118236, 167395, 1979, 25006, 19375, 31628,\n    18916, 144723, 78502, 114047, 103107, 86492, 107686, 5844, 20934, 206963, 23556, 22591, 16562, 146333, 20167, 10471,\n    117434, 33085, 2863, 9740, 36669, 41849, 37271, 22790, 18209, 28979, 8231, 12952, 54408, 21731, 25130, 45208,\n    55748, 138120, 75826, 414, 29593, 9925, 292865, 25999, 683, 123149, 7036, 92159, 86055, 61827, 103680, 23176,\n    54918, 58466, 57578, 13305, 5709, 86479, 16697, 31064, 17660, 200919, 10770, 49793, 33423, 32370, 52047, 16488,\n    62555, 6459, 8426, 83493, 7763, 59725, 82812, 18628, 67760, 79405, 68557, 9612, 7673, 28102, 56517, 69620,\n    171797, 32458, 29541, 15870, 81109, 32080, 207644, 71495, 21202, 11039, 91036, 61230, 2810, 130800, 32260, 4613,\n    60590, 37112, 75214, 33979, 126402, 155062, 30642, 63875, 12810, 194463, 82799, 47664, 16725, 36685, 43367, 61099,\n    449, 172150, 102867, 21691, 301838, 36745, 7130, 18671, 57316, 34852, 38034, 54182, 35578, 65900, 99486, 19771,\n    3456, 2658, 16914, 99866, 28390, 28109, 8262, 21147, 34353, 20006, 4228, 137085, 1675, 203023, 283196, 198286,\n    214375, 163329, 290603, 152574, 40471, 83506, 30068, 14730, 23177, 131539, 34759, 27668, 32178, 71896, 104799, 116305,\n    85430, 119262, 42860, 25160, 8911, 23428, 49437, 105322, 6519, 16203, 6349, 74711, 1230, 38045, 8540, 75165,\n    44736, 25909, 51026, 317034, 4984, 32281, 91312, 27060, 44431, 17817, 45363, 155937, 239085, 35697, 59784, 91993,\n    29531, 126740, 213757, 76560, 167776, 285273, 24262, 8237, 65030, 41160, 74437, 48804, 118916, 13159, 37842, 1031,\n    75349, 1478, 11655, 108777, 23435, 277425, 101734, 67469, 70231, 124711, 43532, 28514, 65526, 54956, 1000, 21882,\n    17728, 25302, 40952, 52214, 149632, 1999, 2111, 3259, 63362, 89961, 220561, 39777, 26335, 9063, 10572, 12416,\n    34551, 34623, 38604, 24723, 5947, 15588, 69927, 66252, 119177, 69173, 46629, 28714, 70715, 212408, 20521, 406913,\n    74380, 11716, 50659, 50862, 37009, 88460, 130101, 7210, 53853, 538, 65120, 151950, 55806, 163748, 52837, 13153,\n    21100, 16674, 64536, 6091, 138201, 44837, 58547, 3723, 163, 2177, 32288, 85454, 34033, 8497, 14282, 25742,\n    10535, 10741, 79559, 117493, 243787, 49337, 100718, 79495, 40139, 42956, 7551, 55433, 15421, 31509, 23034, 45081,\n    547, 61176, 53434, 328001, 8470, 36263, 30145, 4519, 74173, 53935, 11845, 73774, 60211, 78025, 3, 4102,\n    73782, 109293, 315332, 48412, 26683, 13714, 6865, 20128, 18490, 104141, 325, 39470, 171970, 115860, 15707, 7268,\n    73301, 74336, 31370, 2368, 111827, 107757, 136231, 142844, 97138, 96638, 84053, 38691, 23801, 1588, 10573, 122098,\n    77039, 240, 186135, 146101, 11996, 18143, 112963, 46171, 155836, 348769, 47795, 121213, 116266, 132515, 3344, 144804,\n    31286, 99187, 255838, 129694, 35894, 48779, 55235, 148582, 71967, 65282, 15174, 13920, 47080, 6147, 108242, 157593,\n    125025, 7136, 1286, 28957, 127956, 28402, 98813, 20805, 7532, 109417, 40610, 5041, 32958, 15142, 18408, 108596,\n    33543, 50517, 27748, 80114, 233434, 91447, 487, 37094, 100048, 30541, 43477, 10639, 89862, 155868, 37667, 8726,\n    60684, 237903, 73408, 99589, 12190, 38739, 97348, 3914, 13594, 2680, 149016, 13907, 30171, 28343, 23530, 115225,\n    61104, 35821, 147679, 14337, 4297, 244282, 24085, 326976, 56428, 7851, 21303, 131620, 71446, 83253, 68692, 111870,\n    5224, 15813, 38197, 49026, 45057, 13660, 3306, 76345, 40671, 27905, 91072, 996, 68527, 62085, 91351, 122634,\n    55109, 168209, 2024, 27560, 112707, 17352, 8306, 167115, 169921, 166958, 5031, 46020, 11844, 67284, 19130, 76185,\n    6920, 32849, 5450, 14610, 22451, 21002, 17392, 31872, 66682, 84796, 13709, 40210, 59898, 12029, 8719, 53564,\n    21462, 91884, 21647, 88379, 194428, 12754, 37797, 132826, 160016, 22567, 54383, 53186, 77611, 31107, 8339, 4694,\n    19185, 90355, 23597, 17222, 140675, 28442, 23668, 55977, 9128, 61555, 28774, 155229, 17658, 9390, 24379, 69357,\n    15752, 127381, 239631, 62460, 93181, 55913, 45133, 140155, 18676, 25249, 33164, 29581, 82837, 67223, 22362, 29975,\n    7317, 52813, 1943, 29613, 20012, 207130, 49617, 49651, 5636, 15334, 36313, 29226, 28084, 95247, 72072, 19000,\n    224932, 15811, 114, 32127, 38097, 37508, 88507, 37225, 27359, 91626, 12193, 69279, 20608, 11055, 88156, 92808,\n    2152, 57259, 55275, 72789, 24475, 104414, 1708, 9882, 3818, 48661, 66897, 1631, 34806, 227930, 85815, 87753,\n    18321, 250664, 72733, 25107, 206797, 50891, 8082, 196411, 92596, 96764, 152823, 65514, 22819, 387277, 62176, 51225,\n    40329, 15563, 189, 3659, 73670, 64357, 51793, 275136, 33482, 86653, 74615, 67058, 11318, 125720, 15388, 22388,\n    8267, 1730, 102663, 170910, 40784, 7144, 85373, 13040, 7088, 94309, 583, 44224, 140424, 77439, 18496, 164026,\n    36578, 4722, 9151, 5824, 63365, 26510, 35199, 40500, 79277, 32495, 44614, 35233, 9566, 203293, 152144, 7097,\n    2330, 183480, 98629, 13423, 330887, 44130, 68600, 30939, 97829, 31012, 345465, 56747, 94879, 4939, 160027, 149761,\n    99423, 46099, 32251, 15332, 8761, 96094, 128555, 5763, 235318, 222223, 55729, 30241, 55420, 201746, 3987, 81382,\n    8259, 49325, 23287, 7719, 24633, 251100, 92311, 18591, 110533, 64759, 170260, 393860, 7175, 21144, 132887, 3593,\n    75346, 101277, 91109, 16387, 259187, 11627, 57459, 173829, 44694, 55780, 49797, 89192, 120443, 62622, 3904, 14814,\n    23887, 1027, 112258, 64955, 99800, 11132, 66353, 36202, 48624, 18158, 88481, 96882, 43059, 11040, 2455, 7077,\n    21651, 181159, 99126, 100434, 61388, 68186, 19161, 110468, 120052, 8819, 55324, 41494, 7014, 37689, 3618, 87729,\n    92615, 207943, 9823, 128657, 12587, 15857, 6379, 67628, 51216, 71775, 157617, 63244, 1503, 3864, 218754, 110864,\n    5769, 21492, 7243, 1192, 87921, 85529, 31512, 18537, 42698, 35350, 73510, 84474, 34301, 8991, 21013, 35034,\n    566, 38832, 19838, 35586, 37216, 39413, 55006, 12178, 59742, 856, 84563, 6900, 25632, 17437, 49786, 30723,\n    13847, 70845, 4044, 7843, 23944, 235976, 55530, 48942, 6518, 20939, 73769, 192653, 52936, 95207, 23895, 132542,\n    142982, 22632, 87452, 48042, 54018, 178468, 10728, 26230, 23559, 363, 81269, 142012, 5718, 346258, 31456, 84333,\n    246476, 51018, 66692, 101804, 120570, 39962, 30373, 70593, 2864, 60541, 19425, 54209, 104092, 7201, 31545, 48018,\n    25865, 15442, 46257, 40443, 8328, 6451, 111782, 47527, 97754, 33046, 470, 245116, 31095, 39, 91934, 87208,\n    73470, 36708, 36521, 12801, 70624, 36272, 8892, 79768, 12427, 55454, 103756, 5908, 52390, 62962, 22720, 141138,\n    94634, 41689, 128402, 126390, 6628, 106394, 35527, 134394, 82727, 254651, 194502, 148064, 89549, 3202, 28359, 957,\n    21954, 27906, 49840, 142747, 8307, 24206, 48978, 1186, 71728, 133038, 71474, 91306, 6333, 110959, 74600, 70387,\n    18983, 62609, 56057, 22970, 1147, 135850, 1321, 28834, 3578, 59715, 102227, 32827, 81415, 99952, 55636, 257598,\n    390, 22702, 35701, 85872, 402916, 39216, 189795, 14929, 19467, 10112, 144422, 61514, 5279, 63421, 134686, 41436,\n    8424, 51925, 10598, 132295, 124416, 4604, 194739, 210929, 57866, 31829, 51626, 50007, 9976, 91878, 61906, 56168,\n    81906, 60918, 61859, 40017, 23059, 16887, 40927, 62064, 12785, 32893, 32913, 21782, 93965, 20169, 44387, 79084,\n    38463, 11457, 93950, 27127, 157050, 2697, 337088, 5116, 54128, 48255, 33279, 8821, 27352, 25515, 124022, 65710,\n    28906, 38557, 33390, 1722, 104435, 72215, 38551, 12094, 30978, 25113, 6671, 37355, 175109, 42862, 98024, 65406,\n    221276, 59624, 118012, 64637, 78760, 86697, 21426, 1639, 40350, 12584, 67193, 84144, 31396, 7863, 143011, 69629,\n    63112, 9454, 28666, 65798, 46372, 134721, 6314, 51402, 30837, 151922, 2847, 38676, 38008, 92823, 136245, 17540,\n    5504, 109295, 205242, 37606, 5211, 214892, 1586, 20670, 208711, 137743, 19328, 40652, 16995, 20023, 14657, 154919,\n    34422, 12996, 13918, 38221, 47690, 16398, 2959, 37680, 89122, 6721, 198469, 91876, 172043, 83898, 101992, 26084,\n    94570, 3635, 76958, 22853, 76497, 38266, 176590, 168403, 44464, 142840, 79180, 184594, 1984, 41806, 83147, 11985,\n    6546, 366068, 59732, 24533, 271505, 8736, 39084, 222992, 93429, 28962, 58985, 86665, 8432, 30028, 14548, 32439,\n    54424, 165029, 55175, 27458, 69046, 121277, 46168, 33732, 20661, 24581, 135574, 123110, 37556, 79260, 72611, 16957,\n    12939, 46162, 58238, 44907, 72936, 253758, 41324, 32518, 96480, 11949, 124438, 65280, 43256, 34107, 53533, 43531,\n    37037, 28366, 45970, 32741, 173438, 6121, 194202, 62969, 26355, 30314, 58370, 28455, 1848, 50519, 82830, 90393,\n    21761, 295490, 10936, 256940, 133568, 44050, 20269, 4089, 27457, 21610, 219460, 36743, 14821, 101388, 52005, 13124,\n    30979, 140816, 167362, 26054, 18458, 60789, 34917, 40447, 26606, 33422, 9066, 3452, 83614, 5761, 20263, 137238,\n    25038, 91310, 101, 52322, 74548, 42572, 38084, 214054, 186568, 31802, 17665, 30620, 141936, 37730, 14420, 4265,\n    187218, 49640, 188208, 51441, 55388, 96452, 66659, 40869, 42039, 60967, 221027, 19234, 178581, 29105, 96050, 9165,\n    196118, 157335, 3738, 40354, 117436, 2965, 34136, 59659, 15570, 50843, 230035, 31444, 71260, 43886, 18316, 5387,\n    38500, 168508, 17406, 32174, 8828, 103373, 143806, 90367, 3560, 18719, 122310, 16508, 26719, 2541, 105429, 6645,\n    37998, 73190, 10591, 235916, 49737, 87112, 233941, 53188, 32193, 79154, 4544, 52905, 126477, 7580, 63501, 57314,\n    3216, 31337, 6541, 103083, 60846, 49, 9756, 15481, 1355, 43840, 14319, 13743, 27486, 10222, 73114, 230718,\n    418644, 16706, 6674, 279748, 23058, 45273, 295831, 86306, 2743, 5535, 88773, 21829, 35253, 120938, 31153, 3169,\n    16839, 42847, 8751, 80974, 33942, 36867, 35514, 16485, 26474, 77775, 56877, 5391, 48346, 3882, 108713, 31403,\n    27804, 55248, 26235, 43821, 136104, 40118, 175507, 28034, 203908, 18732, 1788, 34030, 106427, 36958, 54359, 7251,\n    44936, 15356, 69139, 455, 157915, 22173, 140291, 50348, 43275, 82066, 49621, 54952, 15216, 36226, 96695, 66855,\n    6936, 1987, 8227, 196087, 4631, 68827, 99004, 47541, 110265, 17953, 147605, 110242, 58520, 31312, 38724, 329975,\n    642, 3155, 34497, 75937, 6207, 73843, 6120, 17249, 51429, 117746, 3218, 910, 68961, 319671, 14938, 29555,\n    34700, 1649, 66673, 72268, 9655, 76800, 153087, 6941, 210168, 27130, 35398, 1780, 73242, 3135, 56689, 19556,\n    165307, 8765, 35967, 121458, 13333, 70453, 17350, 117253, 22265, 13340, 44265, 39869, 441, 3742, 135025, 23581,\n    33309, 16543, 17731, 13291, 157637, 283005, 21408, 101360, 63887, 52312, 83873, 5338, 233779, 23759, 186949, 34531,\n    177320, 38069, 156465, 91004, 19353, 59852, 68160, 14891, 1338, 1072, 29823, 1950, 28901, 81407, 313445, 73038,\n    84807, 162348, 240257, 37162, 138934, 16111, 58013, 41253, 102951, 16457, 96056, 19541, 56402, 67217, 41638, 94381,\n    89674, 29481, 37456, 80815, 151579, 13937, 13683, 132537, 19699, 134545, 67020, 29816, 222341, 141235, 427578, 48868,\n    129557, 233342, 23077, 87871, 16213, 18728, 16184, 9469, 37913, 19680, 2798, 171356, 178328, 13216, 50049, 72690,\n    71904, 124644, 55455, 7504, 29052, 41036, 266546, 19899, 30391, 188755, 8659, 59469, 16, 104298, 112943, 53865,\n    76203, 138226, 68857, 139953, 14125, 107625, 119795, 173133, 4398, 50273, 48808, 54390, 16466, 122086, 31835, 67035,\n    50971, 48859, 7508, 46427, 66477, 73021, 84615, 39985, 83076, 46779, 201569, 53336, 36443, 60865, 168164, 143810,\n    51393, 25548, 169307, 32896, 24485, 38424, 21837, 29087, 275813, 51674, 6714, 64883, 46169, 187369, 55186, 76192,\n    12852, 12018, 62134, 31067, 118303, 16542, 12125, 10579, 4928, 26291, 43854, 7091, 10946, 253716, 109062, 39283,\n    17261, 113012, 258512, 47764, 125126, 32646, 55892, 80279, 201623, 149872, 3192, 385, 1208, 48750, 5376, 58738,\n    22335, 5427, 82416, 47811, 32435, 143086, 38930, 94128, 59975, 156037, 37977, 38224, 62485, 7698, 50405, 71027,\n    16462, 21559, 136153, 34131, 107506, 162069, 63703, 3101, 215029, 40407, 4178, 3774, 9187, 80019, 17880, 97926,\n    67579, 2600, 18405, 8351, 47924, 86638, 70820, 92206, 86453, 29610, 42241, 119200, 3198, 15466, 67813, 57863,\n    35454, 4779, 99518, 4649, 104641, 144269, 33730, 38073, 65864, 6838, 109456, 193298, 154007, 5623, 45741, 30846,\n    182578, 25573, 157224, 1543, 58575, 138703, 146140, 44971, 49356, 18275, 59064, 20300, 13122, 11848, 24453, 11973,\n    9797, 86843, 2919, 25530, 49210, 1130, 161220, 76788, 75373, 85604, 34926, 36014, 17777, 17255, 51533, 11676,\n    92226, 51845, 119859, 21525, 5936, 18507, 28050, 1140, 31418, 14857, 34207, 47859, 10750, 36382, 32079, 106909,\n    59426, 87757, 38393, 110042, 15965, 97104, 33757, 35344, 97993, 53979, 33651, 45407, 41884, 82515, 173089, 7177,\n    58371, 35365, 47543, 51927, 35587, 10670, 23544, 29306, 84233, 39976, 76076, 62097, 9007, 8668, 28119, 78281,\n    120790, 19835, 143020, 54968, 18670, 64959, 20649, 34469, 42570, 33001, 136570, 87796, 120044, 1106, 58700, 63951,\n    127623, 12805, 83057, 40212, 31773, 49850, 7361, 54336, 347524, 101314, 23751, 19569, 48791, 29174, 49369, 20467,\n    7465, 75842, 38281, 623, 112457, 60210, 28849, 51003, 94720, 6426, 90047, 85560, 43761, 3579, 85105, 34607,\n    90410, 118528, 7224, 42907, 111163, 18168, 6960, 161135, 191298, 5247, 100584, 127552, 171568, 20121, 91173, 12636,\n    54615, 20199, 63730, 98105, 2396, 40387, 14438, 125012, 4765, 33235, 12865, 45299, 37728, 82098, 77872, 114037,\n    59253, 19675, 24838, 398016, 102561, 11446, 17069, 57508, 178277, 65836, 99941, 26114, 2585, 271882, 136866, 50126,\n    11027, 155648, 118367, 14585, 8910, 123015, 335383, 40434, 41016, 53021, 14439, 87098, 176860, 201543, 121888, 2358,\n    9286, 5739, 22666, 54270, 37884, 169381, 33984, 93859, 16124, 89364, 72207, 51639, 76366, 99029, 65812, 2198,\n    12147, 174891, 194289, 6986, 30252, 88822, 21284, 11445, 288337, 160821, 33034, 100869, 43852, 25761, 52882, 1144,\n    103809, 1924, 84458, 86079, 43411, 13542, 139276, 18141, 34978, 41298, 7276, 26481, 173800, 33210, 17951, 142652,\n    33616, 33677, 2210, 19941, 98568, 2486, 192414, 80136, 12058, 235883, 50963, 249638, 29572, 27221, 47034, 6124,\n    72107, 63346, 97620, 158513, 299699, 40388, 23235, 37176, 224244, 198386, 121323, 67992, 23827, 63170, 17838, 106622,\n    158590, 26807, 5345, 23489, 91891, 55474, 74834, 37981, 13058, 5977, 72552, 34706, 26828, 145172, 19904, 21367,\n    34043, 960, 77092, 91381, 4733, 47446, 7680, 41697, 5170, 16960, 14741, 46101, 13656, 473, 51842, 37433,\n    11103, 11551, 121951, 13191, 97536, 165932, 50397, 51628, 129028, 9069, 44885, 6590, 59195, 47045, 32940, 225472,\n    90345, 21833, 13303, 29407, 96615, 141951, 5198, 6028, 18395, 7181, 3861, 14966, 156358, 167182, 36529, 55253,\n    25942, 173153, 30959, 27261, 50691, 150176, 162201, 38467, 48462, 80602, 42163, 118482, 168, 108756, 26011, 17166,\n    54149, 456538, 22512, 91374, 13816, 90358, 131615, 18132, 226707, 1824, 28139, 26860, 42253, 93877, 77351, 65575,\n    8980, 80574, 22020, 27948, 40422, 91324, 76376, 13528, 39281, 91685, 82215, 122541, 144066, 1983, 193851, 17283,\n    26320, 2739, 194978, 4790, 26845, 42627, 61300, 65815, 174612, 55133, 4200, 191130, 79771, 158321, 52280, 166796,\n    221620, 62461, 11278, 4067, 88152, 83409, 31717, 121367, 13522, 47325, 37945, 10406, 174348, 249321, 154101, 64912,\n    29938, 51775, 17220, 15776, 166138, 78890, 84425, 54121, 42861, 16368, 24572, 291647, 10197, 32073, 22651, 11677,\n    97509, 26952, 35787, 18424, 41910, 71614, 94977, 72318, 41594, 70024, 275419, 37702, 60199, 7335, 39107, 61315,\n    18271, 18394, 33768, 87884, 104277, 123724, 7277, 56288, 71981, 189803, 49320, 3352, 6798, 14240, 8954, 69220,\n    94433, 57372, 28620, 68863, 193727, 85575, 42309, 41667, 67689, 42081, 22543, 44824, 12719, 28540, 114236, 101553,\n    27638, 27296, 4300, 5353, 4663, 19379, 94098, 3758, 95888, 95144, 80344, 87320, 28447, 259518, 12718, 71391,\n    152731, 37063, 24132, 31911, 104896, 15672, 103782, 1521, 4945, 72541, 23717, 122632, 15619, 87175, 206120, 29428,\n    189780, 61416, 28350, 44457, 972, 1175, 47233, 198738, 95789, 41907, 21953, 97034, 59341, 22864, 53713, 16873,\n    32971, 20693, 20954, 31336, 21477, 16169, 38370, 16412, 9019, 3841, 24599, 21938, 17085, 6484, 81198, 76413,\n    5849, 72514, 12320, 65247, 276175, 37234, 59796, 52642, 16312, 57349, 198507, 94148, 46134, 18958, 125552, 1747,\n    18725, 151873, 14901, 5490, 68287, 29470, 3689, 64794, 40814, 26018, 25692, 54450, 2703, 88278, 124886, 173087,\n    174000, 24159, 179477, 24276, 46004, 201876, 209202, 445, 52876, 31948, 30206, 157610, 39180, 18439, 44124, 50469,\n    5774, 96278, 222758, 200216, 50290, 45486, 20435, 46986, 46276, 140133, 142326, 15569, 13363, 47522, 92583, 2182,\n    7135, 16853, 22998, 30272, 4952, 63263, 35623, 39096, 53789, 44864, 20053, 110392, 124213, 4630, 16087, 28221,\n    127787, 25839, 77481, 44693, 13464, 113146, 6983, 27069, 55717, 50102, 4760, 7107, 26186, 66507, 59145, 36032,\n    104182, 71328, 29425, 64317, 50781, 47465, 94298, 69706, 74899, 22754, 120756, 25108, 93077, 56834, 73286, 39928,\n    16218, 41699, 176763, 7555, 70819, 50083, 26895, 23315, 26014, 16773, 123079, 41712, 5719, 31516, 90427, 158540,\n    85051, 183128, 40864, 27505, 55392, 9058, 45224, 96857, 30901, 136622, 96557, 56304, 120061, 11501, 151448, 5773,\n    89743, 7769, 86069, 2935, 18471, 41628, 10114, 33660, 110170, 49479, 26745, 92846, 33221, 26731, 18795, 87076,\n    8550, 2100, 29972, 120289, 3077, 72490, 33784, 2630, 208722, 50861, 63483, 79029, 6419, 39467, 14302, 45286,\n    64207, 9686, 67513, 44170, 1050, 77246, 59266, 17055, 53801, 7150, 11111, 42432, 4278, 94579, 362117, 36175,\n    42902, 41933, 39002, 98489, 22913, 74161, 84773, 57036, 17556, 162288, 74485, 178760, 93867, 73635, 128860, 50362,\n    261, 67455, 80001, 46080, 35662, 4368, 25247, 19230, 74393, 22588, 1822, 27682, 235324, 13798, 85998, 13194,\n    235067, 23514, 71669, 147632, 23191, 134748, 214683, 105101, 1518, 25489, 247114, 7380, 54842, 26922, 3971, 26361,\n    20844, 68642, 170517, 77339, 123255, 8963, 77818, 150998, 48466, 36806, 2732, 23261, 11741, 236162, 18243, 126216,\n    28690, 50546, 16385, 92760, 197383, 246558, 201295, 88255, 67588, 71687, 176076, 172653, 169058, 33906, 63747, 24835,\n    157621, 43338, 30050, 46152, 132741, 2770, 51371, 94835, 6614, 15112, 11749, 56936, 1250, 19027, 399017, 58036,\n    100215, 23388, 55815, 308768, 124152, 94803, 9521, 64186, 8971, 28, 30427, 62163, 7616, 103838, 35079, 29203,\n    131235, 7743, 17389, 10882, 37420, 61460, 228512, 85363, 41581, 131077, 62822, 119647, 10130, 54445, 26925, 19968,\n    29016, 24446, 74028, 24176, 61448, 67185, 9254, 8563, 119129, 9771, 99184, 37716, 39514, 10532, 221512, 258753,\n    218630, 55980, 23394, 32141, 61924, 66749, 32411, 3741, 36475, 26678, 77010, 44946, 91203, 128749, 116953, 20476,\n    49625, 53116, 13735, 102335, 29376, 51946, 83407, 67892, 59212, 34685, 21083, 1546, 112982, 32972, 74397, 1078,\n    190545, 16082, 86140, 58591, 89611, 101531, 10061, 105104, 76319, 20035, 17551, 52611, 169061, 190842, 100780, 23907,\n    90413, 115619, 9675, 34710, 193435, 49443, 129734, 11183, 258877, 16318, 136182, 126808, 44635, 27304, 192375, 2599,\n    125648, 47051, 12091, 23814, 721, 58800, 40137, 66726, 97930, 60877, 74487, 7942, 54326, 9841, 41428, 13762,\n    8211, 85383, 6950, 99177, 79806, 201786, 296464, 124087, 13144, 29741, 41721, 47634, 55088, 254286, 106408, 17041,\n    99064, 12942, 64086, 45233, 14005, 2612, 55827, 255, 7984, 13980, 38574, 12776, 46654, 73499, 249951, 2101,\n    26676, 25996, 132326, 116415, 119062, 50449, 31033, 23038, 11589, 179252, 20007, 14860, 129270, 21143, 17796, 144715,\n    60106, 70758, 69842, 34674, 282133, 44014, 16774, 57268, 38528, 24053, 46373, 201667, 28327, 471023, 51889, 102667,\n    21193, 114909, 84132, 69317, 96723, 67969, 16134, 68145, 15058, 28765, 32035, 2524, 101089, 98664, 25045, 76571,\n    14957, 86040, 118506, 262428, 154764, 81573, 39681, 283900, 73287, 127825, 544, 80448, 52347, 38512, 175971, 15180,\n    45467, 33086, 46552, 48894, 81107, 43213, 36672, 54025, 76703, 8053, 7608, 13299, 56619, 20752, 238099, 54164,\n    105133, 1444, 32942, 953, 37564, 8000, 66316, 119463, 106817, 404, 13667, 149108, 128597, 31267, 10269, 49836,\n    106150, 1484, 52330, 76965, 160486, 171648, 38456, 31263, 22424, 37738, 66245, 67467, 143369, 60471, 75610, 20895,\n    115528, 86070, 60854, 40796, 49347, 18989, 15030, 11371, 37578, 15779, 79867, 10187, 86462, 46402, 155626, 93200,\n    40229, 7090, 57547, 108053, 99598, 11088, 47505, 41218, 206017, 2173, 20988, 30219, 22919, 80563, 57566, 42369,\n    93141, 41675, 2407, 182519, 120495, 27154, 16702, 29456, 14349, 7958, 16688, 117177, 140375, 42467, 261919, 74916,\n    153569, 10836, 34742, 49526, 7621, 105997, 12212, 2270, 392377, 7755, 17959, 25086, 232152, 138791, 33847, 13860,\n    35316, 5811, 1344, 71259, 50452, 207539, 92635, 50359, 5821, 33674, 30255, 2086, 2587, 96264, 17543, 42,\n    6029, 9580, 43007, 139248, 82831, 12917, 29607, 25786, 51467, 42137, 85161, 100698, 31561, 88989, 121990, 278500,\n    3602, 109344, 37982, 15279, 116442, 28936, 30880, 87894, 58079, 128661, 126731, 67392, 28051, 146885, 4861, 16216,\n    97344, 42827, 147561, 153948, 22684, 21335, 47685, 1853, 43349, 15185, 59642, 10229, 25520, 187921, 108972, 5579,\n    98037, 24945, 6697, 19193, 63734, 137934, 75056, 89740, 19767, 224268, 56138, 63643, 151661, 39313, 70618, 84031,\n    89723, 84074, 13703, 85626, 35460, 8867, 64845, 3439, 57906, 99776, 63968, 49270, 81130, 34356, 16210, 23547,\n    36446, 34090, 140028, 72439, 2221, 22163, 57058, 363492, 113754, 18913, 95451, 48663, 54464, 54037, 176097, 68425,\n    3023, 34906, 29482, 117389, 341780, 80431, 58330, 16753, 92616, 60907, 94846, 147486, 4498, 48646, 7773, 46801,\n    7778, 18946, 464978, 47558, 33223, 177444, 7328, 15626, 63337, 94700, 11743, 9351, 255024, 39098, 16447, 42647,\n    96230, 39769, 58840, 10068, 63439, 35800, 65843, 58823, 413844, 9156, 51258, 7434, 61791, 85018, 6872, 3692,\n    28096, 7121, 33024, 6009, 75532, 31997, 192535, 9661, 3304, 9547, 14753, 31987, 25314, 55689, 15896, 20430,\n    39472, 31340, 99744, 25398, 115569, 54883, 28719, 205423, 23071, 57855, 64638, 149867, 25671, 82403, 37616, 20668,\n    39989, 77996, 74948, 140555, 175248, 64810, 36515, 46595, 4958, 248773, 24045, 28728, 136673, 168704, 20804, 114833,\n    100325, 27135, 21205, 96151, 153134, 45992, 7093, 13992, 76047, 1980, 19432, 145001, 75159, 87462, 17710, 1013,\n    45556, 34297, 144882, 20648, 26061, 11319, 129567, 108555, 18872, 464580, 33386, 22717, 65948, 167189, 5603, 135042,\n    79542, 8801, 202632, 18114, 91882, 5973, 5239, 67315, 4431, 60916, 47819, 71693, 32597, 32606, 18183, 45072,\n    80329, 76385, 24749, 51305, 40314, 156514, 14693, 130345, 13168, 66214, 18029, 12858, 34801, 27628, 14544, 10823,\n    40522, 40185, 33739, 148694, 23548, 9923, 61012, 28859, 17933, 19442, 34364, 99849, 164107, 141167, 30629, 21054,\n    6744, 36491, 8096, 42474, 41706, 155060, 30650, 10600, 163442, 1143, 96655, 61390, 52359, 7559, 51568, 64256,\n    203854, 4467, 22453, 14504, 436398, 7878, 6980, 8293, 63610, 293747, 16167, 35763, 19627, 147603, 15419, 18032,\n    110744, 51346, 33681, 54571, 40472, 48615, 39073, 21604, 13754, 173027, 92560, 11083, 47299, 63062, 11813, 52007,\n    29883, 9734, 139722, 15953, 1550, 20651, 13616, 49306, 16113, 90089, 92326, 7584, 30712, 72424, 164858, 6831,\n    152871, 55746, 197721, 34167, 196442, 6022, 112107, 55215, 7538, 123381, 4920, 43539, 77165, 8939, 50392, 34192,\n    20225, 79762, 22505, 58667, 40770, 29788, 97180, 82835, 4568, 8579, 13273, 363569, 35898, 49983, 436, 36598,\n    3237, 131691, 62418, 35591, 8101, 4073, 379438, 65218, 76072, 33887, 2968, 27573, 212619, 288680, 68278, 72851,\n    150504, 217896, 6913, 121339, 22017, 35340, 51072, 43616, 75043, 31437, 10833, 81487, 4364, 22968, 41454, 106687,\n    85446, 19863, 109625, 149241, 524, 141850, 214404, 54376, 657, 237023, 9401, 108137, 53800, 32474, 49712, 53334,\n    126876, 27337, 45552, 177696, 8269, 15036, 12097, 42240, 2328, 125374, 119295, 99715, 2500, 19624, 39441, 27220,\n    102691, 60957, 94543, 39101, 18566, 67362, 13975, 78230, 25017, 34017, 239007, 90027, 39351, 41681, 35354, 43822,\n    1043, 916, 58587, 141983, 94818, 38799, 75459, 41114, 67432, 16195, 36606, 59568, 22272, 126769, 31424, 68659,\n    12287, 134302, 257977, 5756, 207285, 95637, 47248, 117689, 19583, 77451, 22373, 12200, 54993, 117118, 34244, 29386,\n    34562, 53819, 71267, 64172, 77665, 49368, 7716, 59301, 25749, 45426, 194789, 17297, 2650, 1766, 32501, 45198,\n    20403, 20984, 6600, 14171, 94604, 19037, 5402, 29896, 9938, 59935, 109708, 88081, 145182, 44844, 39167, 352626,\n    164173, 35374, 45982, 6122, 154, 73419, 220487, 53834, 53601, 17992, 8609, 229321, 5610, 68098, 66815, 71012,\n    95069, 140968, 27396, 8957, 134489, 24656, 86659, 56598, 134852, 17316, 123838, 255436, 6613, 41610, 138033, 81452,\n    32023, 32396, 123687, 63398, 8693, 29712, 30407, 19296, 121188, 3551, 36099, 20032, 111948, 56624, 16547, 27453,\n    35916, 15378, 52039, 56849, 13489, 22214, 73177, 53097, 277349, 2157, 14029, 187886, 10260, 141743, 246460, 91880,\n    50869, 3788, 49486, 133566, 54950, 33120, 129337, 53768, 18333, 9525, 26902, 312251, 10297, 9020, 70759, 16647,\n    112432, 59260, 84609, 9818, 82766, 73569, 468, 46001, 75780, 55028, 52106, 11498, 43645, 108069, 17150, 17753,\n    29417, 16705, 31799, 9606, 289, 122254, 115975, 8620, 6133, 255357, 56908, 14456, 133464, 43554, 79224, 11247,\n    29630, 160, 12756, 25464, 65960, 350428, 62521, 321796, 100359, 67358, 35169, 46172, 113128, 48988, 88868, 31094,\n    33266, 6847, 60887, 98188, 49659, 69117, 92977, 220228, 13947, 80181, 35103, 62170, 97351, 13475, 2440, 199768,\n    19498, 36597, 46971, 25234, 67806, 62881, 84717, 73648, 181966, 10488, 94149, 21550, 26655, 63436, 48375, 14405,\n    165650, 9621, 24439, 28043, 42735, 4490, 29963, 56674, 45373, 1934, 262446, 50855, 67098, 26898, 5261, 52696,\n    40644, 33900, 9440, 180286, 87162, 22940, 19704, 26936, 69769, 10254, 101759, 27406, 12243, 48000, 73926, 113215,\n    54935, 5726, 192787, 4312, 106216, 9366, 11550, 52949, 23457, 212271, 277152, 133895, 108374, 6191, 96477, 29980,\n    218916, 58024, 54696, 40853, 91124, 65894, 91170, 65908, 252552, 6793, 29212, 15389, 44516, 122515, 52617, 35058,\n    9017, 103536, 39510, 49136, 19242, 130652, 662077, 74699, 47024, 31422, 8517, 73351, 24399, 13867, 128360, 4810,\n    4434, 61779, 111983, 61036, 17798, 110240, 59722, 102960, 39688, 10001, 23803, 23039, 176498, 56659, 44814, 134295,\n    17188, 77577, 74466, 226175, 102472, 154333, 63900, 111747, 18062, 41171, 79669, 32773, 408933, 42562, 28931, 30907,\n    107388, 43487, 2946, 240310, 23938, 24354, 319, 184983, 7927, 6488, 1422, 10790, 68809, 68209, 64775, 4361,\n    202, 17123, 59634, 51200, 44391, 18188, 17843, 2619, 74278, 3230, 9540, 47187, 21702, 36274, 56894, 43907,\n    16310, 34790, 16866, 6150, 5561, 13587, 107545, 108873, 126867, 86986, 28640, 33427, 19017, 5762, 80637, 17430,\n    46903, 2047, 131055, 25958, 13558, 5444, 47152, 13900, 44563, 122857, 45348, 70863, 39593, 54332, 38068, 33637,\n    318, 40310, 143467, 18502, 24520, 11377, 62013, 28942, 27246, 28269, 83545, 17999, 59015, 90707, 30065, 15161,\n    34720, 1263, 37008, 2012, 6060, 98575, 92933, 5721, 299, 199555, 24578, 29223, 2985, 743, 115825, 109523,\n    136657, 47454, 26378, 53586, 3733, 174945, 93340, 244456, 5693, 37386, 28782, 89767, 27545, 23573, 18798, 136425,\n    34320, 84778, 20041, 48453, 38215, 7477, 71958, 40621, 8773, 5874, 187927, 105965, 51100, 43533, 18083, 8443,\n    10180, 43597, 2003, 183999, 69689, 12216, 129696, 146188, 62389, 34044, 68410, 12765, 43273, 26949, 266807, 3345,\n    34477, 79197, 5688, 47539, 213110, 21634, 22257, 50092, 32222, 42346, 39530, 63668, 98, 134978, 74022, 5152,\n    59088, 174145, 37220, 9934, 9545, 118937, 5724, 87240, 19875, 15784, 40143, 23263, 87513, 181654, 285152, 37881,\n    263241, 4966, 43934, 10433, 186657, 6470, 74416, 225854, 25908, 142677, 246262, 32280, 6192, 75890, 45546, 143264,\n    135305, 29742, 47013, 77787, 11732, 126658, 8763, 37950, 21806, 57557, 113464, 89465, 108995, 164574, 23894, 22996,\n    23169, 15369, 23117, 17642, 130607, 40503, 36239, 280990, 44666, 9981, 40427, 147487, 26869, 168452, 32886, 32991,\n    46798, 240839, 15111, 70502, 65697, 88548, 44145, 28701, 48767, 31139, 206777, 35659, 181164, 166262, 14554, 171445,\n    31786, 66523, 76607, 17956, 6507, 31279, 90476, 116611, 167918, 6560, 1243, 115324, 80128, 41867, 55897, 187323,\n    37069, 32596, 189444, 145931, 13390, 105530, 65709, 26805, 6999, 55714, 41300, 22915, 68951, 22138, 21120, 22264,\n    10058, 19945, 33635, 56123, 99085, 10032, 5818, 6016, 46649, 57476, 35264, 94413, 112522, 262288, 93686, 83038,\n    14341, 23204, 28807, 66084, 77987, 6101, 126673, 7133, 38126, 5923, 122091, 170240, 97772, 46874, 215746, 43948,\n    41622, 3272, 55596, 8332, 146411, 251315, 13533, 8561, 81521, 115449, 48616, 175175, 2063, 186556, 3036, 134537,\n    75772, 29728, 82360, 22973, 186559, 86348, 89100, 38388, 82297, 45610, 2613, 87082, 9986, 177812, 57884, 23591,\n    47485, 42543, 33582, 44713, 74439, 257444, 252451, 31825, 35631, 38540, 33066, 5147, 13973, 4343, 51830, 70378,\n    22827, 26448, 95560, 36896, 241741, 48067, 203953, 298860, 61620, 20450, 3220, 67272, 6586, 107662, 100160, 108684,\n    6929, 57226, 4762, 7457, 1320, 40404, 77204, 99309, 62750, 208653, 59977, 44000, 74315, 34332, 5819, 172217,\n    64904, 114077, 18147, 84012, 1791, 98456, 90930, 21446, 116669, 103938, 7422, 85140, 59713, 5768, 326211, 16239,\n    75411, 13229, 29398, 10758, 236107, 1539, 112472, 95979, 152154, 151294, 306, 21196, 38146, 10700, 6891, 84282,\n    109646, 56492, 40539, 6589, 119491, 51354, 30685, 140209, 136906, 29622, 73617, 49553, 70525, 51671, 166869, 139616,\n    74395, 37439, 49595, 45678, 11959, 33211, 86560, 52434, 9282, 62690, 112155, 130810, 5243, 108261, 99970, 265613,\n    72551, 80049, 6391, 33365, 90721, 66737, 69872, 87011, 1860, 9032, 112544, 60905, 37371, 89015, 140351, 19076,\n    850, 373531, 2802, 36725, 218795, 72062, 28990, 16550, 24614, 7815, 6187, 26336, 33373, 32162, 42791, 73555,\n    32062, 23386, 10244, 56392, 49442, 27076, 136262, 12412, 14883, 1134, 33675, 97153, 199281, 15608, 100152, 74072,\n    47942, 254301, 36451, 16026, 10687, 65067, 56708, 254030, 30290, 50490, 13864, 57941, 259331, 35588, 23485, 43486,\n    24869, 21620, 92971, 22072, 88645, 1048, 182050, 13343, 32452, 14825, 19509, 3325, 216938, 45740, 99716, 189082,\n    53740, 78245, 25609, 24311, 176777, 47340, 308354, 40669, 66085, 14102, 125339, 9225, 128709, 97207, 1271, 200933,\n    78439, 113451, 88975, 18324, 46521, 11819, 18570, 141756, 72512, 170020, 52754, 63550, 118515, 103073, 93330, 32736,\n    50499, 14722, 31600, 68452, 398867, 29316, 172786, 18417, 104924, 2606, 5670, 84818, 16288, 67106, 59580, 82929,\n    607401, 291, 85829, 359, 15897, 35830, 50696, 65630, 52672, 22115, 356968, 29895, 40837, 231192, 34024, 38957,\n    26722, 406, 23335, 124952, 72068, 68804, 13268, 147101, 164740, 276569, 162596, 66943, 11569, 26654, 66358, 4777,\n    23229, 102127, 5848, 978, 2921, 59666, 5371, 28212, 90108, 42938, 39320, 2499, 4271, 108792, 33510, 125072,\n    71653, 65239, 38250, 66357, 38577, 13964, 86251, 35708, 50755, 36010, 29448, 12209, 3844, 38222, 206337, 100876,\n    67827, 137088, 14167, 252225, 84163, 195270, 1306, 5703, 54198, 779, 46802, 22028, 51124, 86759, 70560, 113164,\n    35685, 162145, 45471, 34561, 422, 2611, 6464, 47486, 19223, 38246, 9191, 18331, 89942, 243642, 212364, 15893,\n    17518, 22617, 6409, 30046, 126182, 59716, 36560, 104428, 18846, 26592, 19458, 50793, 147333, 30826, 1388, 27647,\n    10922, 14495, 33545, 19269, 135828, 39727, 41601, 46931, 233379, 49169, 131130, 182112, 16276, 82381, 118209, 142445,\n    128310, 19672, 28740, 82907, 33436, 3118, 102206, 28723, 24819, 41937, 38854, 5157, 3881, 111491, 1142, 9776,\n    421673, 152241, 29309, 14961, 87854, 6054, 15424, 3796, 82656, 54996, 2108, 55367, 239450, 154525, 9643, 118103,\n    106041, 64601, 68549, 48707, 30266, 25772, 18740, 9462, 229669, 91798, 112152, 191327, 14493, 72828, 8175, 66636,\n    236474, 25817, 87351, 129027, 76653, 20422, 22983, 71240, 27846, 44661, 12399, 46158, 77704, 53101, 35032, 11072,\n    17300, 109294, 33638, 24408, 1895, 11241, 760, 17584, 82479, 125877, 63150, 141075, 34259, 23274, 81698, 15732,\n    43577, 48340, 91584, 14688, 16379, 24481, 150280, 96420, 262050, 48635, 43727, 61819, 56268, 72003, 88178, 17281,\n    79912, 13218, 122519, 125295, 166396, 11811, 2171, 118930, 67746, 17636, 178278, 174656, 95661, 173039, 83845, 79689,\n    17473, 98555, 127696, 203415, 54730, 22925, 232239, 9309, 12136, 175026, 20740, 180188, 10747, 39816, 314017, 266131,\n    10040, 175732, 112550, 220651, 31974, 37393, 888, 23008, 86799, 4303, 64905, 148467, 75337, 251, 3284, 370102,\n    50264, 9835, 5438, 23655, 4481, 29851, 329, 12855, 7162, 64931, 78141, 12804, 42372, 296771, 83547, 18624,\n    34874, 86271, 3360, 48665, 77735, 88767, 11463, 63527, 28889, 22258, 29140, 194315, 113924, 25499, 6406, 31334,\n    1845, 4802, 49184, 43455, 35469, 127594, 92970, 61038, 115005, 38840, 87761, 106838, 8811, 20572, 55637, 11162,\n    96721, 132425, 108925, 2948, 125457, 36356, 3502, 75270, 27622, 127192, 2561, 123095, 49394, 61155, 16897, 110064,\n    9699, 89448, 53356, 19628, 220310, 21622, 83036, 9885, 112214, 6087, 26713, 17901, 161912, 91492, 3440, 68594,\n    9266, 92238, 8087, 6866, 150194, 72175, 80701, 13459, 31836, 43243, 239700, 95846, 44749, 50647, 21945, 230538,\n    120612, 132371, 244604, 5193, 105637, 34661, 41341, 68775, 85393, 1874, 8771, 33718, 49672, 77403, 595452, 99507,\n    6490, 58895, 128742, 7704, 39239, 73217, 43816, 62824, 37804, 199976, 22361, 80005, 87514, 94832, 14089, 4574,\n    139975, 59142, 75523, 100268, 43906, 53442, 15152, 2547, 186002, 17011, 19513, 204282, 3343, 60568, 128318, 119250,\n    4298, 51871, 41336, 71759, 21921, 45074, 98169, 145889, 99427, 11350, 1237, 5520, 28799, 7803, 53702, 21026,\n    136352, 38293, 128690, 12158, 90132, 44600, 10184, 26957, 39459, 126025, 78904, 82999, 59373, 39301, 150198, 120529,\n    153042, 20177, 50089, 14764, 271571, 30530, 123161, 38975, 101562, 22941, 5648, 124654, 109243, 69817, 71675, 49162,\n    106884, 21241, 107795, 30258, 16572, 188262, 141456, 7688, 60718, 8271, 11044, 32440, 104608, 103419, 236109, 93156,\n    43293, 128929, 42107, 67180, 25201, 115254, 185488, 130954, 72813, 167547, 20537, 39969, 38432, 22582, 184022, 1139,\n    27199, 5655, 17767, 97412, 122606, 209377, 27070, 35871, 326617, 188954, 42680, 73512, 80911, 22629, 3011, 95021,\n    315242, 157737, 383, 41821, 41808, 19335, 27950, 15674, 25677, 110950, 35375, 76835, 59108, 57370, 35262, 16569,\n    160415, 37706, 78086, 32041, 49691, 137143, 9782, 172080, 50148, 77917, 6323, 10110, 69172, 17711, 21795, 59511,\n    76184, 135114, 31046, 132319, 59105, 157578, 20549, 80778, 57649, 158421, 65143, 4575, 72235, 21899, 10797, 92745,\n    34035, 106079, 80159, 4508, 78304, 25350, 75457, 46458, 32937, 25623, 47, 8531, 104751, 84953, 8138, 36508,\n    187199, 66310, 115274, 13253, 32461, 38536, 1916, 42007, 187160, 35055, 26325, 84394, 35963, 94216, 45590, 97782\n];\n//# sourceMappingURL=generated-prefix-list-browser.js.map","import { CodeError, TypedEventEmitter } from '@libp2p/interface';\nimport { PeerSet } from '@libp2p/peer-collections';\nimport { PeerQueue } from '@libp2p/utils/peer-queue';\nimport { pbStream } from 'it-protobuf-stream';\nimport { Message, MessageType } from '../message/dht.js';\nimport * as utils from '../utils.js';\nimport { KBucket, isLeafBucket } from './k-bucket.js';\nexport const KAD_CLOSE_TAG_NAME = 'kad-close';\nexport const KAD_CLOSE_TAG_VALUE = 50;\nexport const KBUCKET_SIZE = 20;\nexport const PREFIX_LENGTH = 32;\nexport const PING_TIMEOUT = 10000;\nexport const PING_CONCURRENCY = 10;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTable extends TypedEventEmitter {\n    kBucketSize;\n    kb;\n    pingQueue;\n    log;\n    components;\n    prefixLength;\n    splitThreshold;\n    pingTimeout;\n    pingConcurrency;\n    running;\n    protocol;\n    tagName;\n    tagValue;\n    metrics;\n    constructor(components, init) {\n        super();\n        this.components = components;\n        this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);\n        this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;\n        this.pingTimeout = init.pingTimeout ?? PING_TIMEOUT;\n        this.pingConcurrency = init.pingConcurrency ?? PING_CONCURRENCY;\n        this.running = false;\n        this.protocol = init.protocol;\n        this.tagName = init.tagName ?? KAD_CLOSE_TAG_NAME;\n        this.tagValue = init.tagValue ?? KAD_CLOSE_TAG_VALUE;\n        this.prefixLength = init.prefixLength ?? PREFIX_LENGTH;\n        this.splitThreshold = init.splitThreshold ?? KBUCKET_SIZE;\n        this.pingQueue = new PeerQueue({\n            concurrency: this.pingConcurrency,\n            metricName: `${init.logPrefix.replaceAll(':', '_')}_ping_queue`,\n            metrics: this.components.metrics\n        });\n        this.pingQueue.addEventListener('error', evt => {\n            this.log.error('error pinging peer', evt.detail);\n        });\n        if (this.components.metrics != null) {\n            this.metrics = {\n                routingTableSize: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(':', '_')}_routing_table_size`),\n                routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(':', '_')}_routing_table_kad_bucket_total`),\n                routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(':', '_')}_routing_table_kad_bucket_average_occupancy`),\n                routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(':', '_')}_routing_table_kad_bucket_max_depth`)\n            };\n        }\n    }\n    isStarted() {\n        return this.running;\n    }\n    async start() {\n        this.running = true;\n        const kBuck = new KBucket({\n            localPeer: {\n                kadId: await utils.convertPeerId(this.components.peerId),\n                peerId: this.components.peerId\n            },\n            kBucketSize: this.kBucketSize,\n            prefixLength: this.prefixLength,\n            splitThreshold: this.splitThreshold,\n            numberOfNodesToPing: 1\n        });\n        this.kb = kBuck;\n        // test whether to evict peers\n        kBuck.addEventListener('ping', (evt) => {\n            this._onPing(evt).catch(err => {\n                this.log.error('could not process k-bucket ping event', err);\n            });\n        });\n        let peerStorePeers = 0;\n        // add existing peers from the peer store to routing table\n        for (const peer of await this.components.peerStore.all()) {\n            if (peer.protocols.includes(this.protocol)) {\n                const id = await utils.convertPeerId(peer.id);\n                this.kb.add({ kadId: id, peerId: peer.id });\n                peerStorePeers++;\n            }\n        }\n        this.log('added %d peer store peers to the routing table', peerStorePeers);\n        // tag kad-close peers\n        this._tagPeers(kBuck);\n    }\n    async stop() {\n        this.running = false;\n        this.pingQueue.clear();\n        this.kb = undefined;\n    }\n    /**\n     * Keep track of our k-closest peers and tag them in the peer store as such\n     * - this will lower the chances that connections to them get closed when\n     * we reach connection limits\n     */\n    _tagPeers(kBuck) {\n        let kClosest = new PeerSet();\n        const updatePeerTags = utils.debounce(() => {\n            const newClosest = new PeerSet(kBuck.closest(kBuck.localPeer.kadId, KBUCKET_SIZE));\n            const addedPeers = newClosest.difference(kClosest);\n            const removedPeers = kClosest.difference(newClosest);\n            Promise.resolve()\n                .then(async () => {\n                for (const peer of addedPeers) {\n                    await this.components.peerStore.merge(peer, {\n                        tags: {\n                            [this.tagName]: {\n                                value: this.tagValue\n                            }\n                        }\n                    });\n                }\n                for (const peer of removedPeers) {\n                    await this.components.peerStore.merge(peer, {\n                        tags: {\n                            [this.tagName]: undefined\n                        }\n                    });\n                }\n            })\n                .catch(err => {\n                this.log.error('Could not update peer tags', err);\n            });\n            kClosest = newClosest;\n        });\n        kBuck.addEventListener('added', (evt) => {\n            updatePeerTags();\n            this.safeDispatchEvent('peer:add', { detail: evt.detail.peerId });\n        });\n        kBuck.addEventListener('removed', (evt) => {\n            updatePeerTags();\n            this.safeDispatchEvent('peer:remove', { detail: evt.detail.peerId });\n        });\n    }\n    /**\n     * Called on the `ping` event from `k-bucket` when a bucket is full\n     * and cannot split.\n     *\n     * `oldContacts.length` is defined by the `numberOfNodesToPing` param\n     * passed to the `k-bucket` constructor.\n     *\n     * `oldContacts` will not be empty and is the list of contacts that\n     * have not been contacted for the longest.\n     */\n    async _onPing(evt) {\n        if (!this.running) {\n            return;\n        }\n        const { oldContacts, newContact } = evt.detail;\n        const results = await Promise.all(oldContacts.map(async (oldContact) => {\n            // if a previous ping wants us to ping this contact, re-use the result\n            const pingJob = this.pingQueue.find(oldContact.peerId);\n            if (pingJob != null) {\n                return pingJob.join();\n            }\n            return this.pingQueue.add(async () => {\n                let stream;\n                try {\n                    const options = {\n                        signal: AbortSignal.timeout(this.pingTimeout)\n                    };\n                    this.log('pinging old contact %p', oldContact.peerId);\n                    const connection = await this.components.connectionManager.openConnection(oldContact.peerId, options);\n                    stream = await connection.newStream(this.protocol, options);\n                    const pb = pbStream(stream);\n                    await pb.write({\n                        type: MessageType.PING\n                    }, Message, options);\n                    const response = await pb.read(Message, options);\n                    await pb.unwrap().close();\n                    if (response.type !== MessageType.PING) {\n                        throw new CodeError(`Incorrect message type received, expected PING got ${response.type}`, 'ERR_BAD_PING_RESPONSE');\n                    }\n                    return true;\n                }\n                catch (err) {\n                    if (this.running && this.kb != null) {\n                        // only evict peers if we are still running, otherwise we evict\n                        // when dialing is cancelled due to shutdown in progress\n                        this.log.error('could not ping peer %p', oldContact.peerId, err);\n                        this.log('evicting old contact after ping failed %p', oldContact.peerId);\n                        this.kb.remove(oldContact.kadId);\n                    }\n                    stream?.abort(err);\n                    return false;\n                }\n                finally {\n                    this.metrics?.routingTableSize.update(this.size);\n                }\n            }, {\n                peerId: oldContact.peerId\n            });\n        }));\n        const responded = results\n            .filter(res => res)\n            .length;\n        if (this.running && responded < oldContacts.length && this.kb != null) {\n            this.log('adding new contact %p', newContact.peerId);\n            this.kb.add(newContact);\n        }\n    }\n    // -- Public Interface\n    /**\n     * Amount of currently stored peers\n     */\n    get size() {\n        if (this.kb == null) {\n            return 0;\n        }\n        return this.kb.count();\n    }\n    /**\n     * Find a specific peer by id\n     */\n    async find(peer) {\n        const key = await utils.convertPeerId(peer);\n        return this.kb?.get(key)?.peerId;\n    }\n    /**\n     * Retrieve the closest peers to the given kadId\n     */\n    closestPeer(kadId) {\n        const res = this.closestPeers(kadId, 1);\n        if (res.length > 0) {\n            return res[0];\n        }\n        return undefined;\n    }\n    /**\n     * Retrieve the `count`-closest peers to the given kadId\n     */\n    closestPeers(kadId, count = this.kBucketSize) {\n        if (this.kb == null) {\n            return [];\n        }\n        return [...this.kb.closest(kadId, count)];\n    }\n    /**\n     * Add or update the routing table with the given peer\n     */\n    async add(peerId) {\n        if (this.kb == null) {\n            throw new Error('RoutingTable is not started');\n        }\n        const kadId = await utils.convertPeerId(peerId);\n        this.kb.add({ kadId, peerId });\n        this.log('added %p with kad id %b', peerId, kadId);\n        this.updateMetrics();\n    }\n    /**\n     * Remove a given peer from the table\n     */\n    async remove(peer) {\n        if (this.kb == null) {\n            throw new Error('RoutingTable is not started');\n        }\n        const id = await utils.convertPeerId(peer);\n        this.kb.remove(id);\n        this.updateMetrics();\n    }\n    updateMetrics() {\n        if (this.metrics == null || this.kb == null) {\n            return;\n        }\n        let size = 0;\n        let buckets = 0;\n        let maxDepth = 0;\n        function count(bucket) {\n            if (isLeafBucket(bucket)) {\n                if (bucket.depth > maxDepth) {\n                    maxDepth = bucket.depth;\n                }\n                buckets++;\n                size += bucket.peers.length;\n                return;\n            }\n            count(bucket.left);\n            count(bucket.right);\n        }\n        count(this.kb.root);\n        this.metrics.routingTableSize.update(size);\n        this.metrics.routingTableKadBucketTotal.update(buckets);\n        this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));\n        this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);\n    }\n}\n//# sourceMappingURL=index.js.map","import { TypedEventEmitter } from '@libp2p/interface';\nimport map from 'it-map';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport { PeerDistanceList } from '../peer-list/peer-distance-list.js';\nimport { KBUCKET_SIZE } from './index.js';\nfunction arrayEquals(array1, array2) {\n    if (array1 === array2) {\n        return true;\n    }\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    for (let i = 0, length = array1.length; i < length; ++i) {\n        if (array1[i] !== array2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureInt8(name, val) {\n    if (!(val instanceof Uint8Array)) {\n        throw new TypeError(name + ' is not a Uint8Array');\n    }\n    if (val.byteLength !== 32) {\n        throw new TypeError(name + ' had incorrect length');\n    }\n}\nexport function isLeafBucket(obj) {\n    return Array.isArray(obj?.peers);\n}\n/**\n * Implementation of a Kademlia DHT routing table as a prefix binary trie with\n * configurable prefix length, bucket split threshold and size.\n */\nexport class KBucket extends TypedEventEmitter {\n    root;\n    localPeer;\n    prefixLength;\n    splitThreshold;\n    kBucketSize;\n    numberOfNodesToPing;\n    constructor(options) {\n        super();\n        this.localPeer = options.localPeer;\n        this.prefixLength = options.prefixLength;\n        this.kBucketSize = options.kBucketSize ?? KBUCKET_SIZE;\n        this.splitThreshold = options.splitThreshold ?? this.kBucketSize;\n        this.numberOfNodesToPing = options.numberOfNodesToPing ?? 3;\n        ensureInt8('options.localPeer.kadId', options.localPeer.kadId);\n        this.root = {\n            prefix: '',\n            depth: 0,\n            peers: []\n        };\n    }\n    /**\n     * Adds a contact to the k-bucket.\n     *\n     * @param {Peer} peer - the contact object to add\n     */\n    add(peer) {\n        ensureInt8('peer.kadId', peer?.kadId);\n        const bucket = this._determineBucket(peer.kadId);\n        // check if the contact already exists\n        if (this._indexOf(bucket, peer.kadId) > -1) {\n            return;\n        }\n        // are there too many peers in the bucket and can we make the trie deeper?\n        if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {\n            // split the bucket\n            this._split(bucket);\n            // try again\n            this.add(peer);\n            return;\n        }\n        // is there space in the bucket?\n        if (bucket.peers.length < this.kBucketSize) {\n            bucket.peers.push(peer);\n            this.safeDispatchEvent('added', { detail: peer });\n            return;\n        }\n        // we are at the bottom of the trie and the bucket is full so we can't add\n        // any more peers.\n        //\n        // instead ping the first this.numberOfNodesToPing in order to determine\n        // if they are still online.\n        //\n        // only add the new peer if one of the pinged nodes does not respond, this\n        // prevents DoS flooding with new invalid contacts.\n        this.safeDispatchEvent('ping', {\n            detail: {\n                oldContacts: bucket.peers.slice(0, this.numberOfNodesToPing),\n                newContact: peer\n            }\n        });\n    }\n    /**\n     * Get 0-n closest contacts to the provided node id. \"Closest\" here means:\n     * closest according to the XOR metric of the contact node id.\n     *\n     * @param {Uint8Array} id - Contact node id\n     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id\n     */\n    *closest(id, n = this.kBucketSize) {\n        const list = new PeerDistanceList(id, n);\n        for (const peer of this.toIterable()) {\n            list.addWitKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);\n        }\n        yield* map(list.peers, info => info.id);\n    }\n    /**\n     * Counts the total number of contacts in the tree.\n     *\n     * @returns {number} The number of contacts held in the tree\n     */\n    count() {\n        function countBucket(bucket) {\n            if (isLeafBucket(bucket)) {\n                return bucket.peers.length;\n            }\n            let count = 0;\n            if (bucket.left != null) {\n                count += countBucket(bucket.left);\n            }\n            if (bucket.right != null) {\n                count += countBucket(bucket.right);\n            }\n            return count;\n        }\n        return countBucket(this.root);\n    }\n    /**\n     * Get a contact by its exact ID.\n     * If this is a leaf, loop through the bucket contents and return the correct\n     * contact if we have it or null if not. If this is an inner node, determine\n     * which branch of the tree to traverse and repeat.\n     *\n     * @param {Uint8Array} kadId - The ID of the contact to fetch.\n     * @returns {object | undefined} The contact if available, otherwise null\n     */\n    get(kadId) {\n        const bucket = this._determineBucket(kadId);\n        const index = this._indexOf(bucket, kadId);\n        return bucket.peers[index];\n    }\n    /**\n     * Removes contact with the provided id.\n     *\n     * @param {Uint8Array} kadId - The ID of the contact to remove\n     */\n    remove(kadId) {\n        const bucket = this._determineBucket(kadId);\n        const index = this._indexOf(bucket, kadId);\n        if (index > -1) {\n            const peer = bucket.peers.splice(index, 1)[0];\n            this.safeDispatchEvent('removed', {\n                detail: peer\n            });\n        }\n    }\n    /**\n     * Similar to `toArray()` but instead of buffering everything up into an\n     * array before returning it, yields contacts as they are encountered while\n     * walking the tree.\n     *\n     * @returns {Iterable} All of the contacts in the tree, as an iterable\n     */\n    *toIterable() {\n        function* iterate(bucket) {\n            if (isLeafBucket(bucket)) {\n                yield* bucket.peers;\n                return;\n            }\n            yield* iterate(bucket.left);\n            yield* iterate(bucket.right);\n        }\n        yield* iterate(this.root);\n    }\n    /**\n     * Default distance function. Finds the XOR distance between firstId and\n     * secondId.\n     *\n     * @param  {Uint8Array} firstId - Uint8Array containing first id.\n     * @param  {Uint8Array} secondId - Uint8Array containing second id.\n     * @returns {number} Integer The XOR distance between firstId and secondId.\n     */\n    distance(firstId, secondId) {\n        return BigInt('0x' + uint8ArrayToString(uint8ArrayXor(firstId, secondId), 'base16'));\n    }\n    /**\n     * Determines whether the id at the bitIndex is 0 or 1\n     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise\n     *\n     * @param {Uint8Array} kadId - Id to compare localNodeId with\n     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.\n     */\n    _determineBucket(kadId) {\n        const bitString = uint8ArrayToString(kadId, 'base2');\n        const prefix = bitString.substring(0, this.prefixLength);\n        function findBucket(bucket, bitIndex = 0) {\n            if (isLeafBucket(bucket)) {\n                return bucket;\n            }\n            const bit = prefix[bitIndex];\n            if (bit === '0') {\n                return findBucket(bucket.left, bitIndex + 1);\n            }\n            return findBucket(bucket.right, bitIndex + 1);\n        }\n        return findBucket(this.root);\n    }\n    /**\n     * Returns the index of the contact with provided\n     * id if it exists, returns -1 otherwise.\n     *\n     * @param {object} bucket - internal object that has 2 leafs: left and right\n     * @param {Uint8Array} kadId - KadId of peer\n     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.\n     */\n    _indexOf(bucket, kadId) {\n        return bucket.peers.findIndex(peer => arrayEquals(peer.kadId, kadId));\n    }\n    /**\n     * Modify the bucket, turn it from a leaf bucket to an internal bucket\n     *\n     * @param {any} bucket - bucket for splitting\n     */\n    _split(bucket) {\n        const depth = bucket.depth + 1;\n        // create child buckets\n        const left = {\n            prefix: '0',\n            depth,\n            peers: []\n        };\n        const right = {\n            prefix: '1',\n            depth,\n            peers: []\n        };\n        // redistribute peers\n        for (const peer of bucket.peers) {\n            const bitString = uint8ArrayToString(peer.kadId, 'base2');\n            if (bitString[depth] === '0') {\n                left.peers.push(peer);\n            }\n            else {\n                right.peers.push(peer);\n            }\n        }\n        // convert leaf bucket to internal bucket\n        // @ts-expect-error peers is not a property of LeafBucket\n        delete bucket.peers;\n        // @ts-expect-error left is not a property of LeafBucket\n        bucket.left = left;\n        // @ts-expect-error right is not a property of LeafBucket\n        bucket.right = right;\n    }\n}\n//# sourceMappingURL=k-bucket.js.map","import { randomBytes } from '@libp2p/crypto';\nimport { setMaxListeners } from '@libp2p/interface';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport length from 'it-length';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } from '../constants.js';\nimport GENERATED_PREFIXES from './generated-prefix-list.js';\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTableRefresh {\n    log;\n    peerRouting;\n    routingTable;\n    refreshInterval;\n    refreshQueryTimeout;\n    commonPrefixLengthRefreshedAt;\n    refreshTimeoutId;\n    constructor(components, init) {\n        const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;\n        this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);\n        this.peerRouting = peerRouting;\n        this.routingTable = routingTable;\n        this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;\n        this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;\n        this.commonPrefixLengthRefreshedAt = [];\n        this.refreshTable = this.refreshTable.bind(this);\n    }\n    async afterStart() {\n        this.log(`refreshing routing table every ${this.refreshInterval}ms`);\n        this.refreshTable(true);\n    }\n    async stop() {\n        if (this.refreshTimeoutId != null) {\n            clearTimeout(this.refreshTimeoutId);\n        }\n    }\n    /**\n     * To speed lookups, we seed the table with random PeerIds. This means\n     * when we are asked to locate a peer on the network, we can find a KadId\n     * that is close to the requested peer ID and query that, then network\n     * peers will tell us who they know who is close to the fake ID\n     */\n    refreshTable(force = false) {\n        this.log('refreshing routing table');\n        const prefixLength = this._maxCommonPrefix();\n        const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n        this.log(`max common prefix length ${prefixLength}`);\n        this.log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`);\n        /**\n         * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n         * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n         * is smaller.\n         *\n         * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n         * before a very high max Cpl for which we do have peers in the network.\n         *\n         * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n         * the programmer had paid more attention in the Math classes at university.\n         *\n         * So, please be patient and a doc explaining it will be published soon.\n         *\n         * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n         */\n        Promise.all(refreshCpls.map(async (lastRefresh, index) => {\n            try {\n                await this._refreshCommonPrefixLength(index, lastRefresh, force);\n                if (this._numPeersForCpl(prefixLength) === 0) {\n                    const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n                    for (let n = index + 1; n < lastCpl + 1; n++) {\n                        try {\n                            await this._refreshCommonPrefixLength(n, lastRefresh, force);\n                        }\n                        catch (err) {\n                            this.log.error(err);\n                        }\n                    }\n                }\n            }\n            catch (err) {\n                this.log.error(err);\n            }\n        })).catch(err => {\n            this.log.error(err);\n        }).then(() => {\n            this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);\n            if (this.refreshTimeoutId.unref != null) {\n                this.refreshTimeoutId.unref();\n            }\n        }).catch(err => {\n            this.log.error(err);\n        });\n    }\n    async _refreshCommonPrefixLength(cpl, lastRefresh, force) {\n        if (!force && lastRefresh.getTime() > (Date.now() - this.refreshInterval)) {\n            this.log('not running refresh for cpl %s as time since last refresh not above interval', cpl);\n            return;\n        }\n        // gen a key for the query to refresh the cpl\n        const peerId = await this._generateRandomPeerId(cpl);\n        this.log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this.routingTable.size);\n        const signal = AbortSignal.timeout(this.refreshQueryTimeout);\n        setMaxListeners(Infinity, signal);\n        const peers = await length(this.peerRouting.getClosestPeers(peerId.toBytes(), {\n            signal\n        }));\n        this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);\n        this.log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this.routingTable.size);\n    }\n    _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n        if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n            maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n        }\n        const dates = [];\n        for (let i = 0; i <= maxCommonPrefix; i++) {\n            // defaults to the zero value if we haven't refreshed it yet.\n            dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? new Date();\n        }\n        return dates;\n    }\n    async _generateRandomPeerId(targetCommonPrefixLength) {\n        if (this.routingTable.kb == null) {\n            throw new Error('Routing table not started');\n        }\n        const randomData = randomBytes(2);\n        const randomUint16 = (randomData[1] << 8) + randomData[0];\n        const key = await this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);\n        return peerIdFromBytes(key);\n    }\n    async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {\n        if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n            throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);\n        }\n        const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n        const localPrefix = view.getUint16(0, false);\n        // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n        // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n        // to our randomly generated prefix.\n        const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength);\n        // Combine the toggled local prefix and the random bits at the correct offset\n        // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n        const mask = 65535 << (16 - (targetCommonPrefixLength + 1));\n        const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask);\n        // Convert to a known peer ID.\n        const keyPrefix = GENERATED_PREFIXES[targetPrefix];\n        const keyBuffer = new ArrayBuffer(34);\n        const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n        keyView.setUint8(0, sha256.code);\n        keyView.setUint8(1, 32);\n        keyView.setUint32(2, keyPrefix, false);\n        return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);\n    }\n    /**\n     * returns the maximum common prefix length between any peer in the table\n     * and the current peer\n     */\n    _maxCommonPrefix() {\n        // xor our KadId with every KadId in the k-bucket tree,\n        // return the longest id prefix that is the same\n        let prefixLength = 0;\n        for (const length of this._prefixLengths()) {\n            if (length > prefixLength) {\n                prefixLength = length;\n            }\n        }\n        return prefixLength;\n    }\n    /**\n     * Returns the number of peers in the table with a given prefix length\n     */\n    _numPeersForCpl(prefixLength) {\n        let count = 0;\n        for (const length of this._prefixLengths()) {\n            if (length === prefixLength) {\n                count++;\n            }\n        }\n        return count;\n    }\n    /**\n     * Yields the common prefix length of every peer in the table\n     */\n    *_prefixLengths() {\n        if (this.routingTable.kb == null) {\n            return;\n        }\n        for (const { kadId } of this.routingTable.kb.toIterable()) {\n            const distance = uint8ArrayXor(this.routingTable.kb.localPeer.kadId, kadId);\n            let leadingZeros = 0;\n            for (const byte of distance) {\n                if (byte === 0) {\n                    leadingZeros++;\n                }\n                else {\n                    break;\n                }\n            }\n            yield leadingZeros;\n        }\n    }\n}\n//# sourceMappingURL=refresh.js.map","import { CodeError } from '@libp2p/interface';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { CID } from 'multiformats/cid';\nexport class AddProviderHandler {\n    providers;\n    log;\n    constructor(components, init) {\n        this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);\n        this.providers = init.providers;\n    }\n    async handle(peerId, msg) {\n        this.log('start');\n        if (msg.key == null || msg.key.length === 0) {\n            throw new CodeError('Missing key', 'ERR_MISSING_KEY');\n        }\n        let cid;\n        try {\n            // this is actually just the multihash, not the whole CID\n            cid = CID.decode(msg.key);\n        }\n        catch (err) {\n            throw new CodeError('Invalid CID', 'ERR_INVALID_CID');\n        }\n        if (msg.providers == null || msg.providers.length === 0) {\n            this.log.error('no providers found in message');\n        }\n        await Promise.all(msg.providers.map(async (pi) => {\n            // Ignore providers not from the originator\n            if (!peerId.equals(pi.id)) {\n                this.log('invalid provider peer %p from %p', pi.id, peerId);\n                return;\n            }\n            if (pi.multiaddrs.length < 1) {\n                this.log('no valid addresses for provider %p. Ignore', peerId);\n                return;\n            }\n            this.log('received provider %p for %s (addrs %s)', peerId, cid, pi.multiaddrs.map((m) => multiaddr(m).toString()));\n            await this.providers.addProvider(cid, peerIdFromBytes(pi.id));\n        }));\n        return undefined;\n    }\n}\n//# sourceMappingURL=add-provider.js.map","import { CodeError } from '@libp2p/interface';\nimport { protocols } from '@multiformats/multiaddr';\nimport { equals as uint8ArrayEquals } from 'uint8arrays';\nimport { MessageType } from '../../message/dht.js';\nexport class FindNodeHandler {\n    peerRouting;\n    peerInfoMapper;\n    peerId;\n    addressManager;\n    log;\n    constructor(components, init) {\n        const { peerRouting, logPrefix } = init;\n        this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);\n        this.peerId = components.peerId;\n        this.addressManager = components.addressManager;\n        this.peerRouting = peerRouting;\n        this.peerInfoMapper = init.peerInfoMapper;\n    }\n    /**\n     * Process `FindNode` DHT messages\n     */\n    async handle(peerId, msg) {\n        this.log('incoming request from %p for peers closer to %b', peerId, msg.key);\n        if (msg.key == null) {\n            throw new CodeError('Invalid FIND_NODE message received - key was missing', 'ERR_INVALID_MESSAGE');\n        }\n        const closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);\n        if (uint8ArrayEquals(this.peerId.toBytes(), msg.key)) {\n            closer.push({\n                id: this.peerId,\n                multiaddrs: this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n            });\n        }\n        const response = {\n            type: MessageType.FIND_NODE,\n            clusterLevel: msg.clusterLevel,\n            closer: closer\n                .map(this.peerInfoMapper)\n                .filter(({ multiaddrs }) => multiaddrs.length)\n                .map(peerInfo => ({\n                id: peerInfo.id.toBytes(),\n                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)\n            })),\n            providers: []\n        };\n        if (response.closer.length === 0) {\n            this.log('could not find any peers closer to %b than %p', msg.key, peerId);\n        }\n        return response;\n    }\n}\n//# sourceMappingURL=find-node.js.map","import { CodeError } from '@libp2p/interface';\nimport { CID } from 'multiformats/cid';\nimport { MessageType } from '../../message/dht.js';\nexport class GetProvidersHandler {\n    peerRouting;\n    providers;\n    peerStore;\n    peerInfoMapper;\n    log;\n    constructor(components, init) {\n        const { peerRouting, providers, logPrefix } = init;\n        this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);\n        this.peerStore = components.peerStore;\n        this.peerRouting = peerRouting;\n        this.providers = providers;\n        this.peerInfoMapper = init.peerInfoMapper;\n    }\n    async handle(peerId, msg) {\n        if (msg.key == null) {\n            throw new CodeError('Invalid GET_PROVIDERS message received - key was missing', 'ERR_INVALID_MESSAGE');\n        }\n        let cid;\n        try {\n            cid = CID.decode(msg.key);\n        }\n        catch (err) {\n            throw new CodeError('Invalid CID', 'ERR_INVALID_CID');\n        }\n        this.log('%p asking for providers for %s', peerId, cid);\n        const [peers, closer] = await Promise.all([\n            this.providers.getProviders(cid),\n            this.peerRouting.getCloserPeersOffline(msg.key, peerId)\n        ]);\n        const providerPeers = await this._getPeers(peers);\n        const closerPeers = await this._getPeers(closer.map(({ id }) => id));\n        const response = {\n            type: MessageType.GET_PROVIDERS,\n            key: msg.key,\n            clusterLevel: msg.clusterLevel,\n            closer: closerPeers\n                .map(this.peerInfoMapper)\n                .filter(({ multiaddrs }) => multiaddrs.length)\n                .map(peerInfo => ({\n                id: peerInfo.id.toBytes(),\n                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)\n            })),\n            providers: providerPeers\n                .map(this.peerInfoMapper)\n                .filter(({ multiaddrs }) => multiaddrs.length)\n                .map(peerInfo => ({\n                id: peerInfo.id.toBytes(),\n                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)\n            }))\n        };\n        this.log('got %s providers %s closerPeers', response.providers.length, response.closer.length);\n        return response;\n    }\n    async _getAddresses(peerId) {\n        return [];\n    }\n    async _getPeers(peerIds) {\n        const output = [];\n        for (const peerId of peerIds) {\n            try {\n                const peer = await this.peerStore.get(peerId);\n                const peerAfterFilter = this.peerInfoMapper({\n                    id: peerId,\n                    multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr)\n                });\n                if (peerAfterFilter.multiaddrs.length > 0) {\n                    output.push(peerAfterFilter);\n                }\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n        }\n        return output;\n    }\n}\n//# sourceMappingURL=get-providers.js.map","import { CodeError } from '@libp2p/interface';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { MAX_RECORD_AGE } from '../../constants.js';\nimport { MessageType } from '../../message/dht.js';\nimport { bufferToRecordKey, isPublicKeyKey, fromPublicKeyKey } from '../../utils.js';\nexport class GetValueHandler {\n    peerStore;\n    datastore;\n    peerRouting;\n    log;\n    constructor(components, init) {\n        this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);\n        this.peerStore = components.peerStore;\n        this.datastore = components.datastore;\n        this.peerRouting = init.peerRouting;\n    }\n    async handle(peerId, msg) {\n        const key = msg.key;\n        this.log('%p asked for key %b', peerId, key);\n        if (key == null || key.length === 0) {\n            throw new CodeError('Invalid key', 'ERR_INVALID_KEY');\n        }\n        const response = {\n            type: MessageType.GET_VALUE,\n            key,\n            clusterLevel: msg.clusterLevel,\n            closer: [],\n            providers: []\n        };\n        if (isPublicKeyKey(key)) {\n            this.log('is public key');\n            const idFromKey = fromPublicKeyKey(key);\n            let pubKey;\n            try {\n                const peer = await this.peerStore.get(idFromKey);\n                if (peer.id.publicKey == null) {\n                    throw new CodeError('No public key found in key book', 'ERR_NOT_FOUND');\n                }\n                pubKey = peer.id.publicKey;\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    throw err;\n                }\n            }\n            if (pubKey != null) {\n                this.log('returning found public key');\n                response.record = new Libp2pRecord(key, pubKey, new Date()).serialize();\n                return response;\n            }\n        }\n        const [record, closer] = await Promise.all([\n            this._checkLocalDatastore(key),\n            this.peerRouting.getCloserPeersOffline(key, peerId)\n        ]);\n        if (record != null) {\n            this.log('had record for %b in local datastore', key);\n            response.record = record.serialize();\n        }\n        if (closer.length > 0) {\n            this.log('had %s closer peers in routing table', closer.length);\n            response.closer = closer.map(peerInfo => ({\n                id: peerInfo.id.toBytes(),\n                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)\n            }));\n        }\n        return response;\n    }\n    /**\n     * Try to fetch a given record by from the local datastore.\n     * Returns the record if it is still valid, meaning\n     * - it was either authored by this node, or\n     * - it was received less than `MAX_RECORD_AGE` ago.\n     */\n    async _checkLocalDatastore(key) {\n        this.log('checkLocalDatastore looking for %b', key);\n        const dsKey = bufferToRecordKey(key);\n        // Fetch value from ds\n        let rawRecord;\n        try {\n            rawRecord = await this.datastore.get(dsKey);\n        }\n        catch (err) {\n            if (err.code === 'ERR_NOT_FOUND') {\n                return undefined;\n            }\n            throw err;\n        }\n        // Create record from the returned bytes\n        const record = Libp2pRecord.deserialize(rawRecord);\n        if (record == null) {\n            throw new CodeError('Invalid record', 'ERR_INVALID_RECORD');\n        }\n        // Check validity: compare time received with max record age\n        if (record.timeReceived == null ||\n            Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {\n            // If record is bad delete it and return\n            await this.datastore.delete(dsKey);\n            return undefined;\n        }\n        // Record is valid\n        return record;\n    }\n}\n//# sourceMappingURL=get-value.js.map","export class PingHandler {\n    log;\n    constructor(components, init) {\n        this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);\n    }\n    async handle(peerId, msg) {\n        this.log('ping from %p', peerId);\n        return msg;\n    }\n}\n//# sourceMappingURL=ping.js.map","import { CodeError } from '@libp2p/interface';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { verifyRecord } from '../../record/validators.js';\nimport { bufferToRecordKey } from '../../utils.js';\nexport class PutValueHandler {\n    components;\n    validators;\n    log;\n    constructor(components, init) {\n        const { validators } = init;\n        this.components = components;\n        this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);\n        this.validators = validators;\n    }\n    async handle(peerId, msg) {\n        const key = msg.key;\n        this.log('%p asked us to store value for key %b', peerId, key);\n        if (msg.record == null) {\n            const errMsg = `Empty record from: ${peerId.toString()}`;\n            this.log.error(errMsg);\n            throw new CodeError(errMsg, 'ERR_EMPTY_RECORD');\n        }\n        try {\n            const deserializedRecord = Libp2pRecord.deserialize(msg.record);\n            await verifyRecord(this.validators, deserializedRecord);\n            deserializedRecord.timeReceived = new Date();\n            const recordKey = bufferToRecordKey(deserializedRecord.key);\n            await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());\n            this.log('put record for %b into datastore under key %k', key, recordKey);\n        }\n        catch (err) {\n            this.log('did not put record for key %b into datastore %o', key, err);\n        }\n        return msg;\n    }\n}\n//# sourceMappingURL=put-value.js.map","import * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { Message, MessageType } from '../message/dht.js';\nimport { AddProviderHandler } from './handlers/add-provider.js';\nimport { FindNodeHandler } from './handlers/find-node.js';\nimport { GetProvidersHandler } from './handlers/get-providers.js';\nimport { GetValueHandler } from './handlers/get-value.js';\nimport { PingHandler } from './handlers/ping.js';\nimport { PutValueHandler } from './handlers/put-value.js';\nexport class RPC {\n    handlers;\n    routingTable;\n    log;\n    constructor(components, init) {\n        const { providers, peerRouting, validators, logPrefix, peerInfoMapper } = init;\n        this.log = components.logger.forComponent(`${logPrefix}:rpc`);\n        this.routingTable = init.routingTable;\n        this.handlers = {\n            [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, { peerRouting, logPrefix }),\n            [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, { validators, logPrefix }),\n            [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, { peerRouting, logPrefix, peerInfoMapper }),\n            [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, { providers, logPrefix }),\n            [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, { peerRouting, providers, logPrefix, peerInfoMapper }),\n            [MessageType.PING.toString()]: new PingHandler(components, { logPrefix })\n        };\n    }\n    /**\n     * Process incoming DHT messages\n     */\n    async handleMessage(peerId, msg) {\n        try {\n            await this.routingTable.add(peerId);\n        }\n        catch (err) {\n            this.log.error('Failed to update the kbucket store', err);\n        }\n        // get handler & execute it\n        const handler = this.handlers[msg.type];\n        if (handler == null) {\n            this.log.error(`no handler found for message type: ${msg.type}`);\n            return;\n        }\n        return handler.handle(peerId, msg);\n    }\n    /**\n     * Handle incoming streams on the dht protocol\n     */\n    onIncomingStream(data) {\n        Promise.resolve().then(async () => {\n            const { stream, connection } = data;\n            const peerId = connection.remotePeer;\n            try {\n                await this.routingTable.add(peerId);\n            }\n            catch (err) {\n                this.log.error(err);\n            }\n            const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\n            await pipe(stream, (source) => lp.decode(source), async function* (source) {\n                for await (const msg of source) {\n                    // handle the message\n                    const desMessage = Message.decode(msg);\n                    self.log('incoming %s from %p', desMessage.type, peerId);\n                    const res = await self.handleMessage(peerId, desMessage);\n                    // Not all handlers will return a response\n                    if (res != null) {\n                        yield Message.encode(res);\n                    }\n                }\n            }, (source) => lp.encode(source), stream);\n        })\n            .catch(err => {\n            this.log.error(err);\n        });\n    }\n}\n//# sourceMappingURL=index.js.map","import { CustomEvent, TypedEventEmitter } from '@libp2p/interface';\n/**\n * Receives notifications of new peers joining the network that support the DHT protocol\n */\nexport class TopologyListener extends TypedEventEmitter {\n    log;\n    components;\n    protocol;\n    running;\n    registrarId;\n    constructor(components, init) {\n        super();\n        const { protocol, logPrefix } = init;\n        this.components = components;\n        this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);\n        this.running = false;\n        this.protocol = protocol;\n    }\n    isStarted() {\n        return this.running;\n    }\n    /**\n     * Start the network\n     */\n    async start() {\n        if (this.running) {\n            return;\n        }\n        this.running = true;\n        // register protocol with topology\n        this.registrarId = await this.components.registrar.register(this.protocol, {\n            onConnect: (peerId) => {\n                this.log('observed peer %p with protocol %s', peerId, this.protocol);\n                this.dispatchEvent(new CustomEvent('peer', {\n                    detail: peerId\n                }));\n            }\n        });\n    }\n    /**\n     * Stop all network activity\n     */\n    async stop() {\n        this.running = false;\n        // unregister protocol and handlers\n        if (this.registrarId != null) {\n            this.components.registrar.unregister(this.registrarId);\n            this.registrarId = undefined;\n        }\n    }\n}\n//# sourceMappingURL=topology-listener.js.map","import { peerIdFromBytes } from '@libp2p/peer-id';\nimport { Libp2pRecord } from '@libp2p/record';\nimport { isPrivateIp } from '@libp2p/utils/private-ip';\nimport { Key } from 'interface-datastore/key';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { RECORD_KEY_PREFIX } from './constants.js';\n// const IPNS_PREFIX = uint8ArrayFromString('/ipns/')\nconst PK_PREFIX = uint8ArrayFromString('/pk/');\nexport function removePrivateAddressesMapper(peer) {\n    return {\n        ...peer,\n        multiaddrs: peer.multiaddrs.filter(multiaddr => {\n            const [[type, addr]] = multiaddr.stringTuples();\n            // treat /dns, /dns4, and /dns6 addrs as public\n            if (type === 53 || type === 54 || type === 55) {\n                // localhost can be a dns address but it's private\n                if (addr === 'localhost') {\n                    return false;\n                }\n                return true;\n            }\n            if (type !== 4 && type !== 6) {\n                return false;\n            }\n            if (addr == null) {\n                return false;\n            }\n            const isPrivate = isPrivateIp(addr);\n            if (isPrivate == null) {\n                // not an ip address\n                return true;\n            }\n            return !isPrivate;\n        })\n    };\n}\nexport function removePublicAddressesMapper(peer) {\n    return {\n        ...peer,\n        multiaddrs: peer.multiaddrs.filter(multiaddr => {\n            const [[type, addr]] = multiaddr.stringTuples();\n            if (addr === 'localhost') {\n                return true;\n            }\n            if (type !== 4 && type !== 6) {\n                return false;\n            }\n            if (addr == null) {\n                return false;\n            }\n            const isPrivate = isPrivateIp(addr);\n            if (isPrivate == null) {\n                // not an ip address\n                return false;\n            }\n            return isPrivate;\n        })\n    };\n}\nexport function passthroughMapper(info) {\n    return info;\n}\n/**\n * Creates a DHT ID by hashing a given Uint8Array\n */\nexport async function convertBuffer(buf) {\n    const multihash = await sha256.digest(buf);\n    return multihash.digest;\n}\n/**\n * Creates a DHT ID by hashing a Peer ID\n */\nexport async function convertPeerId(peerId) {\n    return convertBuffer(peerId.toBytes());\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToKey(buf) {\n    return new Key('/' + uint8ArrayToString(buf, 'base32'), false);\n}\n/**\n * Convert a Uint8Array to their SHA2-256 hash\n */\nexport function bufferToRecordKey(buf) {\n    return new Key(`${RECORD_KEY_PREFIX}/${uint8ArrayToString(buf, 'base32')}`, false);\n}\n/**\n * Generate the key for a public key.\n */\nexport function keyForPublicKey(peer) {\n    return uint8ArrayConcat([\n        PK_PREFIX,\n        peer.toBytes()\n    ]);\n}\nexport function isPublicKeyKey(key) {\n    return uint8ArrayToString(key.subarray(0, 4)) === '/pk/';\n}\nexport function isIPNSKey(key) {\n    return uint8ArrayToString(key.subarray(0, 4)) === '/ipns/';\n}\nexport function fromPublicKeyKey(key) {\n    return peerIdFromBytes(key.subarray(4));\n}\n/**\n * Create a new put record, encodes and signs it if enabled\n */\nexport function createPutRecord(key, value) {\n    const timeReceived = new Date();\n    const rec = new Libp2pRecord(key, value, timeReceived);\n    return rec.serialize();\n}\nexport function debounce(callback, wait = 100) {\n    let timeout;\n    return () => {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => { callback(); }, wait);\n    };\n}\n// see https://github.com/multiformats/multiaddr/blob/master/protocols.csv\nconst P2P_CIRCUIT_CODE = 290;\nconst DNS4_CODE = 54;\nconst DNS6_CODE = 55;\nconst DNSADDR_CODE = 56;\nconst IP4_CODE = 4;\nconst IP6_CODE = 41;\nexport function multiaddrIsPublic(multiaddr) {\n    const tuples = multiaddr.stringTuples();\n    // p2p-circuit should not enable server mode\n    for (const tuple of tuples) {\n        if (tuple[0] === P2P_CIRCUIT_CODE) {\n            return false;\n        }\n    }\n    // dns4 or dns6 or dnsaddr\n    if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {\n        return true;\n    }\n    // ip4 or ip6\n    if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {\n        const result = isPrivateIp(`${tuples[0][1]}`);\n        const isPublic = result == null || !result;\n        return isPublic;\n    }\n    return false;\n}\n//# sourceMappingURL=utils.js.map","import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.addEventListener || emitter.on || emitter.addListener;\n\tconst removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\t\tif (options.filter && !options.filter(value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = error => {\n\t\t\tcancel();\n\t\t\treject(error);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\trejectHandler(options.signal.reason);\n\t\t\t}, {once: true});\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, {milliseconds: options.timeout});\n\t\ttimeout.cancel = cancel;\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]);\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\tif (options.filter && !options.filter(value)) {\n\t\t\tcancel();\n\t\t\treturn;\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\tif (options.signal) {\n\t\toptions.signal.addEventListener('abort', () => {\n\t\t\trejectHandler(options.signal.reason);\n\t\t}, {once: true});\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n","/**\n * @packageDocumentation\n *\n * A logger for libp2p based on the venerable [debug](https://www.npmjs.com/package/debug) module.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('libp2p:my:component:name')\n *\n * try {\n *   // an operation\n *   log('something happened: %s', 'it was ok')\n * } catch (err) {\n *   log.error('something bad happened: %o', err)\n * }\n *\n * log('with this peer: %p', {})\n * log('and this base58btc: %b', Uint8Array.from([0, 1, 2, 3]))\n * log('and this base32: %t', Uint8Array.from([4, 5, 6, 7]))\n * ```\n *\n * ```console\n * $ DEBUG=libp2p:* node index.js\n * something happened: it was ok\n * something bad happened: <stack trace>\n * with this peer: 12D3Foo\n * with this base58btc: Qmfoo\n * with this base32: bafyfoo\n * ```\n */\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64 } from 'multiformats/bases/base64';\nimport debug from 'weald';\nimport { truncatePeerId } from './utils.js';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\n/**\n * Create a component logger that will prefix any log messages with a truncated\n * peer id.\n *\n * @example\n *\n * ```TypeScript\n * import { peerLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const peerId = peerIdFromString('12D3FooBar')\n * const logger = peerLogger(peerId)\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"12oBar:my-component hello world\"\n * ```\n */\nexport function peerLogger(peerId, options = {}) {\n    return prefixLogger(truncatePeerId(peerId, options));\n}\n/**\n * Create a component logger that will prefix any log messages with the passed\n * string.\n *\n * @example\n *\n * ```TypeScript\n * import { prefixLogger } from '@libp2p/logger'\n *\n * const logger = prefixLogger('my-node')\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-node:my-component hello world\"\n * ```\n */\nexport function prefixLogger(prefix) {\n    return {\n        forComponent(name) {\n            return logger(`${prefix}:${name}`);\n        }\n    };\n}\n/**\n * Create a component logger\n *\n * @example\n *\n * ```TypeScript\n * import { defaultLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const logger = defaultLogger()\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function defaultLogger() {\n    return {\n        forComponent(name) {\n            return logger(name);\n        }\n    };\n}\n/**\n * Creates a logger for the passed component name.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map((r) => r.toString()).find((n) => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n//# sourceMappingURL=index.js.map","export function truncatePeerId(peerId, options = {}) {\n    const prefixLength = options.prefixLength ?? 2;\n    const suffixLength = options.suffixLength ?? 4;\n    const peerIdString = peerId.toString();\n    return `${peerIdString.substring(0, prefixLength)}${peerIdString.substring(peerIdString.length, peerIdString.length - suffixLength)}`;\n}\n//# sourceMappingURL=utils.js.map","import { Uint8ArrayList } from 'uint8arraylist';\nimport { MessageTypeNames, MessageTypes } from './message-types.js';\nexport const MAX_MSG_SIZE = 1 << 20; // 1MB\nexport const MAX_MSG_QUEUE_SIZE = 4 << 20; // 4MB\nexport class Decoder {\n    _buffer;\n    _headerInfo;\n    _maxMessageSize;\n    _maxUnprocessedMessageQueueSize;\n    constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {\n        this._buffer = new Uint8ArrayList();\n        this._headerInfo = null;\n        this._maxMessageSize = maxMessageSize;\n        this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;\n    }\n    write(chunk) {\n        if (chunk == null || chunk.length === 0) {\n            return [];\n        }\n        this._buffer.append(chunk);\n        if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {\n            throw Object.assign(new Error('unprocessed message queue size too large!'), { code: 'ERR_MSG_QUEUE_TOO_BIG' });\n        }\n        const msgs = [];\n        while (this._buffer.length !== 0) {\n            if (this._headerInfo == null) {\n                try {\n                    this._headerInfo = this._decodeHeader(this._buffer);\n                }\n                catch (err) {\n                    if (err.code === 'ERR_MSG_TOO_BIG') {\n                        throw err;\n                    }\n                    break; // We haven't received enough data yet\n                }\n            }\n            const { id, type, length, offset } = this._headerInfo;\n            const bufferedDataLength = this._buffer.length - offset;\n            if (bufferedDataLength < length) {\n                break; // not enough data yet\n            }\n            const msg = {\n                id,\n                type\n            };\n            if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {\n                msg.data = this._buffer.sublist(offset, offset + length);\n            }\n            msgs.push(msg);\n            this._buffer.consume(offset + length);\n            this._headerInfo = null;\n        }\n        return msgs;\n    }\n    /**\n     * Attempts to decode the message header from the buffer\n     */\n    _decodeHeader(data) {\n        const { value: h, offset } = readVarInt(data);\n        const { value: length, offset: end } = readVarInt(data, offset);\n        const type = h & 7;\n        // @ts-expect-error h is a number not a CODE\n        if (MessageTypeNames[type] == null) {\n            throw new Error(`Invalid type received: ${type}`);\n        }\n        // test message type varint + data length\n        if (length > this._maxMessageSize) {\n            throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' });\n        }\n        // @ts-expect-error h is a number not a CODE\n        return { id: h >> 3, type, offset: offset + end, length };\n    }\n}\nconst MSB = 0x80;\nconst REST = 0x7F;\nfunction readVarInt(buf, offset = 0) {\n    let res = 0;\n    let shift = 0;\n    let counter = offset;\n    let b;\n    const l = buf.length;\n    do {\n        if (counter >= l || shift > 49) {\n            offset = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf.get(counter++);\n        res += shift < 28\n            ? (b & REST) << shift\n            : (b & REST) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB);\n    offset = counter - offset;\n    return {\n        value: res,\n        offset\n    };\n}\n//# sourceMappingURL=decode.js.map","import * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nimport { MessageTypes } from './message-types.js';\nconst POOL_SIZE = 10 * 1024;\nclass Encoder {\n    _pool;\n    _poolOffset;\n    constructor() {\n        this._pool = allocUnsafe(POOL_SIZE);\n        this._poolOffset = 0;\n    }\n    /**\n     * Encodes the given message and adds it to the passed list\n     */\n    write(msg, list) {\n        const pool = this._pool;\n        let offset = this._poolOffset;\n        varint.encode(msg.id << 3 | msg.type, pool, offset);\n        offset += varint.encodingLength(msg.id << 3 | msg.type);\n        if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n            varint.encode(msg.data.length, pool, offset);\n            offset += varint.encodingLength(msg.data.length);\n        }\n        else {\n            varint.encode(0, pool, offset);\n            offset += varint.encodingLength(0);\n        }\n        const header = pool.subarray(this._poolOffset, offset);\n        if (POOL_SIZE - offset < 100) {\n            this._pool = allocUnsafe(POOL_SIZE);\n            this._poolOffset = 0;\n        }\n        else {\n            this._poolOffset = offset;\n        }\n        list.append(header);\n        if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n            list.append(msg.data);\n        }\n    }\n}\nconst encoder = new Encoder();\n/**\n * Encode and yield one or more messages\n */\nexport async function* encode(source) {\n    for await (const message of source) {\n        const list = new Uint8ArrayList();\n        encoder.write(message, list);\n        yield list;\n    }\n}\n//# sourceMappingURL=encode.js.map","/**\n * @packageDocumentation\n *\n * This is a [simple stream multiplexer(https://docs.libp2p.io/concepts/multiplex/mplex/) that has been deprecated.\n *\n * Please use [@chainsafe/libp2p-yamux](https://www.npmjs.com/package/@chainsafe/libp2p-yamux) instead.\n *\n * @example\n *\n * ```TypeScript\n * import { mplex } from '@libp2p/mplex'\n * import { pipe } from 'it-pipe'\n *\n * const factory = mplex()\n *\n * const muxer = factory.createStreamMuxer(components, {\n *   onStream: stream => { // Receive a duplex stream from the remote\n *     // ...receive data from the remote and optionally send data back\n *   },\n *   onStreamEnd: stream => {\n *     // ...handle any tracking you may need of stream closures\n *   }\n * })\n *\n * pipe(conn, muxer, conn) // conn is duplex connection to another peer\n *\n * const stream = muxer.newStream() // Create a new duplex stream to the remote\n *\n * // Use the duplex stream to send some data to the remote...\n * pipe([1, 2, 3], stream)\n * ```\n */\nimport { serviceCapabilities } from '@libp2p/interface';\nimport { MplexStreamMuxer } from './mplex.js';\nclass Mplex {\n    protocol = '/mplex/6.7.0';\n    _init;\n    components;\n    constructor(components, init = {}) {\n        this.components = components;\n        this._init = init;\n    }\n    [Symbol.toStringTag] = '@libp2p/mplex';\n    [serviceCapabilities] = [\n        '@libp2p/stream-multiplexing'\n    ];\n    createStreamMuxer(init = {}) {\n        return new MplexStreamMuxer(this.components, {\n            ...init,\n            ...this._init\n        });\n    }\n}\nexport function mplex(init = {}) {\n    return (components) => new Mplex(components, init);\n}\n//# sourceMappingURL=index.js.map","export var MessageTypes;\n(function (MessageTypes) {\n    MessageTypes[MessageTypes[\"NEW_STREAM\"] = 0] = \"NEW_STREAM\";\n    MessageTypes[MessageTypes[\"MESSAGE_RECEIVER\"] = 1] = \"MESSAGE_RECEIVER\";\n    MessageTypes[MessageTypes[\"MESSAGE_INITIATOR\"] = 2] = \"MESSAGE_INITIATOR\";\n    MessageTypes[MessageTypes[\"CLOSE_RECEIVER\"] = 3] = \"CLOSE_RECEIVER\";\n    MessageTypes[MessageTypes[\"CLOSE_INITIATOR\"] = 4] = \"CLOSE_INITIATOR\";\n    MessageTypes[MessageTypes[\"RESET_RECEIVER\"] = 5] = \"RESET_RECEIVER\";\n    MessageTypes[MessageTypes[\"RESET_INITIATOR\"] = 6] = \"RESET_INITIATOR\";\n})(MessageTypes || (MessageTypes = {}));\nexport const MessageTypeNames = Object.freeze({\n    0: 'NEW_STREAM',\n    1: 'MESSAGE_RECEIVER',\n    2: 'MESSAGE_INITIATOR',\n    3: 'CLOSE_RECEIVER',\n    4: 'CLOSE_INITIATOR',\n    5: 'RESET_RECEIVER',\n    6: 'RESET_INITIATOR'\n});\nexport const InitiatorMessageTypes = Object.freeze({\n    NEW_STREAM: MessageTypes.NEW_STREAM,\n    MESSAGE: MessageTypes.MESSAGE_INITIATOR,\n    CLOSE: MessageTypes.CLOSE_INITIATOR,\n    RESET: MessageTypes.RESET_INITIATOR\n});\nexport const ReceiverMessageTypes = Object.freeze({\n    MESSAGE: MessageTypes.MESSAGE_RECEIVER,\n    CLOSE: MessageTypes.CLOSE_RECEIVER,\n    RESET: MessageTypes.RESET_RECEIVER\n});\n//# sourceMappingURL=message-types.js.map","import { CodeError } from '@libp2p/interface';\nimport { closeSource } from '@libp2p/utils/close-source';\nimport { RateLimiter } from '@libp2p/utils/rate-limiter';\nimport { pipe } from 'it-pipe';\nimport { pushable } from 'it-pushable';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { Decoder } from './decode.js';\nimport { encode } from './encode.js';\nimport { MessageTypes, MessageTypeNames } from './message-types.js';\nimport { createStream } from './stream.js';\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4; // 4MB\nconst DISCONNECT_THRESHOLD = 5;\nconst CLOSE_TIMEOUT = 500;\nfunction printMessage(msg) {\n    const output = {\n        ...msg,\n        type: `${MessageTypeNames[msg.type]} (${msg.type})`\n    };\n    if (msg.type === MessageTypes.NEW_STREAM) {\n        output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());\n    }\n    if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n        output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16');\n    }\n    return output;\n}\nexport class MplexStreamMuxer {\n    protocol = '/mplex/6.7.0';\n    sink;\n    source;\n    log;\n    _streamId;\n    _streams;\n    _init;\n    _source;\n    closeController;\n    rateLimiter;\n    closeTimeout;\n    logger;\n    constructor(components, init) {\n        init = init ?? {};\n        this.log = components.logger.forComponent('libp2p:mplex');\n        this.logger = components.logger;\n        this._streamId = 0;\n        this._streams = {\n            /**\n             * Stream to ids map\n             */\n            initiators: new Map(),\n            /**\n             * Stream to ids map\n             */\n            receivers: new Map()\n        };\n        this._init = init;\n        this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT;\n        /**\n         * An iterable sink\n         */\n        this.sink = this._createSink();\n        /**\n         * An iterable source\n         */\n        this._source = pushable({\n            objectMode: true,\n            onEnd: () => {\n                // the source has ended, we can't write any more messages to gracefully\n                // close streams so all we can do is destroy them\n                for (const stream of this._streams.initiators.values()) {\n                    stream.destroy();\n                }\n                for (const stream of this._streams.receivers.values()) {\n                    stream.destroy();\n                }\n            }\n        });\n        this.source = pipe(this._source, source => encode(source));\n        /**\n         * Close controller\n         */\n        this.closeController = new AbortController();\n        this.rateLimiter = new RateLimiter({\n            points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n            duration: 1\n        });\n    }\n    /**\n     * Returns a Map of streams and their ids\n     */\n    get streams() {\n        // Inbound and Outbound streams may have the same ids, so we need to make those unique\n        const streams = [];\n        for (const stream of this._streams.initiators.values()) {\n            streams.push(stream);\n        }\n        for (const stream of this._streams.receivers.values()) {\n            streams.push(stream);\n        }\n        return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of the stream will be used.\n     */\n    newStream(name) {\n        if (this.closeController.signal.aborted) {\n            throw new Error('Muxer already closed');\n        }\n        const id = this._streamId++;\n        name = name == null ? id.toString() : name.toString();\n        const registry = this._streams.initiators;\n        return this._newStream({ id, name, type: 'initiator', registry });\n    }\n    /**\n     * Close or abort all tracked streams and stop the muxer\n     */\n    async close(options) {\n        if (this.closeController.signal.aborted) {\n            return;\n        }\n        const signal = options?.signal ?? AbortSignal.timeout(this.closeTimeout);\n        try {\n            // try to gracefully close all streams\n            await Promise.all(this.streams.map(async (s) => s.close({\n                signal\n            })));\n            this._source.end();\n            // try to gracefully close the muxer\n            await this._source.onEmpty({\n                signal\n            });\n            this.closeController.abort();\n        }\n        catch (err) {\n            this.abort(err);\n        }\n    }\n    abort(err) {\n        if (this.closeController.signal.aborted) {\n            return;\n        }\n        this.streams.forEach(s => { s.abort(err); });\n        this.closeController.abort(err);\n    }\n    /**\n     * Called whenever an inbound stream is created\n     */\n    _newReceiverStream(options) {\n        const { id, name } = options;\n        const registry = this._streams.receivers;\n        return this._newStream({ id, name, type: 'receiver', registry });\n    }\n    _newStream(options) {\n        const { id, name, type, registry } = options;\n        this.log('new %s stream %s', type, id);\n        if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n            throw new CodeError('Too many outbound streams open', 'ERR_TOO_MANY_OUTBOUND_STREAMS');\n        }\n        if (registry.has(id)) {\n            throw new Error(`${type} stream ${id} already exists!`);\n        }\n        const send = async (msg) => {\n            if (this.log.enabled) {\n                this.log.trace('%s stream %s send', type, id, printMessage(msg));\n            }\n            this._source.push(msg);\n        };\n        const onEnd = () => {\n            this.log('%s stream with id %s and protocol %s ended', type, id, stream.protocol);\n            registry.delete(id);\n            if (this._init.onStreamEnd != null) {\n                this._init.onStreamEnd(stream);\n            }\n        };\n        const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize, logger: this.logger });\n        registry.set(id, stream);\n        return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     */\n    _createSink() {\n        const sink = async (source) => {\n            const abortListener = () => {\n                closeSource(source, this.log);\n            };\n            this.closeController.signal.addEventListener('abort', abortListener);\n            try {\n                const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);\n                for await (const chunk of source) {\n                    for (const msg of decoder.write(chunk)) {\n                        await this._handleIncoming(msg);\n                    }\n                }\n                this._source.end();\n            }\n            catch (err) {\n                this.log('error in sink', err);\n                this._source.end(err); // End the source with an error\n            }\n            finally {\n                this.closeController.signal.removeEventListener('abort', abortListener);\n            }\n        };\n        return sink;\n    }\n    async _handleIncoming(message) {\n        const { id, type } = message;\n        if (this.log.enabled) {\n            this.log.trace('incoming message', printMessage(message));\n        }\n        // Create a new stream?\n        if (message.type === MessageTypes.NEW_STREAM) {\n            if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n                this.log('too many inbound streams open');\n                // not going to allow this stream, send the reset message manually\n                // instead of setting it up just to tear it down\n                this._source.push({\n                    id,\n                    type: MessageTypes.RESET_RECEIVER\n                });\n                // if we've hit our stream limit, and the remote keeps trying to open\n                // more new streams, if they are doing this very quickly maybe they\n                // are attacking us and we should close the connection\n                try {\n                    await this.rateLimiter.consume('new-stream', 1);\n                }\n                catch {\n                    this.log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection');\n                    // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n                    this.abort(new Error('Too many open streams'));\n                    return;\n                }\n                return;\n            }\n            const stream = this._newReceiverStream({ id, name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) });\n            if (this._init.onIncomingStream != null) {\n                this._init.onIncomingStream(stream);\n            }\n            return;\n        }\n        const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;\n        const stream = list.get(id);\n        if (stream == null) {\n            this.log('missing stream %s for message type %s', id, MessageTypeNames[type]);\n            // if the remote keeps sending us messages for streams that have been\n            // closed or were never opened they may be attacking us so if they do\n            // this very quickly all we can do is close the connection\n            try {\n                await this.rateLimiter.consume('missing-stream', 1);\n            }\n            catch {\n                this.log('rate limit hit when receiving messages for streams that do not exist - closing remote connection');\n                // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n                this.abort(new Error('Too many messages for missing streams'));\n                return;\n            }\n            return;\n        }\n        const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;\n        try {\n            switch (type) {\n                case MessageTypes.MESSAGE_INITIATOR:\n                case MessageTypes.MESSAGE_RECEIVER:\n                    if (stream.sourceReadableLength() > maxBufferSize) {\n                        // Stream buffer has got too large, reset the stream\n                        this._source.push({\n                            id: message.id,\n                            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n                        });\n                        // Inform the stream consumer they are not fast enough\n                        throw new CodeError('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers', 'ERR_STREAM_INPUT_BUFFER_FULL');\n                    }\n                    // We got data from the remote, push it into our local stream\n                    stream.sourcePush(message.data);\n                    break;\n                case MessageTypes.CLOSE_INITIATOR:\n                case MessageTypes.CLOSE_RECEIVER:\n                    // The remote has stopped writing, so we can stop reading\n                    stream.remoteCloseWrite();\n                    break;\n                case MessageTypes.RESET_INITIATOR:\n                case MessageTypes.RESET_RECEIVER:\n                    // The remote has errored, stop reading and writing to the stream immediately\n                    stream.reset();\n                    break;\n                default:\n                    this.log('unknown message type %s', type);\n            }\n        }\n        catch (err) {\n            this.log.error('error while processing message', err);\n            stream.abort(err);\n        }\n    }\n}\n//# sourceMappingURL=mplex.js.map","import { AbstractStream } from '@libp2p/utils/abstract-stream';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { MAX_MSG_SIZE } from './decode.js';\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js';\nexport class MplexStream extends AbstractStream {\n    name;\n    streamId;\n    send;\n    types;\n    maxDataSize;\n    constructor(init) {\n        super(init);\n        this.types = init.direction === 'outbound' ? InitiatorMessageTypes : ReceiverMessageTypes;\n        this.send = init.send;\n        this.name = init.name;\n        this.streamId = init.streamId;\n        this.maxDataSize = init.maxDataSize;\n    }\n    async sendNewStream() {\n        await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(uint8ArrayFromString(this.name)) });\n    }\n    async sendData(data) {\n        data = data.sublist();\n        while (data.byteLength > 0) {\n            const toSend = Math.min(data.byteLength, this.maxDataSize);\n            await this.send({\n                id: this.streamId,\n                type: this.types.MESSAGE,\n                data: data.sublist(0, toSend)\n            });\n            data.consume(toSend);\n        }\n    }\n    async sendReset() {\n        await this.send({ id: this.streamId, type: this.types.RESET });\n    }\n    async sendCloseWrite() {\n        await this.send({ id: this.streamId, type: this.types.CLOSE });\n    }\n    async sendCloseRead() {\n        // mplex does not support close read, only close write\n    }\n}\nexport function createStream(options) {\n    const { id, name, send, onEnd, type = 'initiator', maxMsgSize = MAX_MSG_SIZE } = options;\n    return new MplexStream({\n        id: type === 'initiator' ? (`i${id}`) : `r${id}`,\n        streamId: id,\n        name: `${name ?? id}`,\n        direction: type === 'initiator' ? 'outbound' : 'inbound',\n        maxDataSize: maxMsgSize,\n        onEnd,\n        send,\n        log: options.logger.forComponent(`libp2p:mplex:stream:${type}:${id}`)\n    });\n}\n//# sourceMappingURL=stream.js.map","export const PROTOCOL_ID = '/multistream/1.0.0';\n// Conforming to go-libp2p\n// See https://github.com/multiformats/go-multistream/blob/master/multistream.go#L297\nexport const MAX_PROTOCOL_LENGTH = 1024;\n//# sourceMappingURL=constants.js.map","import { encode } from 'it-length-prefixed';\nimport { lpStream } from 'it-length-prefixed-stream';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { MAX_PROTOCOL_LENGTH, PROTOCOL_ID } from './constants.js';\nimport * as multistream from './multistream.js';\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle(stream, protocols, options) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    options.log.trace('handle: available protocols %s', protocols);\n    const lp = lpStream(stream, {\n        ...options,\n        maxDataLength: MAX_PROTOCOL_LENGTH,\n        maxLengthLength: 2 // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH\n    });\n    while (true) {\n        options.log.trace('handle: reading incoming string');\n        const protocol = await multistream.readString(lp, options);\n        options.log.trace('handle: read \"%s\"', protocol);\n        if (protocol === PROTOCOL_ID) {\n            options.log.trace('handle: respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol);\n            await multistream.write(lp, uint8ArrayFromString(`${PROTOCOL_ID}\\n`), options);\n            options.log.trace('handle: responded with \"%s\" for \"%s\"', PROTOCOL_ID, protocol);\n            continue;\n        }\n        if (protocols.includes(protocol)) {\n            options.log.trace('handle: respond with \"%s\" for \"%s\"', protocol, protocol);\n            await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options);\n            options.log.trace('handle: responded with \"%s\" for \"%s\"', protocol, protocol);\n            return { stream: lp.unwrap(), protocol };\n        }\n        if (protocol === 'ls') {\n            // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n            const protos = new Uint8ArrayList(...protocols.map(p => encode.single(uint8ArrayFromString(`${p}\\n`))), uint8ArrayFromString('\\n'));\n            options.log.trace('handle: respond with \"%s\" for %s', protocols, protocol);\n            await multistream.write(lp, protos, options);\n            options.log.trace('handle: responded with \"%s\" for %s', protocols, protocol);\n            continue;\n        }\n        options.log('handle: respond with \"na\" for \"%s\"', protocol);\n        await multistream.write(lp, uint8ArrayFromString('na\\n'), options);\n        options.log('handle: responded with \"na\" for \"%s\"', protocol);\n    }\n}\n//# sourceMappingURL=handle.js.map","import { CodeError } from '@libp2p/interface';\nimport {} from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst NewLine = uint8ArrayFromString('\\n');\n/**\n * `write` encodes and writes a single buffer\n */\nexport async function write(writer, buffer, options) {\n    await writer.write(buffer, options);\n}\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport async function writeAll(writer, buffers, options) {\n    await writer.writeV(buffers, options);\n}\n/**\n * Read a length-prefixed buffer from the passed stream, stripping the final newline character\n */\nexport async function read(reader, options) {\n    const buf = await reader.read(options);\n    if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {\n        options.log.error('Invalid mss message - missing newline', buf);\n        throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n    }\n    return buf.sublist(0, -1); // Remove newline\n}\n/**\n * Read a length-prefixed string from the passed stream, stripping the final newline character\n */\nexport async function readString(reader, options) {\n    const buf = await read(reader, options);\n    return uint8ArrayToString(buf.subarray());\n}\n//# sourceMappingURL=multistream.js.map","import { CodeError } from '@libp2p/interface';\nimport { lpStream } from 'it-length-prefixed-stream';\nimport pDefer from 'p-defer';\nimport { raceSignal } from 'race-signal';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { MAX_PROTOCOL_LENGTH } from './constants.js';\nimport * as multistream from './multistream.js';\nimport { PROTOCOL_ID } from './index.js';\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different impls\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select(stream, protocols, options) {\n    protocols = Array.isArray(protocols) ? [...protocols] : [protocols];\n    if (protocols.length === 1 && options.negotiateFully === false) {\n        return optimisticSelect(stream, protocols[0], options);\n    }\n    const lp = lpStream(stream, {\n        ...options,\n        maxDataLength: MAX_PROTOCOL_LENGTH\n    });\n    const protocol = protocols.shift();\n    if (protocol == null) {\n        throw new Error('At least one protocol must be specified');\n    }\n    options.log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol);\n    const p1 = uint8ArrayFromString(`${PROTOCOL_ID}\\n`);\n    const p2 = uint8ArrayFromString(`${protocol}\\n`);\n    await multistream.writeAll(lp, [p1, p2], options);\n    options.log.trace('select: reading multistream-select header');\n    let response = await multistream.readString(lp, options);\n    options.log.trace('select: read \"%s\"', response);\n    // Read the protocol response if we got the protocolId in return\n    if (response === PROTOCOL_ID) {\n        options.log.trace('select: reading protocol response');\n        response = await multistream.readString(lp, options);\n        options.log.trace('select: read \"%s\"', response);\n    }\n    // We're done\n    if (response === protocol) {\n        return { stream: lp.unwrap(), protocol };\n    }\n    // We haven't gotten a valid ack, try the other protocols\n    for (const protocol of protocols) {\n        options.log.trace('select: write \"%s\"', protocol);\n        await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options);\n        options.log.trace('select: reading protocol response');\n        const response = await multistream.readString(lp, options);\n        options.log.trace('select: read \"%s\" for \"%s\"', response, protocol);\n        if (response === protocol) {\n            return { stream: lp.unwrap(), protocol };\n        }\n    }\n    throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n}\n/**\n * Optimistically negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nfunction optimisticSelect(stream, protocol, options) {\n    const originalSink = stream.sink.bind(stream);\n    const originalSource = stream.source;\n    let negotiated = false;\n    let negotiating = false;\n    const doneNegotiating = pDefer();\n    let sentProtocol = false;\n    let sendingProtocol = false;\n    const doneSendingProtocol = pDefer();\n    let readProtocol = false;\n    let readingProtocol = false;\n    const doneReadingProtocol = pDefer();\n    const lp = lpStream({\n        sink: originalSink,\n        source: originalSource\n    }, {\n        ...options,\n        maxDataLength: MAX_PROTOCOL_LENGTH\n    });\n    stream.sink = async (source) => {\n        const { sink } = lp.unwrap();\n        await sink(async function* () {\n            let sentData = false;\n            for await (const buf of source) {\n                // started reading before the source yielded, wait for protocol send\n                if (sendingProtocol) {\n                    await doneSendingProtocol.promise;\n                }\n                // writing before reading, send the protocol and the first chunk of data\n                if (!sentProtocol) {\n                    sendingProtocol = true;\n                    options.log.trace('optimistic: write [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);\n                    const protocolString = `${protocol}\\n`;\n                    // send protocols in first chunk of data written to transport\n                    yield new Uint8ArrayList(Uint8Array.from([19]), // length of PROTOCOL_ID plus newline\n                    uint8ArrayFromString(`${PROTOCOL_ID}\\n`), varint.encode(protocolString.length), uint8ArrayFromString(protocolString), buf).subarray();\n                    options.log.trace('optimistic: wrote [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);\n                    sentProtocol = true;\n                    sendingProtocol = false;\n                    doneSendingProtocol.resolve();\n                    // read the negotiation response but don't block more sending\n                    negotiate()\n                        .catch(err => {\n                        options.log.error('could not finish optimistic protocol negotiation of %s', protocol, err);\n                    });\n                }\n                else {\n                    yield buf;\n                }\n                sentData = true;\n            }\n            // special case - the source passed to the sink has ended but we didn't\n            // negotiated the protocol yet so do it now\n            if (!sentData) {\n                await negotiate();\n            }\n        }());\n    };\n    async function negotiate() {\n        if (negotiating) {\n            options.log.trace('optimistic: already negotiating %s stream', protocol);\n            await doneNegotiating.promise;\n            return;\n        }\n        negotiating = true;\n        try {\n            // we haven't sent the protocol yet, send it now\n            if (!sentProtocol) {\n                options.log.trace('optimistic: doing send protocol for %s stream', protocol);\n                await doSendProtocol();\n            }\n            // if we haven't read the protocol response yet, do it now\n            if (!readProtocol) {\n                options.log.trace('optimistic: doing read protocol for %s stream', protocol);\n                await doReadProtocol();\n            }\n        }\n        finally {\n            negotiating = false;\n            negotiated = true;\n            doneNegotiating.resolve();\n        }\n    }\n    async function doSendProtocol() {\n        if (sendingProtocol) {\n            await doneSendingProtocol.promise;\n            return;\n        }\n        sendingProtocol = true;\n        try {\n            options.log.trace('optimistic: write [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol);\n            await lp.writeV([\n                uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n                uint8ArrayFromString(`${protocol}\\n`)\n            ]);\n            options.log.trace('optimistic: wrote [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol);\n        }\n        finally {\n            sentProtocol = true;\n            sendingProtocol = false;\n            doneSendingProtocol.resolve();\n        }\n    }\n    async function doReadProtocol() {\n        if (readingProtocol) {\n            await doneReadingProtocol.promise;\n            return;\n        }\n        readingProtocol = true;\n        try {\n            options.log.trace('optimistic: reading multistream select header');\n            let response = await multistream.readString(lp, options);\n            options.log.trace('optimistic: read multistream select header \"%s\"', response);\n            if (response === PROTOCOL_ID) {\n                response = await multistream.readString(lp, options);\n            }\n            options.log.trace('optimistic: read protocol \"%s\", expecting \"%s\"', response, protocol);\n            if (response !== protocol) {\n                throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n            }\n        }\n        finally {\n            readProtocol = true;\n            readingProtocol = false;\n            doneReadingProtocol.resolve();\n        }\n    }\n    stream.source = (async function* () {\n        // make sure we've done protocol negotiation before we read stream data\n        await negotiate();\n        options.log.trace('optimistic: reading data from \"%s\" stream', protocol);\n        yield* lp.unwrap().source;\n    })();\n    if (stream.closeRead != null) {\n        const originalCloseRead = stream.closeRead.bind(stream);\n        stream.closeRead = async (opts) => {\n            // we need to read & write to negotiate the protocol so ensure we've done\n            // this before closing the readable end of the stream\n            if (!negotiated) {\n                await negotiate().catch(err => {\n                    options.log.error('could not negotiate protocol before close read', err);\n                });\n            }\n            // protocol has been negotiated, ok to close the readable end\n            await originalCloseRead(opts);\n        };\n    }\n    if (stream.closeWrite != null) {\n        const originalCloseWrite = stream.closeWrite.bind(stream);\n        stream.closeWrite = async (opts) => {\n            // we need to read & write to negotiate the protocol so ensure we've done\n            // this before closing the writable end of the stream\n            if (!negotiated) {\n                await negotiate().catch(err => {\n                    options.log.error('could not negotiate protocol before close write', err);\n                });\n            }\n            // protocol has been negotiated, ok to close the writable end\n            await originalCloseWrite(opts);\n        };\n    }\n    if (stream.close != null) {\n        const originalClose = stream.close.bind(stream);\n        stream.close = async (opts) => {\n            // if we are in the process of negotiation, let it finish before closing\n            // because we may have unsent early data\n            const tasks = [];\n            if (sendingProtocol) {\n                tasks.push(doneSendingProtocol.promise);\n            }\n            if (readingProtocol) {\n                tasks.push(doneReadingProtocol.promise);\n            }\n            if (tasks.length > 0) {\n                // let the in-flight protocol negotiation finish gracefully\n                await raceSignal(Promise.all(tasks), opts?.signal);\n            }\n            else {\n                // no protocol negotiation attempt has occurred so don't start one\n                negotiated = true;\n                negotiating = false;\n                doneNegotiating.resolve();\n            }\n            // protocol has been negotiated, ok to close the writable end\n            await originalClose(opts);\n        };\n    }\n    return {\n        stream,\n        protocol\n    };\n}\n//# sourceMappingURL=select.js.map","import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap {\n    map;\n    constructor(map) {\n        this.map = new Map();\n        if (map != null) {\n            for (const [key, value] of map.entries()) {\n                this.map.set(key.toString(), value);\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(peer) {\n        return this.map.delete(peer.toString());\n    }\n    entries() {\n        return mapIterable(this.map.entries(), (val) => {\n            return [peerIdFromString(val[0]), val[1]];\n        });\n    }\n    forEach(fn) {\n        this.map.forEach((value, key) => {\n            fn(value, peerIdFromString(key), this);\n        });\n    }\n    get(peer) {\n        return this.map.get(peer.toString());\n    }\n    has(peer) {\n        return this.map.has(peer.toString());\n    }\n    set(peer, value) {\n        this.map.set(peer.toString(), value);\n    }\n    keys() {\n        return mapIterable(this.map.keys(), (val) => {\n            return peerIdFromString(val);\n        });\n    }\n    values() {\n        return this.map.values();\n    }\n    get size() {\n        return this.map.size;\n    }\n}\nexport function peerMap() {\n    return new PeerMap();\n}\n//# sourceMappingURL=map.js.map","import { peerIdFromString } from '@libp2p/peer-id';\nimport { mapIterable } from './util.js';\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n    set;\n    constructor(set) {\n        this.set = new Set();\n        if (set != null) {\n            for (const key of set) {\n                this.set.add(key.toString());\n            }\n        }\n    }\n    get size() {\n        return this.set.size;\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n    add(peer) {\n        this.set.add(peer.toString());\n    }\n    clear() {\n        this.set.clear();\n    }\n    delete(peer) {\n        this.set.delete(peer.toString());\n    }\n    entries() {\n        return mapIterable(this.set.entries(), (val) => {\n            const peerId = peerIdFromString(val[0]);\n            return [peerId, peerId];\n        });\n    }\n    forEach(predicate) {\n        this.set.forEach((str) => {\n            const id = peerIdFromString(str);\n            predicate(id, id, this);\n        });\n    }\n    has(peer) {\n        return this.set.has(peer.toString());\n    }\n    values() {\n        return mapIterable(this.set.values(), (val) => {\n            return peerIdFromString(val);\n        });\n    }\n    intersection(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            if (this.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    difference(other) {\n        const output = new PeerSet();\n        for (const peerId of this) {\n            if (!other.has(peerId)) {\n                output.add(peerId);\n            }\n        }\n        return output;\n    }\n    union(other) {\n        const output = new PeerSet();\n        for (const peerId of other) {\n            output.add(peerId);\n        }\n        for (const peerId of this) {\n            output.add(peerId);\n        }\n        return output;\n    }\n}\nexport function peerSet() {\n    return new PeerSet();\n}\n//# sourceMappingURL=set.js.map","/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nexport function mapIterable(iter, map) {\n    const iterator = {\n        [Symbol.iterator]: () => {\n            return iterator;\n        },\n        next: () => {\n            const next = iter.next();\n            const val = next.value;\n            if (next.done === true || val == null) {\n                const result = {\n                    done: true,\n                    value: undefined\n                };\n                return result;\n            }\n            return {\n                done: false,\n                value: map(val)\n            };\n        }\n    };\n    return iterator;\n}\n//# sourceMappingURL=util.js.map","/**\n * @packageDocumentation\n *\n * Generate, import, and export PeerIDs.\n *\n * A Peer ID is the SHA-256 [multihash](https://github.com/multiformats/multihash) of a public key.\n *\n * The public key is a base64 encoded string of a protobuf containing an RSA DER buffer. This uses a node buffer to pass the base64 encoded public key protobuf to the multihash for ID generation.\n *\n * @example\n *\n * ```TypeScript\n * import { createEd25519PeerId } from '@libp2p/peer-id-factory'\n *\n * const peerId = await createEd25519PeerId()\n * console.log(peerId.toString())\n * ```\n *\n * ```bash\n * 12D3KooWRm8J3iL796zPFi2EtGGtUJn58AG67gcqzMFHZnnsTzqD\n * ```\n */\nimport { generateKeyPair, marshalPrivateKey, unmarshalPrivateKey, marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { peerIdFromKeys, peerIdFromBytes } from '@libp2p/peer-id';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { PeerIdProto } from './proto.js';\nexport const createEd25519PeerId = async () => {\n    const key = await generateKeyPair('Ed25519');\n    const id = await createFromPrivKey(key);\n    if (id.type === 'Ed25519') {\n        return id;\n    }\n    throw new Error(`Generated unexpected PeerId type \"${id.type}\"`);\n};\nexport const createSecp256k1PeerId = async () => {\n    const key = await generateKeyPair('secp256k1');\n    const id = await createFromPrivKey(key);\n    if (id.type === 'secp256k1') {\n        return id;\n    }\n    throw new Error(`Generated unexpected PeerId type \"${id.type}\"`);\n};\nexport const createRSAPeerId = async (opts) => {\n    const key = await generateKeyPair('RSA', opts?.bits ?? 2048);\n    const id = await createFromPrivKey(key);\n    if (id.type === 'RSA') {\n        return id;\n    }\n    throw new Error(`Generated unexpected PeerId type \"${id.type}\"`);\n};\nexport async function createFromPubKey(publicKey) {\n    return peerIdFromKeys(marshalPublicKey(publicKey));\n}\nexport async function createFromPrivKey(privateKey) {\n    return peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));\n}\nexport function exportToProtobuf(peerId, excludePrivateKey) {\n    return PeerIdProto.encode({\n        id: peerId.multihash.bytes,\n        pubKey: peerId.publicKey,\n        privKey: excludePrivateKey === true || peerId.privateKey == null ? undefined : peerId.privateKey\n    });\n}\nexport async function createFromProtobuf(buf) {\n    const { id, privKey, pubKey } = PeerIdProto.decode(buf);\n    return createFromParts(id ?? new Uint8Array(0), privKey, pubKey);\n}\nexport async function createFromJSON(obj) {\n    return createFromParts(uint8ArrayFromString(obj.id, 'base58btc'), obj.privKey != null ? uint8ArrayFromString(obj.privKey, 'base64pad') : undefined, obj.pubKey != null ? uint8ArrayFromString(obj.pubKey, 'base64pad') : undefined);\n}\nasync function createFromParts(multihash, privKey, pubKey) {\n    if (privKey != null) {\n        const key = await unmarshalPrivateKey(privKey);\n        return createFromPrivKey(key);\n    }\n    else if (pubKey != null) {\n        const key = unmarshalPublicKey(pubKey);\n        return createFromPubKey(key);\n    }\n    const peerId = peerIdFromBytes(multihash);\n    if (peerId.type !== 'Ed25519' && peerId.type !== 'secp256k1' && peerId.type !== 'RSA') {\n        // should not be possible since `multihash` is derived from keys and these\n        // are the cryptographic peer id types\n        throw new Error('Supplied PeerID is invalid');\n    }\n    return peerId;\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var PeerIdProto;\n(function (PeerIdProto) {\n    let _codec;\n    PeerIdProto.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.id != null) {\n                    w.uint32(10);\n                    w.bytes(obj.id);\n                }\n                if (obj.pubKey != null) {\n                    w.uint32(18);\n                    w.bytes(obj.pubKey);\n                }\n                if (obj.privKey != null) {\n                    w.uint32(26);\n                    w.bytes(obj.privKey);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.id = reader.bytes();\n                            break;\n                        case 2:\n                            obj.pubKey = reader.bytes();\n                            break;\n                        case 3:\n                            obj.privKey = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PeerIdProto.encode = (obj) => {\n        return encodeMessage(obj, PeerIdProto.codec());\n    };\n    PeerIdProto.decode = (buf) => {\n        return decodeMessage(buf, PeerIdProto.codec());\n    };\n})(PeerIdProto || (PeerIdProto = {}));\n//# sourceMappingURL=proto.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\nimport { CodeError } from '@libp2p/interface';\nimport { peerIdSymbol } from '@libp2p/interface';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    type;\n    multihash;\n    privateKey;\n    publicKey;\n    string;\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    [peerIdSymbol] = true;\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id == null) {\n            return false;\n        }\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```TypeScript\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    type = 'RSA';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    type = 'Ed25519';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    type = 'secp256k1';\n    publicKey;\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.publicKey = init.multihash.digest;\n    }\n}\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920;\nclass URLPeerIdImpl {\n    type = 'url';\n    multihash;\n    privateKey;\n    publicKey;\n    url;\n    constructor(url) {\n        this.url = url.toString();\n        this.multihash = identity.digest(uint8ArrayFromString(this.url));\n    }\n    [inspect]() {\n        return `PeerId(${this.url})`;\n    }\n    [peerIdSymbol] = true;\n    toString() {\n        return this.toCID().toString();\n    }\n    toCID() {\n        return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.toCID().bytes;\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (other instanceof Uint8Array) {\n            other = uint8ArrayToString(other);\n        }\n        return other.toString() === this.toString();\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid?.multihash == null || cid.version == null || (cid.version === 1 && (cid.code !== LIBP2P_KEY_CODE) && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {\n        const url = uint8ArrayToString(cid.multihash.digest);\n        return new URLPeerIdImpl(new URL(url));\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Envelope;\n(function (Envelope) {\n    let _codec;\n    Envelope.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.publicKey);\n                }\n                if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.payloadType);\n                }\n                if ((obj.payload != null && obj.payload.byteLength > 0)) {\n                    w.uint32(26);\n                    w.bytes(obj.payload);\n                }\n                if ((obj.signature != null && obj.signature.byteLength > 0)) {\n                    w.uint32(42);\n                    w.bytes(obj.signature);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    publicKey: new Uint8Array(0),\n                    payloadType: new Uint8Array(0),\n                    payload: new Uint8Array(0),\n                    signature: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 2:\n                            obj.payloadType = reader.bytes();\n                            break;\n                        case 3:\n                            obj.payload = reader.bytes();\n                            break;\n                        case 5:\n                            obj.signature = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Envelope.encode = (obj) => {\n        return encodeMessage(obj, Envelope.codec());\n    };\n    Envelope.decode = (buf) => {\n        return decodeMessage(buf, Envelope.codec());\n    };\n})(Envelope || (Envelope = {}));\n//# sourceMappingURL=envelope.js.map","import { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { CodeError } from '@libp2p/interface';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string';\nimport { codes } from '../errors.js';\nimport { Envelope as Protobuf } from './envelope.js';\nexport class RecordEnvelope {\n    /**\n     * Unmarshal a serialized Envelope protobuf message\n     */\n    static createFromProtobuf = async (data) => {\n        const envelopeData = Protobuf.decode(data);\n        const peerId = await peerIdFromKeys(envelopeData.publicKey);\n        return new RecordEnvelope({\n            peerId,\n            payloadType: envelopeData.payloadType,\n            payload: envelopeData.payload,\n            signature: envelopeData.signature\n        });\n    };\n    /**\n     * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n     * and signs it with the given peerId's private key\n     */\n    static seal = async (record, peerId) => {\n        if (peerId.privateKey == null) {\n            throw new Error('Missing private key');\n        }\n        const domain = record.domain;\n        const payloadType = record.codec;\n        const payload = record.marshal();\n        const signData = formatSignaturePayload(domain, payloadType, payload);\n        const key = await unmarshalPrivateKey(peerId.privateKey);\n        const signature = await key.sign(signData.subarray());\n        return new RecordEnvelope({\n            peerId,\n            payloadType,\n            payload,\n            signature\n        });\n    };\n    /**\n     * Open and certify a given marshalled envelope.\n     * Data is unmarshalled and the signature validated for the given domain.\n     */\n    static openAndCertify = async (data, domain) => {\n        const envelope = await RecordEnvelope.createFromProtobuf(data);\n        const valid = await envelope.validate(domain);\n        if (!valid) {\n            throw new CodeError('envelope signature is not valid for the given domain', codes.ERR_SIGNATURE_NOT_VALID);\n        }\n        return envelope;\n    };\n    peerId;\n    payloadType;\n    payload;\n    signature;\n    marshaled;\n    /**\n     * The Envelope is responsible for keeping an arbitrary signed record\n     * by a libp2p peer.\n     */\n    constructor(init) {\n        const { peerId, payloadType, payload, signature } = init;\n        this.peerId = peerId;\n        this.payloadType = payloadType;\n        this.payload = payload;\n        this.signature = signature;\n    }\n    /**\n     * Marshal the envelope content\n     */\n    marshal() {\n        if (this.peerId.publicKey == null) {\n            throw new Error('Missing public key');\n        }\n        if (this.marshaled == null) {\n            this.marshaled = Protobuf.encode({\n                publicKey: this.peerId.publicKey,\n                payloadType: this.payloadType,\n                payload: this.payload.subarray(),\n                signature: this.signature\n            });\n        }\n        return this.marshaled;\n    }\n    /**\n     * Verifies if the other Envelope is identical to this one\n     */\n    equals(other) {\n        return uint8ArrayEquals(this.marshal(), other.marshal());\n    }\n    /**\n     * Validate envelope data signature for the given domain\n     */\n    async validate(domain) {\n        const signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n        if (this.peerId.publicKey == null) {\n            throw new Error('Missing public key');\n        }\n        const key = unmarshalPublicKey(this.peerId.publicKey);\n        return key.verify(signData.subarray(), this.signature);\n    }\n}\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n    // When signing, a peer will prepare a Uint8Array by concatenating the following:\n    // - The length of the domain separation string string in bytes\n    // - The domain separation string, encoded as UTF-8\n    // - The length of the payload_type field in bytes\n    // - The value of the payload_type field\n    // - The length of the payload field in bytes\n    // - The value of the payload field\n    const domainUint8Array = uint8arraysFromString(domain);\n    const domainLength = varint.encode(domainUint8Array.byteLength);\n    const payloadTypeLength = varint.encode(payloadType.length);\n    const payloadLength = varint.encode(payload.length);\n    return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);\n};\n//# sourceMappingURL=index.js.map","export const codes = {\n    ERR_SIGNATURE_NOT_VALID: 'ERR_SIGNATURE_NOT_VALID'\n};\n//# sourceMappingURL=errors.js.map","// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record';\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);\n//# sourceMappingURL=consts.js.map","import { peerIdFromBytes } from '@libp2p/peer-id';\nimport { arrayEquals } from '@libp2p/utils/array-equals';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { ENVELOPE_DOMAIN_PEER_RECORD, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD } from './consts.js';\nimport { PeerRecord as Protobuf } from './peer-record.js';\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nexport class PeerRecord {\n    /**\n     * Unmarshal Peer Record Protobuf\n     */\n    static createFromProtobuf = (buf) => {\n        const peerRecord = Protobuf.decode(buf);\n        const peerId = peerIdFromBytes(peerRecord.peerId);\n        const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));\n        const seqNumber = peerRecord.seq;\n        return new PeerRecord({ peerId, multiaddrs, seqNumber });\n    };\n    static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;\n    static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;\n    peerId;\n    multiaddrs;\n    seqNumber;\n    domain = PeerRecord.DOMAIN;\n    codec = PeerRecord.CODEC;\n    marshaled;\n    constructor(init) {\n        const { peerId, multiaddrs, seqNumber } = init;\n        this.peerId = peerId;\n        this.multiaddrs = multiaddrs ?? [];\n        this.seqNumber = seqNumber ?? BigInt(Date.now());\n    }\n    /**\n     * Marshal a record to be used in an envelope\n     */\n    marshal() {\n        if (this.marshaled == null) {\n            this.marshaled = Protobuf.encode({\n                peerId: this.peerId.toBytes(),\n                seq: BigInt(this.seqNumber),\n                addresses: this.multiaddrs.map((m) => ({\n                    multiaddr: m.bytes\n                }))\n            });\n        }\n        return this.marshaled;\n    }\n    /**\n     * Returns true if `this` record equals the `other`\n     */\n    equals(other) {\n        if (!(other instanceof PeerRecord)) {\n            return false;\n        }\n        // Validate PeerId\n        if (!this.peerId.equals(other.peerId)) {\n            return false;\n        }\n        // Validate seqNumber\n        if (this.seqNumber !== other.seqNumber) {\n            return false;\n        }\n        // Validate multiaddrs\n        if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n            return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var PeerRecord;\n(function (PeerRecord) {\n    let AddressInfo;\n    (function (AddressInfo) {\n        let _codec;\n        AddressInfo.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n                        w.uint32(10);\n                        w.bytes(obj.multiaddr);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        multiaddr: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.multiaddr = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        AddressInfo.encode = (obj) => {\n            return encodeMessage(obj, AddressInfo.codec());\n        };\n        AddressInfo.decode = (buf) => {\n            return decodeMessage(buf, AddressInfo.codec());\n        };\n    })(AddressInfo = PeerRecord.AddressInfo || (PeerRecord.AddressInfo = {}));\n    let _codec;\n    PeerRecord.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.peerId);\n                }\n                if ((obj.seq != null && obj.seq !== 0n)) {\n                    w.uint32(16);\n                    w.uint64(obj.seq);\n                }\n                if (obj.addresses != null) {\n                    for (const value of obj.addresses) {\n                        w.uint32(26);\n                        PeerRecord.AddressInfo.codec().encode(value, w);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    peerId: new Uint8Array(0),\n                    seq: 0n,\n                    addresses: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.peerId = reader.bytes();\n                            break;\n                        case 2:\n                            obj.seq = reader.uint64();\n                            break;\n                        case 3:\n                            obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    PeerRecord.encode = (obj) => {\n        return encodeMessage(obj, PeerRecord.codec());\n    };\n    PeerRecord.decode = (buf) => {\n        return decodeMessage(buf, PeerRecord.codec());\n    };\n})(PeerRecord || (PeerRecord = {}));\n//# sourceMappingURL=peer-record.js.map","export const codes = {\n    ERR_INVALID_PARAMETERS: 'ERR_INVALID_PARAMETERS'\n};\n//# sourceMappingURL=errors.js.map","/**\n * @packageDocumentation\n *\n * The peer store is where libp2p stores data about the peers it has encountered on the network.\n */\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport all from 'it-all';\nimport { PersistentStore } from './store.js';\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nexport class PersistentPeerStore {\n    store;\n    events;\n    peerId;\n    log;\n    constructor(components, init = {}) {\n        this.log = components.logger.forComponent('libp2p:peer-store');\n        this.events = components.events;\n        this.peerId = components.peerId;\n        this.store = new PersistentStore(components, init);\n    }\n    [Symbol.toStringTag] = '@libp2p/peer-store';\n    async forEach(fn, query) {\n        this.log.trace('forEach await read lock');\n        const release = await this.store.lock.readLock();\n        this.log.trace('forEach got read lock');\n        try {\n            for await (const peer of this.store.all(query)) {\n                fn(peer);\n            }\n        }\n        finally {\n            this.log.trace('forEach release read lock');\n            release();\n        }\n    }\n    async all(query) {\n        this.log.trace('all await read lock');\n        const release = await this.store.lock.readLock();\n        this.log.trace('all got read lock');\n        try {\n            return await all(this.store.all(query));\n        }\n        finally {\n            this.log.trace('all release read lock');\n            release();\n        }\n    }\n    async delete(peerId) {\n        this.log.trace('delete await write lock');\n        const release = await this.store.lock.writeLock();\n        this.log.trace('delete got write lock');\n        try {\n            await this.store.delete(peerId);\n        }\n        finally {\n            this.log.trace('delete release write lock');\n            release();\n        }\n    }\n    async has(peerId) {\n        this.log.trace('has await read lock');\n        const release = await this.store.lock.readLock();\n        this.log.trace('has got read lock');\n        try {\n            return await this.store.has(peerId);\n        }\n        finally {\n            this.log.trace('has release read lock');\n            release();\n        }\n    }\n    async get(peerId) {\n        this.log.trace('get await read lock');\n        const release = await this.store.lock.readLock();\n        this.log.trace('get got read lock');\n        try {\n            return await this.store.load(peerId);\n        }\n        finally {\n            this.log.trace('get release read lock');\n            release();\n        }\n    }\n    async save(id, data) {\n        this.log.trace('save await write lock');\n        const release = await this.store.lock.writeLock();\n        this.log.trace('save got write lock');\n        try {\n            const result = await this.store.save(id, data);\n            this.#emitIfUpdated(id, result);\n            return result.peer;\n        }\n        finally {\n            this.log.trace('save release write lock');\n            release();\n        }\n    }\n    async patch(id, data) {\n        this.log.trace('patch await write lock');\n        const release = await this.store.lock.writeLock();\n        this.log.trace('patch got write lock');\n        try {\n            const result = await this.store.patch(id, data);\n            this.#emitIfUpdated(id, result);\n            return result.peer;\n        }\n        finally {\n            this.log.trace('patch release write lock');\n            release();\n        }\n    }\n    async merge(id, data) {\n        this.log.trace('merge await write lock');\n        const release = await this.store.lock.writeLock();\n        this.log.trace('merge got write lock');\n        try {\n            const result = await this.store.merge(id, data);\n            this.#emitIfUpdated(id, result);\n            return result.peer;\n        }\n        finally {\n            this.log.trace('merge release write lock');\n            release();\n        }\n    }\n    async consumePeerRecord(buf, expectedPeer) {\n        const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN);\n        if (expectedPeer?.equals(envelope.peerId) === false) {\n            this.log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, envelope.peerId);\n            return false;\n        }\n        const peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n        let peer;\n        try {\n            peer = await this.get(envelope.peerId);\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        // ensure seq is greater than, or equal to, the last received\n        if (peer?.peerRecordEnvelope != null) {\n            const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);\n            const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);\n            if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n                this.log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n                return false;\n            }\n        }\n        await this.patch(peerRecord.peerId, {\n            peerRecordEnvelope: buf,\n            addresses: peerRecord.multiaddrs.map(multiaddr => ({\n                isCertified: true,\n                multiaddr\n            }))\n        });\n        return true;\n    }\n    #emitIfUpdated(id, result) {\n        if (!result.updated) {\n            return;\n        }\n        if (this.peerId.equals(id)) {\n            this.events.safeDispatchEvent('self:peer:update', { detail: result });\n        }\n        else {\n            this.events.safeDispatchEvent('peer:update', { detail: result });\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime';\nexport var Peer;\n(function (Peer) {\n    let Peer$metadataEntry;\n    (function (Peer$metadataEntry) {\n        let _codec;\n        Peer$metadataEntry.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.key != null && obj.key !== '')) {\n                        w.uint32(10);\n                        w.string(obj.key);\n                    }\n                    if ((obj.value != null && obj.value.byteLength > 0)) {\n                        w.uint32(18);\n                        w.bytes(obj.value);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        key: '',\n                        value: new Uint8Array(0)\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.key = reader.string();\n                                break;\n                            case 2:\n                                obj.value = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Peer$metadataEntry.encode = (obj) => {\n            return encodeMessage(obj, Peer$metadataEntry.codec());\n        };\n        Peer$metadataEntry.decode = (buf) => {\n            return decodeMessage(buf, Peer$metadataEntry.codec());\n        };\n    })(Peer$metadataEntry = Peer.Peer$metadataEntry || (Peer.Peer$metadataEntry = {}));\n    let Peer$tagsEntry;\n    (function (Peer$tagsEntry) {\n        let _codec;\n        Peer$tagsEntry.codec = () => {\n            if (_codec == null) {\n                _codec = message((obj, w, opts = {}) => {\n                    if (opts.lengthDelimited !== false) {\n                        w.fork();\n                    }\n                    if ((obj.key != null && obj.key !== '')) {\n                        w.uint32(10);\n                        w.string(obj.key);\n                    }\n                    if (obj.value != null) {\n                        w.uint32(18);\n                        Tag.codec().encode(obj.value, w);\n                    }\n                    if (opts.lengthDelimited !== false) {\n                        w.ldelim();\n                    }\n                }, (reader, length) => {\n                    const obj = {\n                        key: ''\n                    };\n                    const end = length == null ? reader.len : reader.pos + length;\n                    while (reader.pos < end) {\n                        const tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                obj.key = reader.string();\n                                break;\n                            case 2:\n                                obj.value = Tag.codec().decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return obj;\n                });\n            }\n            return _codec;\n        };\n        Peer$tagsEntry.encode = (obj) => {\n            return encodeMessage(obj, Peer$tagsEntry.codec());\n        };\n        Peer$tagsEntry.decode = (buf) => {\n            return decodeMessage(buf, Peer$tagsEntry.codec());\n        };\n    })(Peer$tagsEntry = Peer.Peer$tagsEntry || (Peer.Peer$tagsEntry = {}));\n    let _codec;\n    Peer.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.addresses != null) {\n                    for (const value of obj.addresses) {\n                        w.uint32(10);\n                        Address.codec().encode(value, w);\n                    }\n                }\n                if (obj.protocols != null) {\n                    for (const value of obj.protocols) {\n                        w.uint32(18);\n                        w.string(value);\n                    }\n                }\n                if (obj.publicKey != null) {\n                    w.uint32(34);\n                    w.bytes(obj.publicKey);\n                }\n                if (obj.peerRecordEnvelope != null) {\n                    w.uint32(42);\n                    w.bytes(obj.peerRecordEnvelope);\n                }\n                if (obj.metadata != null && obj.metadata.size !== 0) {\n                    for (const [key, value] of obj.metadata.entries()) {\n                        w.uint32(50);\n                        Peer.Peer$metadataEntry.codec().encode({ key, value }, w);\n                    }\n                }\n                if (obj.tags != null && obj.tags.size !== 0) {\n                    for (const [key, value] of obj.tags.entries()) {\n                        w.uint32(58);\n                        Peer.Peer$tagsEntry.codec().encode({ key, value }, w);\n                    }\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    addresses: [],\n                    protocols: [],\n                    metadata: new Map(),\n                    tags: new Map()\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.addresses.push(Address.codec().decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            obj.protocols.push(reader.string());\n                            break;\n                        case 4:\n                            obj.publicKey = reader.bytes();\n                            break;\n                        case 5:\n                            obj.peerRecordEnvelope = reader.bytes();\n                            break;\n                        case 6: {\n                            const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32());\n                            obj.metadata.set(entry.key, entry.value);\n                            break;\n                        }\n                        case 7: {\n                            const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32());\n                            obj.tags.set(entry.key, entry.value);\n                            break;\n                        }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Peer.encode = (obj) => {\n        return encodeMessage(obj, Peer.codec());\n    };\n    Peer.decode = (buf) => {\n        return decodeMessage(buf, Peer.codec());\n    };\n})(Peer || (Peer = {}));\nexport var Address;\n(function (Address) {\n    let _codec;\n    Address.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.multiaddr);\n                }\n                if (obj.isCertified != null) {\n                    w.uint32(16);\n                    w.bool(obj.isCertified);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    multiaddr: new Uint8Array(0)\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.multiaddr = reader.bytes();\n                            break;\n                        case 2:\n                            obj.isCertified = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Address.encode = (obj) => {\n        return encodeMessage(obj, Address.codec());\n    };\n    Address.decode = (buf) => {\n        return decodeMessage(buf, Address.codec());\n    };\n})(Address || (Address = {}));\nexport var Tag;\n(function (Tag) {\n    let _codec;\n    Tag.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.value != null && obj.value !== 0)) {\n                    w.uint32(8);\n                    w.uint32(obj.value);\n                }\n                if (obj.expiry != null) {\n                    w.uint32(16);\n                    w.uint64(obj.expiry);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    value: 0\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.value = reader.uint32();\n                            break;\n                        case 2:\n                            obj.expiry = reader.uint64();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Tag.encode = (obj) => {\n        return encodeMessage(obj, Tag.codec());\n    };\n    Tag.decode = (buf) => {\n        return decodeMessage(buf, Tag.codec());\n    };\n})(Tag || (Tag = {}));\n//# sourceMappingURL=peer.js.map","import { CodeError } from '@libp2p/interface';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport mortice, {} from 'mortice';\nimport { base32 } from 'multiformats/bases/base32';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { codes } from './errors.js';\nimport { Peer as PeerPB } from './pb/peer.js';\nimport { bytesToPeer } from './utils/bytes-to-peer.js';\nimport { NAMESPACE_COMMON, peerIdToDatastoreKey } from './utils/peer-id-to-datastore-key.js';\nimport { toPeerPB } from './utils/to-peer-pb.js';\nfunction decodePeer(key, value, cache) {\n    // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n    const base32Str = key.toString().split('/')[2];\n    const buf = base32.decode(base32Str);\n    const peerId = peerIdFromBytes(buf);\n    const cached = cache.get(peerId);\n    if (cached != null) {\n        return cached;\n    }\n    const peer = bytesToPeer(peerId, value);\n    cache.set(peerId, peer);\n    return peer;\n}\nfunction mapQuery(query, cache) {\n    if (query == null) {\n        return {};\n    }\n    return {\n        prefix: NAMESPACE_COMMON,\n        filters: (query.filters ?? []).map(fn => ({ key, value }) => {\n            return fn(decodePeer(key, value, cache));\n        }),\n        orders: (query.orders ?? []).map(fn => (a, b) => {\n            return fn(decodePeer(a.key, a.value, cache), decodePeer(b.key, b.value, cache));\n        })\n    };\n}\nexport class PersistentStore {\n    peerId;\n    datastore;\n    lock;\n    addressFilter;\n    constructor(components, init = {}) {\n        this.peerId = components.peerId;\n        this.datastore = components.datastore;\n        this.addressFilter = init.addressFilter;\n        this.lock = mortice({\n            name: 'peer-store',\n            singleProcess: true\n        });\n    }\n    async has(peerId) {\n        return this.datastore.has(peerIdToDatastoreKey(peerId));\n    }\n    async delete(peerId) {\n        if (this.peerId.equals(peerId)) {\n            throw new CodeError('Cannot delete self peer', codes.ERR_INVALID_PARAMETERS);\n        }\n        await this.datastore.delete(peerIdToDatastoreKey(peerId));\n    }\n    async load(peerId) {\n        const buf = await this.datastore.get(peerIdToDatastoreKey(peerId));\n        return bytesToPeer(peerId, buf);\n    }\n    async save(peerId, data) {\n        const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);\n        const peerPb = await toPeerPB(peerId, data, 'patch', {\n            addressFilter: this.addressFilter\n        });\n        return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);\n    }\n    async patch(peerId, data) {\n        const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);\n        const peerPb = await toPeerPB(peerId, data, 'patch', {\n            addressFilter: this.addressFilter,\n            existingPeer\n        });\n        return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);\n    }\n    async merge(peerId, data) {\n        const { existingBuf, existingPeer } = await this.#findExistingPeer(peerId);\n        const peerPb = await toPeerPB(peerId, data, 'merge', {\n            addressFilter: this.addressFilter,\n            existingPeer\n        });\n        return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer);\n    }\n    async *all(query) {\n        const peerCache = new PeerMap();\n        for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))) {\n            const peer = decodePeer(key, value, peerCache);\n            if (peer.id.equals(this.peerId)) {\n                // Skip self peer if present\n                continue;\n            }\n            yield peer;\n        }\n    }\n    async #findExistingPeer(peerId) {\n        try {\n            const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId));\n            const existingPeer = bytesToPeer(peerId, existingBuf);\n            return {\n                existingBuf,\n                existingPeer\n            };\n        }\n        catch (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n                throw err;\n            }\n        }\n        return {};\n    }\n    async #saveIfDifferent(peerId, peer, existingBuf, existingPeer) {\n        const buf = PeerPB.encode(peer);\n        if (existingBuf != null && uint8ArrayEquals(buf, existingBuf)) {\n            return {\n                peer: bytesToPeer(peerId, buf),\n                previous: existingPeer,\n                updated: false\n            };\n        }\n        await this.datastore.put(peerIdToDatastoreKey(peerId), buf);\n        return {\n            peer: bytesToPeer(peerId, buf),\n            previous: existingPeer,\n            updated: true\n        };\n    }\n}\n//# sourceMappingURL=store.js.map","import { peerIdFromPeerId } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Peer as PeerPB } from '../pb/peer.js';\nexport function bytesToPeer(peerId, buf) {\n    const peer = PeerPB.decode(buf);\n    if (peer.publicKey != null && peerId.publicKey == null) {\n        peerId = peerIdFromPeerId({\n            ...peerId,\n            publicKey: peerId.publicKey\n        });\n    }\n    const tags = new Map();\n    // remove any expired tags\n    const now = BigInt(Date.now());\n    for (const [key, tag] of peer.tags.entries()) {\n        if (tag.expiry != null && tag.expiry < now) {\n            continue;\n        }\n        tags.set(key, tag);\n    }\n    return {\n        ...peer,\n        id: peerId,\n        addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {\n            return {\n                multiaddr: multiaddr(ma),\n                isCertified: isCertified ?? false\n            };\n        }),\n        metadata: peer.metadata,\n        peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,\n        tags\n    };\n}\n//# sourceMappingURL=bytes-to-peer.js.map","import { CodeError } from '@libp2p/interface';\nimport { isMultiaddr, multiaddr } from '@multiformats/multiaddr';\nimport { codes } from '../errors.js';\nexport async function dedupeFilterAndSortAddresses(peerId, filter, addresses) {\n    const addressMap = new Map();\n    for (const addr of addresses) {\n        if (addr == null) {\n            continue;\n        }\n        if (addr.multiaddr instanceof Uint8Array) {\n            addr.multiaddr = multiaddr(addr.multiaddr);\n        }\n        if (!isMultiaddr(addr.multiaddr)) {\n            throw new CodeError('Multiaddr was invalid', codes.ERR_INVALID_PARAMETERS);\n        }\n        if (!(await filter(peerId, addr.multiaddr))) {\n            continue;\n        }\n        const isCertified = addr.isCertified ?? false;\n        const maStr = addr.multiaddr.toString();\n        const existingAddr = addressMap.get(maStr);\n        if (existingAddr != null) {\n            addr.isCertified = existingAddr.isCertified || isCertified;\n        }\n        else {\n            addressMap.set(maStr, {\n                multiaddr: addr.multiaddr,\n                isCertified\n            });\n        }\n    }\n    return [...addressMap.values()]\n        .sort((a, b) => {\n        return a.multiaddr.toString().localeCompare(b.multiaddr.toString());\n    })\n        .map(({ isCertified, multiaddr }) => ({\n        isCertified,\n        multiaddr: multiaddr.bytes\n    }));\n}\n//# sourceMappingURL=dedupe-addresses.js.map","import { CodeError } from '@libp2p/interface';\nimport { isPeerId } from '@libp2p/interface';\nimport { Key } from 'interface-datastore/key';\nimport { codes } from '../errors.js';\nexport const NAMESPACE_COMMON = '/peers/';\nexport function peerIdToDatastoreKey(peerId) {\n    if (!isPeerId(peerId) || peerId.type == null) {\n        throw new CodeError('Invalid PeerId', codes.ERR_INVALID_PARAMETERS);\n    }\n    const b32key = peerId.toCID().toString();\n    return new Key(`${NAMESPACE_COMMON}${b32key}`);\n}\n//# sourceMappingURL=peer-id-to-datastore-key.js.map","import { CodeError } from '@libp2p/interface';\nimport { equals as uint8arrayEquals } from 'uint8arrays/equals';\nimport { codes } from '../errors.js';\nimport { dedupeFilterAndSortAddresses } from './dedupe-addresses.js';\nexport async function toPeerPB(peerId, data, strategy, options) {\n    if (data == null) {\n        throw new CodeError('Invalid PeerData', codes.ERR_INVALID_PARAMETERS);\n    }\n    if (data.publicKey != null && peerId.publicKey != null && !uint8arrayEquals(data.publicKey, peerId.publicKey)) {\n        throw new CodeError('publicKey bytes do not match peer id publicKey bytes', codes.ERR_INVALID_PARAMETERS);\n    }\n    const existingPeer = options.existingPeer;\n    if (existingPeer != null && !peerId.equals(existingPeer.id)) {\n        throw new CodeError('peer id did not match existing peer id', codes.ERR_INVALID_PARAMETERS);\n    }\n    let addresses = existingPeer?.addresses ?? [];\n    let protocols = new Set(existingPeer?.protocols ?? []);\n    let metadata = existingPeer?.metadata ?? new Map();\n    let tags = existingPeer?.tags ?? new Map();\n    let peerRecordEnvelope = existingPeer?.peerRecordEnvelope;\n    // when patching, we replace the original fields with passed values\n    if (strategy === 'patch') {\n        if (data.multiaddrs != null || data.addresses != null) {\n            addresses = [];\n            if (data.multiaddrs != null) {\n                addresses.push(...data.multiaddrs.map(multiaddr => ({\n                    isCertified: false,\n                    multiaddr\n                })));\n            }\n            if (data.addresses != null) {\n                addresses.push(...data.addresses);\n            }\n        }\n        if (data.protocols != null) {\n            protocols = new Set(data.protocols);\n        }\n        if (data.metadata != null) {\n            const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);\n            metadata = createSortedMap(metadataEntries, {\n                validate: validateMetadata\n            });\n        }\n        if (data.tags != null) {\n            const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);\n            tags = createSortedMap(tagsEntries, {\n                validate: validateTag,\n                map: mapTag\n            });\n        }\n        if (data.peerRecordEnvelope != null) {\n            peerRecordEnvelope = data.peerRecordEnvelope;\n        }\n    }\n    // when merging, we join the original fields with passed values\n    if (strategy === 'merge') {\n        if (data.multiaddrs != null) {\n            addresses.push(...data.multiaddrs.map(multiaddr => ({\n                isCertified: false,\n                multiaddr\n            })));\n        }\n        if (data.addresses != null) {\n            addresses.push(...data.addresses);\n        }\n        if (data.protocols != null) {\n            protocols = new Set([...protocols, ...data.protocols]);\n        }\n        if (data.metadata != null) {\n            const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);\n            for (const [key, value] of metadataEntries) {\n                if (value == null) {\n                    metadata.delete(key);\n                }\n                else {\n                    metadata.set(key, value);\n                }\n            }\n            metadata = createSortedMap([...metadata.entries()], {\n                validate: validateMetadata\n            });\n        }\n        if (data.tags != null) {\n            const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);\n            const mergedTags = new Map(tags);\n            for (const [key, value] of tagsEntries) {\n                if (value == null) {\n                    mergedTags.delete(key);\n                }\n                else {\n                    mergedTags.set(key, value);\n                }\n            }\n            tags = createSortedMap([...mergedTags.entries()], {\n                validate: validateTag,\n                map: mapTag\n            });\n        }\n        if (data.peerRecordEnvelope != null) {\n            peerRecordEnvelope = data.peerRecordEnvelope;\n        }\n    }\n    const output = {\n        addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),\n        protocols: [...protocols.values()].sort((a, b) => {\n            return a.localeCompare(b);\n        }),\n        metadata,\n        tags,\n        publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId.publicKey,\n        peerRecordEnvelope\n    };\n    // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it\n    if (peerId.type !== 'RSA') {\n        delete output.publicKey;\n    }\n    return output;\n}\n/**\n * In JS maps are ordered by insertion order so create a new map with the\n * keys inserted in alphabetical order.\n */\nfunction createSortedMap(entries, options) {\n    const output = new Map();\n    for (const [key, value] of entries) {\n        if (value == null) {\n            continue;\n        }\n        options.validate(key, value);\n    }\n    for (const [key, value] of entries.sort(([a], [b]) => {\n        return a.localeCompare(b);\n    })) {\n        if (value != null) {\n            output.set(key, options.map?.(key, value) ?? value);\n        }\n    }\n    return output;\n}\nfunction validateMetadata(key, value) {\n    if (typeof key !== 'string') {\n        throw new CodeError('Metadata key must be a string', codes.ERR_INVALID_PARAMETERS);\n    }\n    if (!(value instanceof Uint8Array)) {\n        throw new CodeError('Metadata value must be a Uint8Array', codes.ERR_INVALID_PARAMETERS);\n    }\n}\nfunction validateTag(key, tag) {\n    if (typeof key !== 'string') {\n        throw new CodeError('Tag name must be a string', codes.ERR_INVALID_PARAMETERS);\n    }\n    if (tag.value != null) {\n        if (parseInt(`${tag.value}`, 10) !== tag.value) {\n            throw new CodeError('Tag value must be an integer', codes.ERR_INVALID_PARAMETERS);\n        }\n        if (tag.value < 0 || tag.value > 100) {\n            throw new CodeError('Tag value must be between 0-100', codes.ERR_INVALID_PARAMETERS);\n        }\n    }\n    if (tag.ttl != null) {\n        if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {\n            throw new CodeError('Tag ttl must be an integer', codes.ERR_INVALID_PARAMETERS);\n        }\n        if (tag.ttl < 0) {\n            throw new CodeError('Tag ttl must be between greater than 0', codes.ERR_INVALID_PARAMETERS);\n        }\n    }\n}\nfunction mapTag(key, tag) {\n    let expiry;\n    if (tag.expiry != null) {\n        expiry = tag.expiry;\n    }\n    if (tag.ttl != null) {\n        expiry = BigInt(Date.now() + Number(tag.ttl));\n    }\n    return {\n        value: tag.value ?? 0,\n        expiry\n    };\n}\n//# sourceMappingURL=to-peer-pb.js.map","/**\n * @packageDocumentation\n *\n * This is an implementation of the [routing record format](https://github.com/libp2p/specs/blob/b9efe152c29f93f7a87931c14d78ae11e7924d5a/kad-dht/README.md?plain=1#L408-L425) used by libp2p to store data in the datastore passed to the libp2p constructor.\n *\n * @example Deserialization\n *\n * ```TypeScript\n * import { Libp2pRecord } from '@libp2p/record'\n *\n * const buf = Uint8Array.from([0, 1, 2, 3])\n * const record = Libp2pRecord.deserialize(buf)\n * ```\n *\n * @example Serialization\n *\n * ```TypeScript\n * import { Libp2pRecord } from '@libp2p/record'\n *\n * const key = Uint8Array.from([0, 1, 2, 3])\n * const value = Uint8Array.from([0, 1, 2, 3])\n * const timeReceived = new Date()\n *\n * const record = new Libp2pRecord(key, value, timeReceived)\n * const buf = record.serialize()\n * ```\n */\nimport { Record } from './record.js';\nimport * as utils from './utils.js';\nexport class Libp2pRecord {\n    key;\n    value;\n    timeReceived;\n    constructor(key, value, timeReceived) {\n        if (!(key instanceof Uint8Array)) {\n            throw new Error('key must be a Uint8Array');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('value must be a Uint8Array');\n        }\n        this.key = key;\n        this.value = value;\n        this.timeReceived = timeReceived;\n    }\n    serialize() {\n        return Record.encode(this.prepareSerialize());\n    }\n    /**\n     * Return the object format ready to be given to the protobuf library.\n     */\n    prepareSerialize() {\n        return {\n            key: this.key,\n            value: this.value,\n            timeReceived: utils.toRFC3339(this.timeReceived)\n        };\n    }\n    /**\n     * Decode a protobuf encoded record\n     */\n    static deserialize(raw) {\n        const rec = Record.decode(raw);\n        return new Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));\n    }\n    /**\n     * Create a record from the raw object returned from the protobuf library\n     */\n    static fromDeserialized(obj) {\n        const recvtime = utils.parseRFC3339(obj.timeReceived);\n        if (obj.key == null) {\n            throw new Error('key missing from deserialized object');\n        }\n        if (obj.value == null) {\n            throw new Error('value missing from deserialized object');\n        }\n        const rec = new Libp2pRecord(obj.key, obj.value, recvtime);\n        return rec;\n    }\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\nimport { decodeMessage, encodeMessage, message } from 'protons-runtime';\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nexport var Record;\n(function (Record) {\n    let _codec;\n    Record.codec = () => {\n        if (_codec == null) {\n            _codec = message((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if ((obj.key != null && obj.key.byteLength > 0)) {\n                    w.uint32(10);\n                    w.bytes(obj.key);\n                }\n                if ((obj.value != null && obj.value.byteLength > 0)) {\n                    w.uint32(18);\n                    w.bytes(obj.value);\n                }\n                if ((obj.timeReceived != null && obj.timeReceived !== '')) {\n                    w.uint32(42);\n                    w.string(obj.timeReceived);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length, opts = {}) => {\n                const obj = {\n                    key: uint8ArrayAlloc(0),\n                    value: uint8ArrayAlloc(0),\n                    timeReceived: ''\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1: {\n                            obj.key = reader.bytes();\n                            break;\n                        }\n                        case 2: {\n                            obj.value = reader.bytes();\n                            break;\n                        }\n                        case 5: {\n                            obj.timeReceived = reader.string();\n                            break;\n                        }\n                        default: {\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Record.encode = (obj) => {\n        return encodeMessage(obj, Record.codec());\n    };\n    Record.decode = (buf, opts) => {\n        return decodeMessage(buf, Record.codec(), opts);\n    };\n})(Record || (Record = {}));\n//# sourceMappingURL=record.js.map","/**\n * Convert a JavaScript date into an `RFC3339Nano` formatted\n * string\n */\nexport function toRFC3339(time) {\n    const year = time.getUTCFullYear();\n    const month = String(time.getUTCMonth() + 1).padStart(2, '0');\n    const day = String(time.getUTCDate()).padStart(2, '0');\n    const hour = String(time.getUTCHours()).padStart(2, '0');\n    const minute = String(time.getUTCMinutes()).padStart(2, '0');\n    const seconds = String(time.getUTCSeconds()).padStart(2, '0');\n    const milliseconds = time.getUTCMilliseconds();\n    const nanoseconds = String(milliseconds * 1000 * 1000).padStart(9, '0');\n    return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`;\n}\n/**\n * Parses a date string formatted as `RFC3339Nano` into a\n * JavaScript Date object\n */\nexport function parseRFC3339(time) {\n    const rfc3339Matcher = new RegExp(\n    // 2006-01-02T\n    '(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T' +\n        // 15:04:05\n        '(\\\\d{2}):(\\\\d{2}):(\\\\d{2})' +\n        // .999999999Z\n        '\\\\.(\\\\d+)Z');\n    const m = String(time).trim().match(rfc3339Matcher);\n    if (m == null) {\n        throw new Error('Invalid format');\n    }\n    const year = parseInt(m[1], 10);\n    const month = parseInt(m[2], 10) - 1;\n    const date = parseInt(m[3], 10);\n    const hour = parseInt(m[4], 10);\n    const minute = parseInt(m[5], 10);\n    const second = parseInt(m[6], 10);\n    const millisecond = parseInt(m[7].slice(0, -6), 10);\n    return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));\n}\n//# sourceMappingURL=utils.js.map","import { CodeError } from '@libp2p/interface';\nimport { pushable } from 'it-pushable';\nimport defer, {} from 'p-defer';\nimport pDefer from 'p-defer';\nimport { raceSignal } from 'race-signal';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { closeSource } from './close-source.js';\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET';\nconst ERR_SINK_INVALID_STATE = 'ERR_SINK_INVALID_STATE';\nconst DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000;\nfunction isPromise(thing) {\n    if (thing == null) {\n        return false;\n    }\n    return typeof thing.then === 'function' &&\n        typeof thing.catch === 'function' &&\n        typeof thing.finally === 'function';\n}\nexport class AbstractStream {\n    id;\n    direction;\n    timeline;\n    protocol;\n    metadata;\n    source;\n    status;\n    readStatus;\n    writeStatus;\n    log;\n    sinkController;\n    sinkEnd;\n    closed;\n    endErr;\n    streamSource;\n    onEnd;\n    onCloseRead;\n    onCloseWrite;\n    onReset;\n    onAbort;\n    sendCloseWriteTimeout;\n    sendingData;\n    constructor(init) {\n        this.sinkController = new AbortController();\n        this.sinkEnd = defer();\n        this.closed = defer();\n        this.log = init.log;\n        // stream status\n        this.status = 'open';\n        this.readStatus = 'ready';\n        this.writeStatus = 'ready';\n        this.id = init.id;\n        this.metadata = init.metadata ?? {};\n        this.direction = init.direction;\n        this.timeline = {\n            open: Date.now()\n        };\n        this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;\n        this.onEnd = init.onEnd;\n        this.onCloseRead = init?.onCloseRead;\n        this.onCloseWrite = init?.onCloseWrite;\n        this.onReset = init?.onReset;\n        this.onAbort = init?.onAbort;\n        this.source = this.streamSource = pushable({\n            onEnd: (err) => {\n                if (err != null) {\n                    this.log.trace('source ended with error', err);\n                }\n                else {\n                    this.log.trace('source ended');\n                }\n                this.onSourceEnd(err);\n            }\n        });\n        // necessary because the libp2p upgrader wraps the sink function\n        this.sink = this.sink.bind(this);\n    }\n    async sink(source) {\n        if (this.writeStatus !== 'ready') {\n            throw new CodeError(`writable end state is \"${this.writeStatus}\" not \"ready\"`, ERR_SINK_INVALID_STATE);\n        }\n        try {\n            this.writeStatus = 'writing';\n            const options = {\n                signal: this.sinkController.signal\n            };\n            if (this.direction === 'outbound') { // If initiator, open a new stream\n                const res = this.sendNewStream(options);\n                if (isPromise(res)) {\n                    await res;\n                }\n            }\n            const abortListener = () => {\n                closeSource(source, this.log);\n            };\n            try {\n                this.sinkController.signal.addEventListener('abort', abortListener);\n                this.log.trace('sink reading from source');\n                for await (let data of source) {\n                    data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;\n                    const res = this.sendData(data, options);\n                    if (isPromise(res)) {\n                        this.sendingData = pDefer();\n                        await res;\n                        this.sendingData.resolve();\n                        this.sendingData = undefined;\n                    }\n                }\n            }\n            finally {\n                this.sinkController.signal.removeEventListener('abort', abortListener);\n            }\n            this.log.trace('sink finished reading from source, write status is \"%s\"', this.writeStatus);\n            if (this.writeStatus === 'writing') {\n                this.writeStatus = 'closing';\n                this.log.trace('send close write to remote');\n                await this.sendCloseWrite({\n                    signal: AbortSignal.timeout(this.sendCloseWriteTimeout)\n                });\n                this.writeStatus = 'closed';\n            }\n            this.onSinkEnd();\n        }\n        catch (err) {\n            this.log.trace('sink ended with error, calling abort with error', err);\n            this.abort(err);\n            throw err;\n        }\n        finally {\n            this.log.trace('resolve sink end');\n            this.sinkEnd.resolve();\n        }\n    }\n    onSourceEnd(err) {\n        if (this.timeline.closeRead != null) {\n            return;\n        }\n        this.timeline.closeRead = Date.now();\n        this.readStatus = 'closed';\n        if (err != null && this.endErr == null) {\n            this.endErr = err;\n        }\n        this.onCloseRead?.();\n        if (this.timeline.closeWrite != null) {\n            this.log.trace('source and sink ended');\n            this.timeline.close = Date.now();\n            if (this.status !== 'aborted' && this.status !== 'reset') {\n                this.status = 'closed';\n            }\n            if (this.onEnd != null) {\n                this.onEnd(this.endErr);\n            }\n            this.closed.resolve();\n        }\n        else {\n            this.log.trace('source ended, waiting for sink to end');\n        }\n    }\n    onSinkEnd(err) {\n        if (this.timeline.closeWrite != null) {\n            return;\n        }\n        this.timeline.closeWrite = Date.now();\n        this.writeStatus = 'closed';\n        if (err != null && this.endErr == null) {\n            this.endErr = err;\n        }\n        this.onCloseWrite?.();\n        if (this.timeline.closeRead != null) {\n            this.log.trace('sink and source ended');\n            this.timeline.close = Date.now();\n            if (this.status !== 'aborted' && this.status !== 'reset') {\n                this.status = 'closed';\n            }\n            if (this.onEnd != null) {\n                this.onEnd(this.endErr);\n            }\n            this.closed.resolve();\n        }\n        else {\n            this.log.trace('sink ended, waiting for source to end');\n        }\n    }\n    // Close for both Reading and Writing\n    async close(options) {\n        this.log.trace('closing gracefully');\n        this.status = 'closing';\n        // wait for read and write ends to close\n        await raceSignal(Promise.all([\n            this.closeWrite(options),\n            this.closeRead(options),\n            this.closed.promise\n        ]), options?.signal);\n        this.status = 'closed';\n        this.log.trace('closed gracefully');\n    }\n    async closeRead(options = {}) {\n        if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n            return;\n        }\n        this.log.trace('closing readable end of stream with starting read status \"%s\"', this.readStatus);\n        const readStatus = this.readStatus;\n        this.readStatus = 'closing';\n        if (this.status !== 'reset' && this.status !== 'aborted' && this.timeline.closeRead == null) {\n            this.log.trace('send close read to remote');\n            await this.sendCloseRead(options);\n        }\n        if (readStatus === 'ready') {\n            this.log.trace('ending internal source queue with %d queued bytes', this.streamSource.readableLength);\n            this.streamSource.end();\n        }\n        this.log.trace('closed readable end of stream');\n    }\n    async closeWrite(options = {}) {\n        if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n            return;\n        }\n        this.log.trace('closing writable end of stream with starting write status \"%s\"', this.writeStatus);\n        if (this.writeStatus === 'ready') {\n            this.log.trace('sink was never sunk, sink an empty array');\n            await raceSignal(this.sink([]), options.signal);\n        }\n        if (this.writeStatus === 'writing') {\n            // try to let sending outgoing data succeed\n            if (this.sendingData != null) {\n                await raceSignal(this.sendingData.promise, options.signal);\n            }\n            // stop reading from the source passed to `.sink`\n            this.log.trace('aborting source passed to .sink');\n            this.sinkController.abort();\n            await raceSignal(this.sinkEnd.promise, options.signal);\n        }\n        this.writeStatus = 'closed';\n        this.log.trace('closed writable end of stream');\n    }\n    /**\n     * Close immediately for reading and writing and send a reset message (local\n     * error)\n     */\n    abort(err) {\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n            return;\n        }\n        this.log('abort with error', err);\n        // try to send a reset message\n        this.log('try to send reset to remote');\n        const res = this.sendReset();\n        if (isPromise(res)) {\n            res.catch((err) => {\n                this.log.error('error sending reset message', err);\n            });\n        }\n        this.status = 'aborted';\n        this.timeline.abort = Date.now();\n        this._closeSinkAndSource(err);\n        this.onAbort?.(err);\n    }\n    /**\n     * Receive a reset message - close immediately for reading and writing (remote\n     * error)\n     */\n    reset() {\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n            return;\n        }\n        const err = new CodeError('stream reset', ERR_STREAM_RESET);\n        this.status = 'reset';\n        this.timeline.reset = Date.now();\n        this._closeSinkAndSource(err);\n        this.onReset?.();\n    }\n    _closeSinkAndSource(err) {\n        this._closeSink(err);\n        this._closeSource(err);\n    }\n    _closeSink(err) {\n        // if the sink function is running, cause it to end\n        if (this.writeStatus === 'writing') {\n            this.log.trace('end sink source');\n            this.sinkController.abort();\n        }\n        this.onSinkEnd(err);\n    }\n    _closeSource(err) {\n        // if the source is not ending, end it\n        if (this.readStatus !== 'closing' && this.readStatus !== 'closed') {\n            this.log.trace('ending source with %d bytes to be read by consumer', this.streamSource.readableLength);\n            this.readStatus = 'closing';\n            this.streamSource.end(err);\n        }\n    }\n    /**\n     * The remote closed for writing so we should expect to receive no more\n     * messages\n     */\n    remoteCloseWrite() {\n        if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n            this.log('received remote close write but local source is already closed');\n            return;\n        }\n        this.log.trace('remote close write');\n        this._closeSource();\n    }\n    /**\n     * The remote closed for reading so we should not send any more\n     * messages\n     */\n    remoteCloseRead() {\n        if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n            this.log('received remote close read but local sink is already closed');\n            return;\n        }\n        this.log.trace('remote close read');\n        this._closeSink();\n    }\n    /**\n     * The underlying muxer has closed, no more messages can be sent or will\n     * be received, close immediately to free up resources\n     */\n    destroy() {\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n            this.log('received destroy but we are already closed');\n            return;\n        }\n        this.log.trace('stream destroyed');\n        this._closeSinkAndSource();\n    }\n    /**\n     * When an extending class reads data from it's implementation-specific source,\n     * call this method to allow the stream consumer to read the data.\n     */\n    sourcePush(data) {\n        this.streamSource.push(data);\n    }\n    /**\n     * Returns the amount of unread data - can be used to prevent large amounts of\n     * data building up when the stream consumer is too slow.\n     */\n    sourceReadableLength() {\n        return this.streamSource.readableLength;\n    }\n}\n//# sourceMappingURL=abstract-stream.js.map","import { setMaxListeners } from '@libp2p/interface';\nimport { anySignal } from 'any-signal';\nimport { MovingAverage } from './moving-average.js';\nexport const DEFAULT_TIMEOUT_MULTIPLIER = 1.2;\nexport const DEFAULT_FAILURE_MULTIPLIER = 2;\nexport const DEFAULT_MIN_TIMEOUT = 2000;\nexport class AdaptiveTimeout {\n    success;\n    failure;\n    next;\n    metric;\n    timeoutMultiplier;\n    failureMultiplier;\n    minTimeout;\n    constructor(init = {}) {\n        this.success = new MovingAverage(init.interval ?? 5000);\n        this.failure = new MovingAverage(init.interval ?? 5000);\n        this.next = new MovingAverage(init.interval ?? 5000);\n        this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;\n        this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;\n        this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;\n        if (init.metricName != null) {\n            this.metric = init.metrics?.registerMetricGroup(init.metricName);\n        }\n    }\n    getTimeoutSignal(options = {}) {\n        // calculate timeout for individual peers based on moving average of\n        // previous successful requests\n        const timeout = Math.max(Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier)), this.minTimeout);\n        const sendTimeout = AbortSignal.timeout(timeout);\n        const timeoutSignal = anySignal([options.signal, sendTimeout]);\n        setMaxListeners(Infinity, timeoutSignal, sendTimeout);\n        timeoutSignal.start = Date.now();\n        timeoutSignal.timeout = timeout;\n        return timeoutSignal;\n    }\n    cleanUp(signal) {\n        const time = Date.now() - signal.start;\n        if (signal.aborted) {\n            this.failure.push(time);\n            this.next.push(time * this.failureMultiplier);\n            this.metric?.update({\n                failureMovingAverage: this.failure.movingAverage,\n                failureDeviation: this.failure.deviation,\n                failureForecast: this.failure.forecast,\n                failureVariance: this.failure.variance,\n                failure: time\n            });\n        }\n        else {\n            this.success.push(time);\n            this.next.push(time);\n            this.metric?.update({\n                successMovingAverage: this.success.movingAverage,\n                successDeviation: this.success.deviation,\n                successForecast: this.success.forecast,\n                successVariance: this.success.variance,\n                success: time\n            });\n        }\n    }\n}\n//# sourceMappingURL=adaptive-timeout.js.map","/**\n * @packageDocumentation\n *\n * Provides strategies to sort a list of multiaddrs.\n *\n * @example\n *\n * ```typescript\n * import { publicAddressesFirst } from '@libp2p/utils/address-sort'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n *\n * const addresses = [\n *   multiaddr('/ip4/127.0.0.1/tcp/9000'),\n *   multiaddr('/ip4/82.41.53.1/tcp/9000')\n * ].sort(publicAddressesFirst)\n *\n * console.info(addresses)\n * // ['/ip4/82.41.53.1/tcp/9000', '/ip4/127.0.0.1/tcp/9000']\n * ```\n */\nimport { Circuit } from '@multiformats/multiaddr-matcher';\nimport { isPrivate } from './multiaddr/is-private.js';\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst(a, b) {\n    const isAPrivate = isPrivate(a.multiaddr);\n    const isBPrivate = isPrivate(b.multiaddr);\n    if (isAPrivate && !isBPrivate) {\n        return 1;\n    }\n    else if (!isAPrivate && isBPrivate) {\n        return -1;\n    }\n    return 0;\n}\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst(a, b) {\n    if (a.isCertified && !b.isCertified) {\n        return -1;\n    }\n    else if (!a.isCertified && b.isCertified) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * start of the array.\n */\nexport function circuitRelayAddressesLast(a, b) {\n    const isACircuit = Circuit.exactMatch(a.multiaddr);\n    const isBCircuit = Circuit.exactMatch(b.multiaddr);\n    if (isACircuit && !isBCircuit) {\n        return 1;\n    }\n    else if (!isACircuit && isBCircuit) {\n        return -1;\n    }\n    return 0;\n}\nexport function defaultAddressSort(a, b) {\n    const publicResult = publicAddressesFirst(a, b);\n    if (publicResult !== 0) {\n        return publicResult;\n    }\n    const relayResult = circuitRelayAddressesLast(a, b);\n    if (relayResult !== 0) {\n        return relayResult;\n    }\n    const certifiedResult = certifiedAddressesFirst(a, b);\n    return certifiedResult;\n}\n//# sourceMappingURL=address-sort.js.map","/**\n * @packageDocumentation\n *\n * Provides strategies ensure arrays are equivalent.\n *\n * @example\n *\n * ```typescript\n * import { arrayEquals } from '@libp2p/utils/array-equals'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),\n * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')\n *\n * console.info(arrayEquals([ma1], [ma1])) // true\n * console.info(arrayEquals([ma1], [ma2])) // false\n * ```\n */\n/**\n * Verify if two arrays of non primitive types with the \"equals\" function are equal.\n * Compatible with multiaddr, peer-id and others.\n */\nexport function arrayEquals(a, b) {\n    const sort = (a, b) => a.toString().localeCompare(b.toString());\n    if (a.length !== b.length) {\n        return false;\n    }\n    b.sort(sort);\n    return a.sort(sort).every((item, index) => b[index].equals(item));\n}\n//# sourceMappingURL=array-equals.js.map","import { getIterator } from 'get-iterator';\nimport { isPromise } from './is-promise.js';\nexport function closeSource(source, log) {\n    const res = getIterator(source).return?.();\n    if (isPromise(res)) {\n        res.catch(err => {\n            log.error('could not cause iterator to return', err);\n        });\n    }\n}\n//# sourceMappingURL=close-source.js.map","/**\n * Close the passed stream, falling back to aborting the stream if closing\n * cleanly fails.\n */\nexport async function safelyCloseStream(stream, options) {\n    try {\n        await stream?.close(options);\n    }\n    catch (err) {\n        stream?.abort(err);\n    }\n}\n/**\n * These are speculative protocols that are run automatically on connection open\n * so are usually not the reason the connection was opened.\n *\n * Consequently when requested it should be safe to close connections that only\n * have these protocol streams open.\n */\nconst DEFAULT_CLOSABLE_PROTOCOLS = [\n    // identify\n    '/ipfs/id/1.0.0',\n    // identify-push\n    '/ipfs/id/push/1.0.0',\n    // autonat\n    '/libp2p/autonat/1.0.0',\n    // dcutr\n    '/libp2p/dcutr'\n];\n/**\n * Close the passed connection if it has no streams, or only closable protocol\n * streams, falling back to aborting the connection if closing it cleanly fails.\n */\nexport async function safelyCloseConnectionIfUnused(connection, options) {\n    const streamProtocols = connection?.streams?.map(stream => stream.protocol) ?? [];\n    const closableProtocols = options?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;\n    // if the connection has protocols not in the closable protocols list, do not\n    // close the connection\n    if (streamProtocols.filter(proto => proto != null && !closableProtocols.includes(proto)).length > 0) {\n        return;\n    }\n    try {\n        await connection?.close(options);\n    }\n    catch (err) {\n        connection?.abort(err);\n    }\n}\n//# sourceMappingURL=close.js.map","import { Fingerprint } from './fingerprint.js';\nimport { getRandomInt } from './utils.js';\nexport class Bucket {\n    contents;\n    constructor(size) {\n        this.contents = new Array(size).fill(null);\n    }\n    has(fingerprint) {\n        if (!(fingerprint instanceof Fingerprint)) {\n            throw new TypeError('Invalid Fingerprint');\n        }\n        return this.contents.some((fp) => {\n            return fingerprint.equals(fp);\n        });\n    }\n    add(fingerprint) {\n        if (!(fingerprint instanceof Fingerprint)) {\n            throw new TypeError('Invalid Fingerprint');\n        }\n        for (let i = 0; i < this.contents.length; i++) {\n            if (this.contents[i] == null) {\n                this.contents[i] = fingerprint;\n                return true;\n            }\n        }\n        return true;\n    }\n    swap(fingerprint) {\n        if (!(fingerprint instanceof Fingerprint)) {\n            throw new TypeError('Invalid Fingerprint');\n        }\n        const i = getRandomInt(0, this.contents.length - 1);\n        const current = this.contents[i];\n        this.contents[i] = fingerprint;\n        return current;\n    }\n    remove(fingerprint) {\n        if (!(fingerprint instanceof Fingerprint)) {\n            throw new TypeError('Invalid Fingerprint');\n        }\n        const found = this.contents.findIndex((fp) => {\n            return fingerprint.equals(fp);\n        });\n        if (found > -1) {\n            this.contents[found] = null;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\n//# sourceMappingURL=bucket.js.map","import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { Bucket } from './bucket.js';\nimport { Fingerprint, MAX_FINGERPRINT_SIZE } from './fingerprint.js';\nimport { fnv1a } from './hashes.js';\nimport { getRandomInt } from './utils.js';\nconst maxCuckooCount = 500;\nexport class CuckooFilter {\n    bucketSize;\n    filterSize;\n    fingerprintSize;\n    buckets;\n    count;\n    hash;\n    seed;\n    constructor(init) {\n        this.filterSize = init.filterSize;\n        this.bucketSize = init.bucketSize ?? 4;\n        this.fingerprintSize = init.fingerprintSize ?? 2;\n        this.count = 0;\n        this.buckets = [];\n        this.hash = init.hash ?? fnv1a;\n        this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));\n    }\n    add(item) {\n        if (typeof item === 'string') {\n            item = uint8ArrayFromString(item);\n        }\n        const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);\n        const j = this.hash.hash(item, this.seed) % this.filterSize;\n        const k = (j ^ fingerprint.hash()) % this.filterSize;\n        if (this.buckets[j] == null) {\n            this.buckets[j] = new Bucket(this.bucketSize);\n        }\n        if (this.buckets[k] == null) {\n            this.buckets[k] = new Bucket(this.bucketSize);\n        }\n        if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {\n            this.count++;\n            return true;\n        }\n        const rand = [j, k];\n        let i = rand[getRandomInt(0, rand.length - 1)];\n        if (this.buckets[i] == null) {\n            this.buckets[i] = new Bucket(this.bucketSize);\n        }\n        for (let n = 0; n < maxCuckooCount; n++) {\n            const swapped = this.buckets[i].swap(fingerprint);\n            if (swapped == null) {\n                continue;\n            }\n            i = (i ^ swapped.hash()) % this.filterSize;\n            if (this.buckets[i] == null) {\n                this.buckets[i] = new Bucket(this.bucketSize);\n            }\n            if (this.buckets[i].add(swapped)) {\n                this.count++;\n                return true;\n            }\n            else {\n                continue;\n            }\n        }\n        return false;\n    }\n    has(item) {\n        if (typeof item === 'string') {\n            item = uint8ArrayFromString(item);\n        }\n        const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);\n        const j = this.hash.hash(item, this.seed) % this.filterSize;\n        const inJ = this.buckets[j]?.has(fingerprint) ?? false;\n        if (inJ) {\n            return inJ;\n        }\n        const k = (j ^ fingerprint.hash()) % this.filterSize;\n        return this.buckets[k]?.has(fingerprint) ?? false;\n    }\n    remove(item) {\n        if (typeof item === 'string') {\n            item = uint8ArrayFromString(item);\n        }\n        const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);\n        const j = this.hash.hash(item, this.seed) % this.filterSize;\n        const inJ = this.buckets[j]?.remove(fingerprint) ?? false;\n        if (inJ) {\n            this.count--;\n            return inJ;\n        }\n        const k = (j ^ fingerprint.hash()) % this.filterSize;\n        const inK = this.buckets[k]?.remove(fingerprint) ?? false;\n        if (inK) {\n            this.count--;\n        }\n        return inK;\n    }\n    get reliable() {\n        return Math.floor(100 * (this.count / this.filterSize)) <= 90;\n    }\n}\n// max load constants, defined in the cuckoo paper\nconst MAX_LOAD = {\n    1: 0.5,\n    2: 0.84,\n    4: 0.95,\n    8: 0.98\n};\nfunction calculateBucketSize(errorRate = 0.001) {\n    if (errorRate > 0.002) {\n        return 2;\n    }\n    if (errorRate > 0.00001) {\n        return 4;\n    }\n    return 8;\n}\nexport function optimize(maxItems, errorRate = 0.001) {\n    // https://www.eecs.harvard.edu/~michaelm/postscripts/cuckoo-conext2014.pdf\n    // Section 5.1 Optimal Bucket Size\n    const bucketSize = calculateBucketSize(errorRate);\n    const load = MAX_LOAD[bucketSize];\n    // https://stackoverflow.com/questions/57555236/how-to-size-a-cuckoo-filter/57617208#57617208\n    const filterSize = Math.round(maxItems / load);\n    const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);\n    return {\n        filterSize,\n        bucketSize,\n        fingerprintSize\n    };\n}\nexport function createCuckooFilter(maxItems, errorRate = 0.005) {\n    const opts = optimize(maxItems, errorRate);\n    return new CuckooFilter(opts);\n}\n//# sourceMappingURL=cuckoo-filter.js.map","import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nexport const MAX_FINGERPRINT_SIZE = 64;\nexport class Fingerprint {\n    fp;\n    h;\n    seed;\n    constructor(buf, hash, seed, fingerprintSize = 2) {\n        if (fingerprintSize > MAX_FINGERPRINT_SIZE) {\n            throw new TypeError('Invalid Fingerprint Size');\n        }\n        const fnv = hash.hashV(buf, seed);\n        const fp = uint8ArrayAlloc(fingerprintSize);\n        for (let i = 0; i < fp.length; i++) {\n            fp[i] = fnv[i];\n        }\n        if (fp.length === 0) {\n            fp[0] = 7;\n        }\n        this.fp = fp;\n        this.h = hash;\n        this.seed = seed;\n    }\n    hash() {\n        return this.h.hash(this.fp, this.seed);\n    }\n    equals(other) {\n        if (!(other?.fp instanceof Uint8Array)) {\n            return false;\n        }\n        return uint8ArrayEquals(this.fp, other.fp);\n    }\n}\n//# sourceMappingURL=fingerprint.js.map","import fnv1aHash from '@sindresorhus/fnv1a';\nimport mur from 'murmurhash3js-revisited';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nexport const murmur3 = {\n    hash: (input, seed) => {\n        return mur.x86.hash32(input, seed);\n    },\n    hashV: (input, seed) => {\n        return numberToBuffer(murmur3.hash(input, seed));\n    }\n};\nexport const fnv1a = {\n    hash: (input) => {\n        return Number(fnv1aHash(input, {\n            size: 32\n        }));\n    },\n    hashV: (input, seed) => {\n        return numberToBuffer(fnv1a.hash(input, seed));\n    }\n};\nexport function numberToBuffer(num) {\n    let hex = num.toString(16);\n    if (hex.length % 2 === 1) {\n        hex = `0${hex}`;\n    }\n    return uint8ArrayFromString(hex, 'base16');\n}\n//# sourceMappingURL=hashes.js.map","import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { CuckooFilter, optimize } from './cuckoo-filter.js';\nimport { fnv1a } from './hashes.js';\nimport { getRandomInt } from './utils.js';\nexport class ScalableCuckooFilter {\n    filterSize;\n    bucketSize;\n    fingerprintSize;\n    scale;\n    filterSeries;\n    hash;\n    seed;\n    constructor(init) {\n        this.bucketSize = init.bucketSize ?? 4;\n        this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;\n        this.fingerprintSize = init.fingerprintSize ?? 2;\n        this.scale = init.scale ?? 2;\n        this.hash = init.hash ?? fnv1a;\n        this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));\n        this.filterSeries = [\n            new CuckooFilter({\n                filterSize: this.filterSize,\n                bucketSize: this.bucketSize,\n                fingerprintSize: this.fingerprintSize,\n                hash: this.hash,\n                seed: this.seed\n            })\n        ];\n    }\n    add(item) {\n        if (typeof item === 'string') {\n            item = uint8ArrayFromString(item);\n        }\n        if (this.has(item)) {\n            return true;\n        }\n        let current = this.filterSeries.find((cuckoo) => {\n            return cuckoo.reliable;\n        });\n        if (current == null) {\n            const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);\n            current = new CuckooFilter({\n                filterSize: curSize,\n                bucketSize: this.bucketSize,\n                fingerprintSize: this.fingerprintSize,\n                hash: this.hash,\n                seed: this.seed\n            });\n            this.filterSeries.push(current);\n        }\n        return current.add(item);\n    }\n    has(item) {\n        if (typeof item === 'string') {\n            item = uint8ArrayFromString(item);\n        }\n        for (let i = 0; i < this.filterSeries.length; i++) {\n            if (this.filterSeries[i].has(item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    remove(item) {\n        if (typeof item === 'string') {\n            item = uint8ArrayFromString(item);\n        }\n        for (let i = 0; i < this.filterSeries.length; i++) {\n            if (this.filterSeries[i].remove(item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    get count() {\n        return this.filterSeries.reduce((acc, curr) => {\n            return acc + curr.count;\n        }, 0);\n    }\n}\nexport function createScalableCuckooFilter(maxItems, errorRate = 0.001, options) {\n    return new ScalableCuckooFilter({\n        ...optimize(maxItems, errorRate),\n        ...(options ?? {})\n    });\n}\n//# sourceMappingURL=scalable-cuckoo-filter.js.map","export function getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n//# sourceMappingURL=utils.js.map","export function isPromise(thing) {\n    if (thing == null) {\n        return false;\n    }\n    return typeof thing.then === 'function' &&\n        typeof thing.catch === 'function' &&\n        typeof thing.finally === 'function';\n}\n//# sourceMappingURL=is-promise.js.map","/**\n * Implements exponential moving average. Ported from `moving-average`.\n *\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n * @see https://www.npmjs.com/package/moving-average\n */\nexport class MovingAverage {\n    movingAverage;\n    variance;\n    deviation;\n    forecast;\n    timespan;\n    previousTime;\n    constructor(timespan) {\n        this.timespan = timespan;\n        this.movingAverage = 0;\n        this.variance = 0;\n        this.deviation = 0;\n        this.forecast = 0;\n    }\n    alpha(t, pt) {\n        return 1 - (Math.exp(-(t - pt) / this.timespan));\n    }\n    push(value, time = Date.now()) {\n        if (this.previousTime != null) {\n            // calculate moving average\n            const a = this.alpha(time, this.previousTime);\n            const diff = value - this.movingAverage;\n            const incr = a * diff;\n            this.movingAverage = a * value + (1 - a) * this.movingAverage;\n            // calculate variance & deviation\n            this.variance = (1 - a) * (this.variance + diff * incr);\n            this.deviation = Math.sqrt(this.variance);\n            // calculate forecast\n            this.forecast = this.movingAverage + a * diff;\n        }\n        else {\n            this.movingAverage = value;\n        }\n        this.previousTime = time;\n    }\n}\n//# sourceMappingURL=moving-average.js.map","import { isPrivateIp } from '../private-ip.js';\n/**\n * Check if a given multiaddr has a private address.\n */\nexport function isPrivate(ma) {\n    try {\n        const { address } = ma.nodeAddress();\n        return Boolean(isPrivateIp(address));\n    }\n    catch {\n        return true;\n    }\n}\n//# sourceMappingURL=is-private.js.map","import { Queue } from './queue/index.js';\n/**\n * Extends Queue to add support for querying queued jobs by peer id\n */\nexport class PeerQueue extends Queue {\n    has(peerId) {\n        return this.find(peerId) != null;\n    }\n    find(peerId) {\n        return this.queue.find(job => {\n            return peerId.equals(job.options.peerId);\n        });\n    }\n}\n//# sourceMappingURL=peer-queue.js.map","import { Queue } from './queue/index.js';\nexport class PriorityQueue extends Queue {\n    constructor(init = {}) {\n        super({\n            ...init,\n            sort: (a, b) => {\n                if (a.options.priority > b.options.priority) {\n                    return -1;\n                }\n                if (a.options.priority < b.options.priority) {\n                    return 1;\n                }\n                return 0;\n            }\n        });\n    }\n}\n//# sourceMappingURL=priority-queue.js.map","import { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport { Netmask } from 'netmask';\nconst PRIVATE_IP_RANGES = [\n    '0.0.0.0/8',\n    '10.0.0.0/8',\n    '100.64.0.0/10',\n    '127.0.0.0/8',\n    '169.254.0.0/16',\n    '172.16.0.0/12',\n    '192.0.0.0/24',\n    '192.0.0.0/29',\n    '192.0.0.8/32',\n    '192.0.0.9/32',\n    '192.0.0.10/32',\n    '192.0.0.170/32',\n    '192.0.0.171/32',\n    '192.0.2.0/24',\n    '192.31.196.0/24',\n    '192.52.193.0/24',\n    '192.88.99.0/24',\n    '192.168.0.0/16',\n    '192.175.48.0/24',\n    '198.18.0.0/15',\n    '198.51.100.0/24',\n    '203.0.113.0/24',\n    '240.0.0.0/4',\n    '255.255.255.255/32'\n];\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ipRange => new Netmask(ipRange));\nfunction ipv4Check(ipAddr) {\n    for (const r of NETMASK_RANGES) {\n        if (r.contains(ipAddr))\n            return true;\n    }\n    return false;\n}\nfunction isIpv4MappedIpv6(ipAddr) {\n    return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n */\nfunction ipv4MappedIpv6Check(ipAddr) {\n    const parts = ipAddr.split(':');\n    if (parts.length < 2) {\n        return false;\n    }\n    const octet34 = parts[parts.length - 1].padStart(4, '0');\n    const octet12 = parts[parts.length - 2].padStart(4, '0');\n    const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;\n    return ipv4Check(ip4);\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.2 example 3\n */\nfunction isIpv4EmbeddedIpv6(ipAddr) {\n    return /^::ffff:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr);\n}\nfunction ipv4EmbeddedIpv6Check(ipAddr) {\n    const parts = ipAddr.split(':');\n    const ip4 = parts[parts.length - 1];\n    return ipv4Check(ip4);\n}\nfunction ipv6Check(ipAddr) {\n    return /^::$/.test(ipAddr) ||\n        /^::1$/.test(ipAddr) ||\n        /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr) ||\n        /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n        /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n        /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n        /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n        /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n        /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) ||\n        /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) ||\n        /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);\n}\nexport function isPrivateIp(ip) {\n    if (isIPv4(ip))\n        return ipv4Check(ip);\n    else if (isIpv4MappedIpv6(ip))\n        return ipv4MappedIpv6Check(ip);\n    else if (isIpv4EmbeddedIpv6(ip))\n        return ipv4EmbeddedIpv6Check(ip);\n    else if (isIPv6(ip))\n        return ipv6Check(ip);\n    else\n        return undefined;\n}\n//# sourceMappingURL=private-ip.js.map","import { AbortError, CodeError, TypedEventEmitter } from '@libp2p/interface';\nimport { pushable } from 'it-pushable';\nimport { raceEvent } from 'race-event';\nimport { Job } from './job.js';\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n */\nexport class Queue extends TypedEventEmitter {\n    concurrency;\n    queue;\n    pending;\n    sort;\n    constructor(init = {}) {\n        super();\n        this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;\n        this.pending = 0;\n        if (init.metricName != null) {\n            init.metrics?.registerMetricGroup(init.metricName, {\n                calculate: () => {\n                    return {\n                        size: this.queue.length,\n                        running: this.pending,\n                        queued: this.queue.length - this.pending\n                    };\n                }\n            });\n        }\n        this.sort = init.sort;\n        this.queue = [];\n    }\n    tryToStartAnother() {\n        if (this.size === 0) {\n            // do this in the microtask queue so all job recipients receive the\n            // result before the \"empty\" event fires\n            queueMicrotask(() => {\n                this.safeDispatchEvent('empty');\n            });\n            if (this.running === 0) {\n                // do this in the microtask queue so all job recipients receive the\n                // result before the \"idle\" event fires\n                queueMicrotask(() => {\n                    this.safeDispatchEvent('idle');\n                });\n            }\n            return false;\n        }\n        if (this.pending < this.concurrency) {\n            let job;\n            for (const j of this.queue) {\n                if (j.status === 'queued') {\n                    job = j;\n                    break;\n                }\n            }\n            if (job == null) {\n                return false;\n            }\n            this.safeDispatchEvent('active');\n            this.pending++;\n            void job.run()\n                .finally(() => {\n                // remove the job from the queue\n                for (let i = 0; i < this.queue.length; i++) {\n                    if (this.queue[i] === job) {\n                        this.queue.splice(i, 1);\n                        break;\n                    }\n                }\n                this.pending--;\n                this.tryToStartAnother();\n                this.safeDispatchEvent('next');\n            });\n            return true;\n        }\n        return false;\n    }\n    enqueue(job) {\n        this.queue.push(job);\n        if (this.sort != null) {\n            this.queue.sort(this.sort);\n        }\n    }\n    /**\n     * Adds a sync or async task to the queue. Always returns a promise.\n     */\n    async add(fn, options) {\n        options?.signal?.throwIfAborted();\n        const job = new Job(fn, options);\n        this.enqueue(job);\n        this.safeDispatchEvent('add');\n        this.tryToStartAnother();\n        return job.join(options)\n            .then(result => {\n            this.safeDispatchEvent('completed', { detail: result });\n            this.safeDispatchEvent('success', { detail: { job, result } });\n            return result;\n        })\n            .catch(err => {\n            if (job.status === 'queued') {\n                // job was aborted before it started - remove the job from the queue\n                for (let i = 0; i < this.queue.length; i++) {\n                    if (this.queue[i] === job) {\n                        this.queue.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n            this.safeDispatchEvent('error', { detail: err });\n            this.safeDispatchEvent('failure', { detail: { job, error: err } });\n            throw err;\n        });\n    }\n    /**\n     * Clear the queue\n     */\n    clear() {\n        this.queue.splice(0, this.queue.length);\n    }\n    /**\n     * Abort all jobs in the queue and clear it\n     */\n    abort() {\n        this.queue.forEach(job => {\n            job.abort(new AbortError());\n        });\n        this.clear();\n    }\n    /**\n     * Can be called multiple times. Useful if you for example add additional items at a later time.\n     *\n     * @returns A promise that settles when the queue becomes empty.\n     */\n    async onEmpty(options) {\n        // Instantly resolve if the queue is empty\n        if (this.size === 0) {\n            return;\n        }\n        await raceEvent(this, 'empty', options?.signal);\n    }\n    /**\n     * @returns A promise that settles when the queue size is less than the given\n     * limit: `queue.size < limit`.\n     *\n     * If you want to avoid having the queue grow beyond a certain size you can\n     * `await queue.onSizeLessThan()` before adding a new item.\n     *\n     * Note that this only limits the number of items waiting to start. There\n     * could still be up to `concurrency` jobs already running that this call does\n     * not include in its calculation.\n     */\n    async onSizeLessThan(limit, options) {\n        // Instantly resolve if the queue is empty.\n        if (this.size < limit) {\n            return;\n        }\n        await raceEvent(this, 'next', options?.signal, {\n            filter: () => this.size < limit\n        });\n    }\n    /**\n     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n     * from the queue has finished. `.onEmpty` merely signals that the queue is\n     * empty, but it could mean that some promises haven't completed yet.\n     *\n     * @returns A promise that settles when the queue becomes empty, and all\n     * promises have completed; `queue.size === 0 && queue.pending === 0`.\n     */\n    async onIdle(options) {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.pending === 0 && this.size === 0) {\n            return;\n        }\n        await raceEvent(this, 'idle', options?.signal);\n    }\n    /**\n     * Size of the queue including running items\n     */\n    get size() {\n        return this.queue.length;\n    }\n    /**\n     * The number of queued items waiting to run.\n     */\n    get queued() {\n        return this.queue.length - this.pending;\n    }\n    /**\n     * The number of items currently running.\n     */\n    get running() {\n        return this.pending;\n    }\n    /**\n     * Returns an async generator that makes it easy to iterate over the results\n     * of jobs added to the queue.\n     *\n     * The generator will end when the queue becomes idle, that is there are no\n     * jobs running and no jobs that have yet to run.\n     *\n     * If you need to keep the queue open indefinitely, consider using it-pushable\n     * instead.\n     */\n    async *toGenerator(options) {\n        options?.signal?.throwIfAborted();\n        const stream = pushable({\n            objectMode: true\n        });\n        const cleanup = (err) => {\n            if (err != null) {\n                this.abort();\n            }\n            else {\n                this.clear();\n            }\n            stream.end(err);\n        };\n        const onQueueJobComplete = (evt) => {\n            if (evt.detail != null) {\n                stream.push(evt.detail);\n            }\n        };\n        const onQueueError = (evt) => {\n            cleanup(evt.detail);\n        };\n        const onQueueIdle = () => {\n            cleanup();\n        };\n        // clear the queue and throw if the query is aborted\n        const onSignalAbort = () => {\n            cleanup(new CodeError('Queue aborted', 'ERR_QUEUE_ABORTED'));\n        };\n        // add listeners\n        this.addEventListener('completed', onQueueJobComplete);\n        this.addEventListener('error', onQueueError);\n        this.addEventListener('idle', onQueueIdle);\n        options?.signal?.addEventListener('abort', onSignalAbort);\n        try {\n            yield* stream;\n        }\n        finally {\n            // remove listeners\n            this.removeEventListener('completed', onQueueJobComplete);\n            this.removeEventListener('error', onQueueError);\n            this.removeEventListener('idle', onQueueIdle);\n            options?.signal?.removeEventListener('abort', onSignalAbort);\n            // empty the queue for when the user has broken out of a loop early\n            cleanup();\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import { AbortError, setMaxListeners } from '@libp2p/interface';\nimport { raceSignal } from 'race-signal';\nimport { JobRecipient } from './recipient.js';\n/**\n * Returns a random string\n */\nfunction randomId() {\n    return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`;\n}\nexport class Job {\n    id;\n    fn;\n    options;\n    recipients;\n    status;\n    timeline;\n    controller;\n    constructor(fn, options) {\n        this.id = randomId();\n        this.status = 'queued';\n        this.fn = fn;\n        this.options = options;\n        this.recipients = [];\n        this.timeline = {\n            created: Date.now()\n        };\n        this.controller = new AbortController();\n        setMaxListeners(Infinity, this.controller.signal);\n        this.onAbort = this.onAbort.bind(this);\n    }\n    abort(err) {\n        this.controller.abort(err);\n    }\n    onAbort() {\n        const allAborted = this.recipients.reduce((acc, curr) => {\n            return acc && (curr.signal?.aborted === true);\n        }, true);\n        // if all recipients have aborted the job, actually abort the job\n        if (allAborted) {\n            this.controller.abort(new AbortError());\n            this.cleanup();\n        }\n    }\n    async join(options = {}) {\n        const recipient = new JobRecipient(options.signal);\n        this.recipients.push(recipient);\n        options.signal?.addEventListener('abort', this.onAbort);\n        return recipient.deferred.promise;\n    }\n    async run() {\n        this.status = 'running';\n        this.timeline.started = Date.now();\n        try {\n            this.controller.signal.throwIfAborted();\n            const result = await raceSignal(this.fn({\n                ...(this.options ?? {}),\n                signal: this.controller.signal\n            }), this.controller.signal);\n            this.recipients.forEach(recipient => {\n                recipient.deferred.resolve(result);\n            });\n            this.status = 'complete';\n        }\n        catch (err) {\n            this.recipients.forEach(recipient => {\n                recipient.deferred.reject(err);\n            });\n            this.status = 'errored';\n        }\n        finally {\n            this.timeline.finished = Date.now();\n            this.cleanup();\n        }\n    }\n    cleanup() {\n        this.recipients.forEach(recipient => {\n            recipient.cleanup();\n            recipient.signal?.removeEventListener('abort', this.onAbort);\n        });\n    }\n}\n//# sourceMappingURL=job.js.map","import { AbortError } from '@libp2p/interface';\nimport pDefer from 'p-defer';\nexport class JobRecipient {\n    deferred;\n    signal;\n    constructor(signal) {\n        this.signal = signal;\n        this.deferred = pDefer();\n        this.onAbort = this.onAbort.bind(this);\n        this.signal?.addEventListener('abort', this.onAbort);\n    }\n    onAbort() {\n        this.deferred.reject(this.signal?.reason ?? new AbortError());\n    }\n    cleanup() {\n        this.signal?.removeEventListener('abort', this.onAbort);\n    }\n}\n//# sourceMappingURL=recipient.js.map","import { CodeError } from '@libp2p/interface';\nimport delay from 'delay';\nexport class RateLimiter {\n    memoryStorage;\n    points;\n    duration;\n    blockDuration;\n    execEvenly;\n    execEvenlyMinDelayMs;\n    keyPrefix;\n    constructor(opts = {}) {\n        this.points = opts.points ?? 4;\n        this.duration = opts.duration ?? 1;\n        this.blockDuration = opts.blockDuration ?? 0;\n        this.execEvenly = opts.execEvenly ?? false;\n        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? (this.duration * 1000 / this.points);\n        this.keyPrefix = opts.keyPrefix ?? 'rlflx';\n        this.memoryStorage = new MemoryStorage();\n    }\n    async consume(key, pointsToConsume = 1, options = {}) {\n        const rlKey = this.getKey(key);\n        const secDuration = this._getKeySecDuration(options);\n        let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n        if (res.consumedPoints > this.points) {\n            // Block only first time when consumed more than points\n            if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n                // Block key\n                res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n            }\n            throw new CodeError('Rate limit exceeded', 'ERR_RATE_LIMIT_EXCEEDED', res);\n        }\n        else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n            // Execute evenly\n            let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n            if (delayMs < this.execEvenlyMinDelayMs) {\n                delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;\n            }\n            await delay(delayMs);\n        }\n        return res;\n    }\n    penalty(key, points = 1, options = {}) {\n        const rlKey = this.getKey(key);\n        const secDuration = this._getKeySecDuration(options);\n        const res = this.memoryStorage.incrby(rlKey, points, secDuration);\n        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n        return res;\n    }\n    reward(key, points = 1, options = {}) {\n        const rlKey = this.getKey(key);\n        const secDuration = this._getKeySecDuration(options);\n        const res = this.memoryStorage.incrby(rlKey, -points, secDuration);\n        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n        return res;\n    }\n    /**\n     * Block any key for secDuration seconds\n     *\n     * @param key\n     * @param secDuration\n     */\n    block(key, secDuration) {\n        const msDuration = secDuration * 1000;\n        const initPoints = this.points + 1;\n        this.memoryStorage.set(this.getKey(key), initPoints, secDuration);\n        return {\n            remainingPoints: 0,\n            msBeforeNext: msDuration === 0 ? -1 : msDuration,\n            consumedPoints: initPoints,\n            isFirstInDuration: false\n        };\n    }\n    set(key, points, secDuration = 0) {\n        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n        this.memoryStorage.set(this.getKey(key), points, secDuration);\n        return {\n            remainingPoints: 0,\n            msBeforeNext: msDuration === 0 ? -1 : msDuration,\n            consumedPoints: points,\n            isFirstInDuration: false\n        };\n    }\n    get(key) {\n        const res = this.memoryStorage.get(this.getKey(key));\n        if (res != null) {\n            res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n        }\n        return res;\n    }\n    delete(key) {\n        this.memoryStorage.delete(this.getKey(key));\n    }\n    _getKeySecDuration(options) {\n        if (options?.customDuration != null && options.customDuration >= 0) {\n            return options.customDuration;\n        }\n        return this.duration;\n    }\n    getKey(key) {\n        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;\n    }\n    parseKey(rlKey) {\n        return rlKey.substring(this.keyPrefix.length);\n    }\n}\nclass MemoryStorage {\n    storage;\n    constructor() {\n        this.storage = new Map();\n    }\n    incrby(key, value, durationSec) {\n        const existing = this.storage.get(key);\n        if (existing != null) {\n            const msBeforeExpires = existing.expiresAt != null\n                ? existing.expiresAt.getTime() - new Date().getTime()\n                : -1;\n            if (existing.expiresAt == null || msBeforeExpires > 0) {\n                // Change value\n                existing.value += value;\n                return {\n                    remainingPoints: 0,\n                    msBeforeNext: msBeforeExpires,\n                    consumedPoints: existing.value,\n                    isFirstInDuration: false\n                };\n            }\n            return this.set(key, value, durationSec);\n        }\n        return this.set(key, value, durationSec);\n    }\n    set(key, value, durationSec) {\n        const durationMs = durationSec * 1000;\n        const existing = this.storage.get(key);\n        if (existing != null) {\n            clearTimeout(existing.timeoutId);\n        }\n        const record = {\n            value,\n            expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : undefined\n        };\n        this.storage.set(key, record);\n        if (durationMs > 0) {\n            record.timeoutId = setTimeout(() => {\n                this.storage.delete(key);\n            }, durationMs);\n            if (record.timeoutId.unref != null) {\n                record.timeoutId.unref();\n            }\n        }\n        return {\n            remainingPoints: 0,\n            msBeforeNext: durationMs === 0 ? -1 : durationMs,\n            consumedPoints: record.value,\n            isFirstInDuration: true\n        };\n    }\n    get(key) {\n        const existing = this.storage.get(key);\n        if (existing != null) {\n            const msBeforeExpires = existing.expiresAt != null\n                ? existing.expiresAt.getTime() - new Date().getTime()\n                : -1;\n            return {\n                remainingPoints: 0,\n                msBeforeNext: msBeforeExpires,\n                consumedPoints: existing.value,\n                isFirstInDuration: false\n            };\n        }\n    }\n    delete(key) {\n        const record = this.storage.get(key);\n        if (record != null) {\n            if (record.timeoutId != null) {\n                clearTimeout(record.timeoutId);\n            }\n            this.storage.delete(key);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=rate-limiter.js.map","class TrackedMap extends Map {\n    metric;\n    constructor(init) {\n        super();\n        const { name, metrics } = init;\n        this.metric = metrics.registerMetric(name);\n        this.updateComponentMetric();\n    }\n    set(key, value) {\n        super.set(key, value);\n        this.updateComponentMetric();\n        return this;\n    }\n    delete(key) {\n        const deleted = super.delete(key);\n        this.updateComponentMetric();\n        return deleted;\n    }\n    clear() {\n        super.clear();\n        this.updateComponentMetric();\n    }\n    updateComponentMetric() {\n        this.metric.update(this.size);\n    }\n}\nexport function trackedMap(config) {\n    const { name, metrics } = config;\n    let map;\n    if (metrics != null) {\n        map = new TrackedMap({ name, metrics });\n    }\n    else {\n        map = new Map();\n    }\n    return map;\n}\n//# sourceMappingURL=tracked-map.js.map","// p2p multi-address code\nexport const CODE_P2P = 421;\nexport const CODE_CIRCUIT = 290;\nexport const CODE_TCP = 6;\nexport const CODE_WS = 477;\nexport const CODE_WSS = 478;\n// Time to wait for a connection to close gracefully before destroying it manually\nexport const CLOSE_TIMEOUT = 500;\n//# sourceMappingURL=constants.js.map","import * as mafmt from '@multiformats/mafmt';\nimport { CODE_CIRCUIT, CODE_P2P, CODE_TCP, CODE_WS, CODE_WSS } from './constants.js';\nexport function all(multiaddrs) {\n    return multiaddrs.filter((ma) => {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n            return false;\n        }\n        const testMa = ma.decapsulateCode(CODE_P2P);\n        return mafmt.WebSockets.matches(testMa) ||\n            mafmt.WebSocketsSecure.matches(testMa);\n    });\n}\nexport function wss(multiaddrs) {\n    return multiaddrs.filter((ma) => {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n            return false;\n        }\n        const testMa = ma.decapsulateCode(CODE_P2P);\n        return mafmt.WebSocketsSecure.matches(testMa);\n    });\n}\nexport function dnsWss(multiaddrs) {\n    return multiaddrs.filter((ma) => {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n            return false;\n        }\n        const testMa = ma.decapsulateCode(CODE_P2P);\n        return mafmt.WebSocketsSecure.matches(testMa) &&\n            mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));\n    });\n}\nexport function dnsWsOrWss(multiaddrs) {\n    return multiaddrs.filter((ma) => {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n            return false;\n        }\n        const testMa = ma.decapsulateCode(CODE_P2P);\n        // WS\n        if (mafmt.WebSockets.matches(testMa)) {\n            return mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS));\n        }\n        // WSS\n        return mafmt.WebSocketsSecure.matches(testMa) &&\n            mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));\n    });\n}\n//# sourceMappingURL=filters.js.map","/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API).\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webSockets } from '@libp2p/websockets'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets()\n *   ]\n * //... other config\n * })\n * await node.start()\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/9090/ws')\n * await node.dial(ma)\n * ```\n *\n * ## Filters\n *\n * When run in a browser by default this module will only connect to secure web socket addresses.\n *\n * To change this you should pass a filter to the factory function.\n *\n * You can create your own address filters for this transports, or rely in the filters [provided](./src/filters.js).\n *\n * The available filters are:\n *\n * - `filters.all`\n *   - Returns all TCP and DNS based addresses, both with `ws` or `wss`.\n * - `filters.dnsWss`\n *   - Returns all DNS based addresses with `wss`.\n * - `filters.dnsWsOrWss`\n *   - Returns all DNS based addresses, both with `ws` or `wss`.\n *\n * @example Allow dialing insecure WebSockets\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webSockets } from '@libp2p/websockets'\n * import * as filters from '@libp2p/websockets/filters'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets({\n *       // connect to all sockets, even insecure ones\n *       filter: filters.all\n *     })\n *   ]\n * })\n * ```\n */\nimport { CodeError, transportSymbol, serviceCapabilities } from '@libp2p/interface';\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri';\nimport { connect } from 'it-ws/client';\nimport pDefer from 'p-defer';\nimport { CustomProgressEvent } from 'progress-events';\nimport { raceSignal } from 'race-signal';\nimport { isBrowser, isWebWorker } from 'wherearewe';\nimport * as filters from './filters.js';\nimport { createListener } from './listener.js';\nimport { socketToMaConn } from './socket-to-conn.js';\nclass WebSockets {\n    log;\n    init;\n    logger;\n    metrics;\n    components;\n    constructor(components, init) {\n        this.log = components.logger.forComponent('libp2p:websockets');\n        this.logger = components.logger;\n        this.components = components;\n        this.init = init;\n        if (components.metrics != null) {\n            this.metrics = {\n                dialerEvents: components.metrics.registerCounterGroup('libp2p_websockets_dialer_events_total', {\n                    label: 'event',\n                    help: 'Total count of WebSockets dialer events by type'\n                })\n            };\n        }\n    }\n    [transportSymbol] = true;\n    [Symbol.toStringTag] = '@libp2p/websockets';\n    [serviceCapabilities] = [\n        '@libp2p/transport'\n    ];\n    async dial(ma, options) {\n        this.log('dialing %s', ma);\n        options = options ?? {};\n        const socket = await this._connect(ma, options);\n        const maConn = socketToMaConn(socket, ma, {\n            logger: this.logger,\n            metrics: this.metrics?.dialerEvents\n        });\n        this.log('new outbound connection %s', maConn.remoteAddr);\n        const conn = await options.upgrader.upgradeOutbound(maConn, options);\n        this.log('outbound connection %s upgraded', maConn.remoteAddr);\n        return conn;\n    }\n    async _connect(ma, options) {\n        options?.signal?.throwIfAborted();\n        const cOpts = ma.toOptions();\n        this.log('dialing %s:%s', cOpts.host, cOpts.port);\n        const errorPromise = pDefer();\n        const rawSocket = connect(toUri(ma), this.init);\n        rawSocket.socket.addEventListener('error', () => {\n            // the WebSocket.ErrorEvent type doesn't actually give us any useful\n            // information about what happened\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/error_event\n            const err = new CodeError(`Could not connect to ${ma.toString()}`, 'ERR_CONNECTION_FAILED');\n            this.log.error('connection error:', err);\n            this.metrics?.dialerEvents.increment({ error: true });\n            errorPromise.reject(err);\n        });\n        try {\n            options.onProgress?.(new CustomProgressEvent('websockets:open-connection'));\n            await raceSignal(Promise.race([rawSocket.connected(), errorPromise.promise]), options.signal);\n        }\n        catch (err) {\n            if (options.signal?.aborted === true) {\n                this.metrics?.dialerEvents.increment({ abort: true });\n            }\n            rawSocket.close()\n                .catch(err => {\n                this.log.error('error closing raw socket', err);\n            });\n            throw err;\n        }\n        this.log('connected %s', ma);\n        this.metrics?.dialerEvents.increment({ connect: true });\n        return rawSocket;\n    }\n    /**\n     * Creates a Websockets listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`\n     */\n    createListener(options) {\n        return createListener({\n            logger: this.logger,\n            metrics: this.components.metrics\n        }, {\n            ...this.init,\n            ...options\n        });\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n     * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n     * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n     */\n    listenFilter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        if (this.init?.filter != null) {\n            return this.init?.filter(multiaddrs);\n        }\n        // Browser\n        if (isBrowser || isWebWorker) {\n            return filters.wss(multiaddrs);\n        }\n        return filters.all(multiaddrs);\n    }\n    /**\n     * Filter check for all Multiaddrs that this transport can dial\n     */\n    dialFilter(multiaddrs) {\n        return this.listenFilter(multiaddrs);\n    }\n}\nexport function webSockets(init = {}) {\n    return (components) => {\n        return new WebSockets(components, init);\n    };\n}\n//# sourceMappingURL=index.js.map","export function createListener() {\n    throw new Error('WebSocket Servers can not be created in the browser!');\n}\n//# sourceMappingURL=listener.browser.js.map","import { CodeError } from '@libp2p/interface';\nimport { CLOSE_TIMEOUT } from './constants.js';\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn(stream, remoteAddr, options) {\n    const log = options.logger.forComponent('libp2p:websockets:maconn');\n    const metrics = options.metrics;\n    const metricPrefix = options.metricPrefix ?? '';\n    const maConn = {\n        log,\n        async sink(source) {\n            try {\n                await stream.sink((async function* () {\n                    for await (const buf of source) {\n                        if (buf instanceof Uint8Array) {\n                            yield buf;\n                        }\n                        else {\n                            yield buf.subarray();\n                        }\n                    }\n                })());\n            }\n            catch (err) {\n                if (err.type !== 'aborted') {\n                    log.error(err);\n                }\n            }\n        },\n        source: stream.source,\n        remoteAddr,\n        timeline: { open: Date.now() },\n        async close(options = {}) {\n            const start = Date.now();\n            if (options.signal == null) {\n                const signal = AbortSignal.timeout(CLOSE_TIMEOUT);\n                options = {\n                    ...options,\n                    signal\n                };\n            }\n            const listener = () => {\n                const { host, port } = maConn.remoteAddr.toOptions();\n                log('timeout closing stream to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n                this.abort(new CodeError('Socket close timeout', 'ERR_SOCKET_CLOSE_TIMEOUT'));\n            };\n            options.signal?.addEventListener('abort', listener);\n            try {\n                await stream.close();\n            }\n            catch (err) {\n                log.error('error closing WebSocket gracefully', err);\n                this.abort(err);\n            }\n            finally {\n                options.signal?.removeEventListener('abort', listener);\n                maConn.timeline.close = Date.now();\n            }\n        },\n        abort(err) {\n            const { host, port } = maConn.remoteAddr.toOptions();\n            log('timeout closing stream to %s:%s due to error', host, port, err);\n            stream.destroy();\n            maConn.timeline.close = Date.now();\n            // ws WebSocket.terminate does not accept an Error arg to emit an 'error'\n            // event on destroy like other node streams so we can't update a metric\n            // with an event listener\n            // https://github.com/websockets/ws/issues/1752#issuecomment-622380981\n            metrics?.increment({ [`${metricPrefix}error`]: true });\n        }\n    };\n    stream.socket.addEventListener('close', () => {\n        metrics?.increment({ [`${metricPrefix}close`]: true });\n        // In instances where `close` was not explicitly called,\n        // such as an iterable stream ending, ensure we have set the close\n        // timeline\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    }, { once: true });\n    return maConn;\n}\n//# sourceMappingURL=socket-to-conn.js.map","import { CustomProgressEvent } from 'progress-events';\nimport { defaultResolver } from './resolvers/default.js';\nimport { cache } from './utils/cache.js';\nimport { getTypes } from './utils/get-types.js';\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000;\nexport class DNS {\n    resolvers;\n    cache;\n    constructor(init) {\n        this.resolvers = {};\n        this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);\n        Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n            if (!Array.isArray(resolver)) {\n                resolver = [resolver];\n            }\n            // convert `com` -> `com.`\n            if (!tld.endsWith('.')) {\n                tld = `${tld}.`;\n            }\n            this.resolvers[tld] = resolver;\n        });\n        // configure default resolver if none specified\n        if (this.resolvers['.'] == null) {\n            this.resolvers['.'] = defaultResolver();\n        }\n    }\n    /**\n     * Queries DNS resolvers for the passed record types for the passed domain.\n     *\n     * If cached records exist for all desired types they will be returned\n     * instead.\n     *\n     * Any new responses will be added to the cache for subsequent requests.\n     */\n    async query(domain, options = {}) {\n        const types = getTypes(options.types);\n        const cached = options.cached !== false ? this.cache.get(domain, types) : undefined;\n        if (cached != null) {\n            options.onProgress?.(new CustomProgressEvent('dns:cache', { detail: cached }));\n            return cached;\n        }\n        const tld = `${domain.split('.').pop()}.`;\n        const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n            return (Math.random() > 0.5) ? -1 : 1;\n        });\n        const errors = [];\n        for (const resolver of resolvers) {\n            // skip further resolutions if the user aborted the signal\n            if (options.signal?.aborted === true) {\n                break;\n            }\n            try {\n                const result = await resolver(domain, {\n                    ...options,\n                    types\n                });\n                for (const answer of result.Answer) {\n                    this.cache.add(domain, answer);\n                }\n                return result;\n            }\n            catch (err) {\n                errors.push(err);\n                options.onProgress?.(new CustomProgressEvent('dns:error', { detail: err }));\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);\n    }\n}\n//# sourceMappingURL=dns.js.map","/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\nimport { DNS as DNSClass } from './dns.js';\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nexport var RecordType;\n(function (RecordType) {\n    RecordType[RecordType[\"A\"] = 1] = \"A\";\n    RecordType[RecordType[\"CNAME\"] = 5] = \"CNAME\";\n    RecordType[RecordType[\"TXT\"] = 16] = \"TXT\";\n    RecordType[RecordType[\"AAAA\"] = 28] = \"AAAA\";\n})(RecordType || (RecordType = {}));\n/**\n * The default maximum amount of recursion allowed during a query\n */\nexport const MAX_RECURSIVE_DEPTH = 32;\nexport function dns(init = {}) {\n    return new DNSClass(init);\n}\n//# sourceMappingURL=index.js.map","import { dnsJsonOverHttps } from './dns-json-over-https.js';\nexport function defaultResolver() {\n    return [\n        dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n        dnsJsonOverHttps('https://dns.google/resolve')\n    ];\n}\n//# sourceMappingURL=default.browser.js.map","/* eslint-env browser */\nimport PQueue from 'p-queue';\nimport { CustomProgressEvent } from 'progress-events';\nimport { RecordType } from '../index.js';\nimport { getTypes } from '../utils/get-types.js';\nimport { toDNSResponse } from '../utils/to-dns-response.js';\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nexport const DEFAULT_QUERY_CONCURRENCY = 4;\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nexport function dnsJsonOverHttps(url, init = {}) {\n    const httpQueue = new PQueue({\n        concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n    });\n    return async (fqdn, options = {}) => {\n        const searchParams = new URLSearchParams();\n        searchParams.set('name', fqdn);\n        getTypes(options.types).forEach(type => {\n            // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n            searchParams.append('type', RecordType[type]);\n        });\n        options.onProgress?.(new CustomProgressEvent('dns:query', { detail: fqdn }));\n        // query DNS-JSON over HTTPS server\n        const response = await httpQueue.add(async () => {\n            const res = await fetch(`${url}?${searchParams}`, {\n                headers: {\n                    accept: 'application/dns-json'\n                },\n                signal: options?.signal\n            });\n            if (res.status !== 200) {\n                throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);\n            }\n            const response = toDNSResponse(await res.json());\n            options.onProgress?.(new CustomProgressEvent('dns:response', { detail: response }));\n            return response;\n        }, {\n            signal: options.signal\n        });\n        if (response == null) {\n            throw new Error('No DNS response received');\n        }\n        return response;\n    };\n}\n//# sourceMappingURL=dns-json-over-https.js.map","import hashlru from 'hashlru';\nimport { RecordType } from '../index.js';\nimport { DEFAULT_TTL, toDNSResponse } from './to-dns-response.js';\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n    lru;\n    constructor(maxSize) {\n        this.lru = hashlru(maxSize);\n    }\n    get(fqdn, types) {\n        let foundAllAnswers = true;\n        const answers = [];\n        for (const type of types) {\n            const cached = this.getAnswers(fqdn, type);\n            if (cached.length === 0) {\n                foundAllAnswers = false;\n                break;\n            }\n            answers.push(...cached);\n        }\n        if (foundAllAnswers) {\n            return toDNSResponse({ answers });\n        }\n    }\n    getAnswers(domain, type) {\n        const key = `${domain.toLowerCase()}-${type}`;\n        const answers = this.lru.get(key);\n        if (answers != null) {\n            const cachedAnswers = answers\n                .filter((entry) => {\n                return entry.expires > Date.now();\n            })\n                .map(({ expires, value }) => ({\n                ...value,\n                TTL: Math.round((expires - Date.now()) / 1000),\n                type: RecordType[value.type]\n            }));\n            if (cachedAnswers.length === 0) {\n                this.lru.remove(key);\n            }\n            // @ts-expect-error hashlru stringifies stored types which turns enums\n            // into strings, we convert back into enums above but tsc doesn't know\n            return cachedAnswers;\n        }\n        return [];\n    }\n    add(domain, answer) {\n        const key = `${domain.toLowerCase()}-${answer.type}`;\n        const answers = this.lru.get(key) ?? [];\n        answers.push({\n            expires: Date.now() + ((answer.TTL ?? DEFAULT_TTL) * 1000),\n            value: answer\n        });\n        this.lru.set(key, answers);\n    }\n    remove(domain, type) {\n        const key = `${domain.toLowerCase()}-${type}`;\n        this.lru.remove(key);\n    }\n    clear() {\n        this.lru.clear();\n    }\n}\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nexport function cache(size) {\n    return new CachedAnswers(size);\n}\n//# sourceMappingURL=cache.js.map","import { RecordType } from '../index.js';\nexport function getTypes(types) {\n    const DEFAULT_TYPES = [\n        RecordType.A\n    ];\n    if (types == null) {\n        return DEFAULT_TYPES;\n    }\n    if (Array.isArray(types)) {\n        if (types.length === 0) {\n            return DEFAULT_TYPES;\n        }\n        return types;\n    }\n    return [\n        types\n    ];\n}\n//# sourceMappingURL=get-types.js.map","import { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { RecordType } from '../index.js';\n/**\n * This TTL will be used if the remote service does not return one\n */\nexport const DEFAULT_TTL = 60;\nexport function toDNSResponse(obj) {\n    return {\n        Status: obj.Status ?? 0,\n        TC: obj.TC ?? obj.flag_tc ?? false,\n        RD: obj.RD ?? obj.flag_rd ?? false,\n        RA: obj.RA ?? obj.flag_ra ?? false,\n        AD: obj.AD ?? obj.flag_ad ?? false,\n        CD: obj.CD ?? obj.flag_cd ?? false,\n        Question: (obj.Question ?? obj.questions ?? []).map((question) => {\n            return {\n                name: question.name,\n                type: RecordType[question.type]\n            };\n        }),\n        Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {\n            return {\n                name: answer.name,\n                type: RecordType[answer.type],\n                TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n                data: answer.data instanceof Uint8Array ? uint8ArrayToString(answer.data) : answer.data\n            };\n        })\n    };\n}\n//# sourceMappingURL=to-dns-response.js.map","import { multiaddr } from '@multiformats/multiaddr';\n/*\n * Valid combinations\n */\nexport const DNS4 = base('dns4');\nexport const DNS6 = base('dns6');\nexport const DNSADDR = base('dnsaddr');\nexport const DNS = or(base('dns'), DNSADDR, DNS4, DNS6);\nexport const IP = or(base('ip4'), base('ip6'));\nexport const TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));\nexport const UDP = and(IP, base('udp'));\nexport const UTP = and(UDP, base('utp'));\nexport const QUIC = and(UDP, base('quic'));\nexport const QUICV1 = and(UDP, base('quic-v1'));\nconst _WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));\nexport const WebSockets = or(and(_WebSockets, base('p2p')), _WebSockets);\nconst _WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')), and(TCP, base('tls'), base('ws')), and(DNS, base('tls'), base('ws')));\nexport const WebSocketsSecure = or(and(_WebSocketsSecure, base('p2p')), _WebSocketsSecure);\nexport const HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));\nexport const HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));\nconst _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'));\nexport const WebRTCDirect = or(and(_WebRTCDirect, base('p2p')), _WebRTCDirect);\nconst _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'));\nexport const WebTransport = or(and(_WebTransport, base('p2p')), _WebTransport);\n/**\n * @deprecated\n */\nexport const P2PWebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));\nexport const WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));\n/**\n * @deprecated\n */\nexport const P2PWebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct'), base('p2p')), and(HTTPS, base('p2p-webrtc-direct'), base('p2p')), and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));\nexport const Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\nexport const Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));\nconst _P2P = or(and(Reliable, base('p2p')), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base('p2p'));\nconst _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));\nconst CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);\nexport const Circuit = CircuitRecursive();\nexport const P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);\nexport const IPFS = P2P;\nexport const WebRTC = or(and(Circuit, base('webrtc'), base('p2p')), and(Circuit, base('webrtc')), and(Reliable, base('webrtc'), base('p2p')), and(Reliable, base('webrtc')), base('webrtc'));\n/*\n * Validation funcs\n */\nfunction makeMatchesFunction(partialMatch) {\n    function matches(a) {\n        let ma;\n        try {\n            ma = multiaddr(a);\n        }\n        catch (err) { // catch error\n            return false; // also if it's invalid it's probably not matching as well so return false\n        }\n        const out = partialMatch(ma.protoNames());\n        if (out === null) {\n            return false;\n        }\n        if (out === true || out === false) {\n            return out;\n        }\n        return out.length === 0;\n    }\n    return matches;\n}\nfunction and(...args) {\n    function partialMatch(a) {\n        if (a.length < args.length) {\n            return null;\n        }\n        let out = a;\n        args.some((arg) => {\n            out = typeof arg === 'function'\n                ? arg().partialMatch(a)\n                : arg.partialMatch(a);\n            if (Array.isArray(out)) {\n                a = out;\n            }\n            if (out === null) {\n                return true;\n            }\n            return false;\n        });\n        return out;\n    }\n    return {\n        toString: function () { return '{ ' + args.join(' ') + ' }'; },\n        input: args,\n        matches: makeMatchesFunction(partialMatch),\n        partialMatch\n    };\n}\nfunction or(...args) {\n    function partialMatch(a) {\n        let out = null;\n        args.some((arg) => {\n            const res = typeof arg === 'function'\n                ? arg().partialMatch(a)\n                : arg.partialMatch(a);\n            if (res != null) {\n                out = res;\n                return true;\n            }\n            return false;\n        });\n        return out;\n    }\n    const result = {\n        toString: function () { return '{ ' + args.join(' ') + ' }'; },\n        input: args,\n        matches: makeMatchesFunction(partialMatch),\n        partialMatch\n    };\n    return result;\n}\nfunction base(n) {\n    const name = n;\n    function matches(a) {\n        let ma;\n        try {\n            ma = multiaddr(a);\n        }\n        catch (err) { // catch error\n            return false; // also if it's invalid it's probably not matching as well so return false\n        }\n        const pnames = ma.protoNames();\n        if (pnames.length === 1 && pnames[0] === name) {\n            return true;\n        }\n        return false;\n    }\n    function partialMatch(protos) {\n        if (protos.length === 0) {\n            return null;\n        }\n        if (protos[0] === name) {\n            return protos.slice(1);\n        }\n        return null;\n    }\n    return {\n        toString: function () { return name; },\n        matches,\n        partialMatch\n    };\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module exports various matchers that can be used to infer the type of a\n * passed multiaddr.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org')\n *\n * DNS.matches(ma) // true - this is a multiaddr with a DNS address at the start\n * ```\n *\n * @example\n *\n * The default matching behaviour ignores any subsequent tuples in the multiaddr.\n * If you want stricter matching you can use `.exactMatch`:\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS, Circuit } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org/p2p/QmFoo/p2p-circuit/p2p/QmBar')\n *\n * DNS.exactMatch(ma) // false - this address has extra tuples after the DNS component\n * Circuit.matches(ma) // true\n * Circuit.exactMatch(ma) // true - the extra tuples are circuit relay related\n * ```\n */\nimport { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport {} from '@multiformats/multiaddr';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base64url } from 'multiformats/bases/base64';\n/**\n * Split a multiaddr into path components\n */\nconst toParts = (ma) => {\n    return ma.toString().split('/').slice(1);\n};\nconst func = (fn) => {\n    return {\n        match: (vals) => {\n            if (vals.length < 1) {\n                return false;\n            }\n            if (fn(vals[0])) {\n                return vals.slice(1);\n            }\n            return false;\n        },\n        pattern: 'fn'\n    };\n};\nconst literal = (str) => {\n    return {\n        match: (vals) => func((val) => val === str).match(vals),\n        pattern: str\n    };\n};\nconst string = () => {\n    return {\n        match: (vals) => func((val) => typeof val === 'string').match(vals),\n        pattern: '{string}'\n    };\n};\nconst number = () => {\n    return {\n        match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),\n        pattern: '{number}'\n    };\n};\nconst peerId = () => {\n    return {\n        match: (vals) => {\n            if (vals.length < 2) {\n                return false;\n            }\n            if (vals[0] !== 'p2p' && vals[0] !== 'ipfs') {\n                return false;\n            }\n            // Q is RSA, 1 is Ed25519 or Secp256k1\n            if (vals[1].startsWith('Q') || vals[1].startsWith('1')) {\n                try {\n                    base58btc.decode(`z${vals[1]}`);\n                }\n                catch (err) {\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n            return vals.slice(2);\n        },\n        pattern: '/p2p/{peerid}'\n    };\n};\nconst certhash = () => {\n    return {\n        match: (vals) => {\n            if (vals.length < 2) {\n                return false;\n            }\n            if (vals[0] !== 'certhash') {\n                return false;\n            }\n            try {\n                base64url.decode(vals[1]);\n            }\n            catch {\n                return false;\n            }\n            return vals.slice(2);\n        },\n        pattern: '/certhash/{certhash}'\n    };\n};\nconst optional = (matcher) => {\n    return {\n        match: (vals) => {\n            const result = matcher.match(vals);\n            if (result === false) {\n                return vals;\n            }\n            return result;\n        },\n        pattern: `optional(${matcher.pattern})`\n    };\n};\nconst or = (...matchers) => {\n    return {\n        match: (vals) => {\n            let matches;\n            for (const matcher of matchers) {\n                const result = matcher.match(vals);\n                // no match\n                if (result === false) {\n                    continue;\n                }\n                // choose greediest matcher\n                if (matches == null || result.length < matches.length) {\n                    matches = result;\n                }\n            }\n            if (matches == null) {\n                return false;\n            }\n            return matches;\n        },\n        pattern: `or(${matchers.map(m => m.pattern).join(', ')})`\n    };\n};\nconst and = (...matchers) => {\n    return {\n        match: (vals) => {\n            for (const matcher of matchers) {\n                // pass what's left of the array\n                const result = matcher.match(vals);\n                // no match\n                if (result === false) {\n                    return false;\n                }\n                vals = result;\n            }\n            return vals;\n        },\n        pattern: `and(${matchers.map(m => m.pattern).join(', ')})`\n    };\n};\nfunction fmt(...matchers) {\n    function match(ma) {\n        let parts = toParts(ma);\n        for (const matcher of matchers) {\n            const result = matcher.match(parts);\n            if (result === false) {\n                return false;\n            }\n            parts = result;\n        }\n        return parts;\n    }\n    function matches(ma) {\n        const result = match(ma);\n        return result !== false;\n    }\n    function exactMatch(ma) {\n        const result = match(ma);\n        if (result === false) {\n            return false;\n        }\n        return result.length === 0;\n    }\n    return {\n        matches,\n        exactMatch\n    };\n}\n/**\n * DNS matchers\n */\nconst _DNS4 = and(literal('dns4'), string());\nconst _DNS6 = and(literal('dns6'), string());\nconst _DNSADDR = and(literal('dnsaddr'), string());\nconst _DNS = and(literal('dns'), string());\n/**\n * Matches dns4 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS4 } from '@multiformats/multiaddr-matcher'\n *\n * DNS4.matches(multiaddr('/dns4/example.org')) // true\n * ```\n */\nexport const DNS4 = fmt(_DNS4);\n/**\n * Matches dns6 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS6 } from '@multiformats/multiaddr-matcher'\n *\n * DNS6.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS6 = fmt(_DNS6);\n/**\n * Matches dnsaddr addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNSADDR } from '@multiformats/multiaddr-matcher'\n *\n * DNSADDR.matches(multiaddr('/dnsaddr/example.org')) // true\n * ```\n */\nexport const DNSADDR = fmt(_DNSADDR);\n/**\n * Matches any dns address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * DNS.matches(multiaddr('/dnsaddr/example.org')) // true\n * DNS.matches(multiaddr('/dns4/example.org')) // true\n * DNS.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6));\nconst _IP4 = and(literal('ip4'), func(isIPv4));\nconst _IP6 = and(literal('ip6'), func(isIPv6));\nconst _IP = or(_IP4, _IP6);\nconst _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);\n/**\n * A matcher for addresses that start with IP or DNS tuples.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\n *\n * IP_OR_DOMAIN.matches(multiaddr('/ip4/123.123.123.123/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/dns/example.com/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/p2p/QmFoo')) // false\n * ```\n */\nexport const IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN);\n/**\n * Matches ip4 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP4 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip4/123.123.123.123')\n *\n * IP4.matches(ma) // true\n * ```\n */\nexport const IP4 = fmt(_IP4);\n/**\n * Matches ip6 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP6 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')\n *\n * IP6.matches(ma) // true\n * ```\n */\nexport const IP6 = fmt(_IP6);\n/**\n * Matches ip4 or ip6 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP } from '@multiformats/multiaddr-matcher'\n *\n * IP.matches(multiaddr('/ip4/123.123.123.123')) // true\n * IP.matches(multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')) // true\n * ```\n */\nexport const IP = fmt(_IP);\nconst _TCP = and(_IP_OR_DOMAIN, literal('tcp'), number());\nconst _UDP = and(_IP_OR_DOMAIN, literal('udp'), number());\n/**\n * Matches TCP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { TCP } from '@multiformats/multiaddr-matcher'\n *\n * TCP.matches(multiaddr('/ip4/123.123.123.123/tcp/1234')) // true\n * ```\n */\nexport const TCP = fmt(_TCP);\n/**\n * Matches UDP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { UDP } from '@multiformats/multiaddr-matcher'\n *\n * UDP.matches(multiaddr('/ip4/123.123.123.123/udp/1234')) // true\n * ```\n */\nexport const UDP = fmt(_UDP);\nconst _QUIC = and(_UDP, literal('quic'));\nconst _QUICV1 = and(_UDP, literal('quic-v1'));\nconst QUIC_V0_OR_V1 = or(_QUIC, _QUICV1);\n/**\n * Matches QUIC addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUIC } from '@multiformats/multiaddr-matcher'\n *\n * QUIC.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic')) // true\n * ```\n */\nexport const QUIC = fmt(_QUIC);\n/**\n * Matches QUICv1 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUICV1 } from '@multiformats/multiaddr-matcher'\n *\n * QUICV1.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1')) // true\n * ```\n */\nexport const QUICV1 = fmt(_QUICV1);\nconst _WEB = or(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);\nconst _WebSockets = or(and(_WEB, literal('ws'), optional(peerId())));\n/**\n * Matches WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSockets } from '@multiformats/multiaddr-matcher'\n *\n * WebSockets.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/ws')) // true\n * ```\n */\nexport const WebSockets = fmt(_WebSockets);\nconst _WebSocketsSecure = or(and(_WEB, literal('wss'), optional(peerId())), and(_WEB, literal('tls'), literal('ws'), optional(peerId())));\n/**\n * Matches secure WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSocketsSecure } from '@multiformats/multiaddr-matcher'\n *\n * WebSocketsSecure.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/wss')) // true\n * ```\n */\nexport const WebSocketsSecure = fmt(_WebSocketsSecure);\nconst _WebRTCDirect = and(_UDP, literal('webrtc-direct'), optional(certhash()), optional(certhash()), optional(peerId()));\n/**\n * Matches WebRTC-direct addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo/webrtc-direct/certhash/u....')) // true\n * ```\n */\nexport const WebRTCDirect = fmt(_WebRTCDirect);\nconst _WebTransport = and(_QUICV1, literal('webtransport'), optional(certhash()), optional(certhash()), optional(peerId()));\n/**\n * Matches WebTransport addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1/webtransport/certhash/u..../certhash/u..../p2p/QmFoo')) // true\n * ```\n */\nexport const WebTransport = fmt(_WebTransport);\nconst _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());\n/**\n * Matches peer addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { P2P } from '@multiformats/multiaddr-matcher'\n *\n * P2P.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo')) // true\n * ```\n */\nexport const P2P = fmt(_P2P);\nconst _Circuit = and(_P2P, literal('p2p-circuit'), peerId());\n/**\n * Matches circuit relay addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Circuit } from '@multiformats/multiaddr-matcher'\n *\n * Circuit.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/p2p/QmTarget')) // true\n * ```\n */\nexport const Circuit = fmt(_Circuit);\nconst _WebRTC = or(and(_P2P, literal('p2p-circuit'), literal('webrtc'), optional(peerId())), and(_P2P, literal('webrtc'), optional(peerId())), literal('webrtc'));\n/**\n * Matches WebRTC addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTC } from '@multiformats/multiaddr-matcher'\n *\n * WebRTC.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/webrtc/p2p/QmTarget')) // true\n * ```\n */\nexport const WebRTC = fmt(_WebRTC);\nconst _HTTP = or(and(_IP_OR_DOMAIN, literal('tcp'), number(), literal('http'), optional(peerId())), and(_IP_OR_DOMAIN, literal('http'), optional(peerId())));\n/**\n * Matches HTTP addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { HTTP } from '@multiformats/multiaddr-matcher'\n *\n * HTTP.matches(multiaddr('/dns/example.org/http')) // true\n * ```\n */\nexport const HTTP = fmt(_HTTP);\nconst _HTTPS = or(and(_IP_OR_DOMAIN, literal('tcp'), or(and(literal('443'), literal('http')), and(number(), literal('https'))), optional(peerId())), and(_IP_OR_DOMAIN, literal('tls'), literal('http'), optional(peerId())), and(_IP_OR_DOMAIN, literal('https'), optional(peerId())));\n/**\n * Matches HTTPS addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { HTTP } from '@multiformats/multiaddr-matcher'\n *\n * HTTP.matches(multiaddr('/dns/example.org/tls/http')) // true\n * ```\n */\nexport const HTTPS = fmt(_HTTPS);\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module allows easy conversion of Multiaddrs to string URIs.\n *\n * @example Converting multiaddrs to string URIs\n *\n * ```js\n * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n *\n * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))\n * // -> https://protocol.ai\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))\n * // -> http://127.0.0.1:8080\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))\n * // -> tcp://127.0.0.1:8080\n * ```\n *\n * Note:\n *\n * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)\n *   - this means produced URIs will start with `http://` instead of `tcp://`\n *   - passing `{ assumeHttp: false }` disables this behavior\n * - Might be lossy - e.g. a DNSv6 multiaddr\n * - Can throw if the passed multiaddr:\n *   - is not a valid multiaddr\n *   - is not supported as a URI e.g. circuit\n */\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nconst ASSUME_HTTP_CODES = [\n    protocols('tcp').code,\n    protocols('dns').code,\n    protocols('dnsaddr').code,\n    protocols('dns4').code,\n    protocols('dns6').code\n];\nfunction extractSNI(ma) {\n    let sniProtoCode;\n    try {\n        sniProtoCode = protocols('sni').code;\n    }\n    catch (e) {\n        // No SNI protocol in multiaddr\n        return null;\n    }\n    for (const [proto, value] of ma) {\n        if (proto === sniProtoCode && value !== undefined) {\n            return value;\n        }\n    }\n    return null;\n}\nfunction hasTLS(ma) {\n    return ma.some(([proto, _]) => proto === protocols('tls').code);\n}\nfunction interpretNext(headProtoCode, headProtoVal, restMa) {\n    const interpreter = interpreters[protocols(headProtoCode).name];\n    if (interpreter === undefined) {\n        throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`);\n    }\n    const restVal = interpreter(headProtoVal, restMa);\n    if (headProtoCode === protocols('ip6').code) {\n        return `[${restVal}]`;\n    }\n    return restVal;\n}\nconst interpreters = {\n    ip4: (value, restMa) => value,\n    ip6: (value, restMa) => {\n        if (restMa.length === 0) {\n            return value;\n        }\n        return `[${value}]`;\n    },\n    tcp: (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;\n    },\n    udp: (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;\n    },\n    dnsaddr: (value, restMa) => value,\n    dns4: (value, restMa) => value,\n    dns6: (value, restMa) => value,\n    dns: (value, restMa) => value,\n    ipfs: (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`;\n    },\n    p2p: (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`;\n    },\n    http: (value, restMa) => {\n        const maHasTLS = hasTLS(restMa);\n        const sni = extractSNI(restMa);\n        if (maHasTLS && sni !== null) {\n            return `https://${sni}`;\n        }\n        const protocol = maHasTLS ? 'https://' : 'http://';\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n        baseVal = baseVal.replace('tcp://', '');\n        return `${protocol}${baseVal}`;\n    },\n    'http-path': (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        const baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n        const decodedValue = decodeURIComponent(value);\n        return `${baseVal}/${decodedValue}`;\n    },\n    tls: (value, restMa) => {\n        // Noop, the parent context knows that it's tls. We don't need to do\n        // anything here\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n    },\n    sni: (value, restMa) => {\n        // Noop, the parent context uses the sni information, we don't need to do\n        // anything here\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n    },\n    https: (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n        baseVal = baseVal.replace('tcp://', '');\n        return `https://${baseVal}`;\n    },\n    ws: (value, restMa) => {\n        const maHasTLS = hasTLS(restMa);\n        const sni = extractSNI(restMa);\n        if (maHasTLS && sni !== null) {\n            return `wss://${sni}`;\n        }\n        const protocol = maHasTLS ? 'wss://' : 'ws://';\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n        // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n        baseVal = baseVal.replace('tcp://', '');\n        return `${protocol}${baseVal}`;\n    },\n    wss: (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n        baseVal = baseVal.replace('tcp://', '');\n        return `wss://${baseVal}`;\n    },\n    'p2p-websocket-star': (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`;\n    },\n    'p2p-webrtc-star': (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`;\n    },\n    'p2p-webrtc-direct': (value, restMa) => {\n        const tailProto = restMa.pop();\n        if (tailProto === undefined) {\n            throw new Error('Unexpected end of multiaddr');\n        }\n        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`;\n    }\n};\nexport function multiaddrToUri(input, opts) {\n    const ma = multiaddr(input);\n    const parts = ma.stringTuples();\n    const head = parts.pop();\n    if (head === undefined) {\n        throw new Error('Unexpected end of multiaddr');\n    }\n    const protocol = protocols(head[0]);\n    const interpreter = interpreters[protocol.name];\n    if (interpreter == null) {\n        throw new Error(`No interpreter found for ${protocol.name}`);\n    }\n    let uri = interpreter(head[1] ?? '', parts);\n    if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head[0])) {\n        // strip any declared protocol\n        uri = uri.replace(/^.*:\\/\\//, '');\n        if (head[1] === '443') {\n            uri = `https://${uri}`;\n        }\n        else {\n            uri = `http://${uri}`;\n        }\n    }\n    if (uri.startsWith('http://') || uri.startsWith('https://')) {\n        // this will strip default ports while keeping paths intact\n        uri = new URL(uri).toString();\n        // strip trailing slash, e.g. http://127.0.0.1/ -> http://127.0.0.1\n        if (uri.endsWith('/')) {\n            uri = uri.substring(0, uri.length - 1);\n        }\n    }\n    return uri;\n}\n//# sourceMappingURL=index.js.map","import * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { convertToBytes, convertToString } from './convert.js';\nimport { getProtocol } from './protocols-table.js';\nexport function stringToMultiaddrParts(str) {\n    str = cleanPath(str);\n    const tuples = [];\n    const stringTuples = [];\n    let path = null;\n    const parts = str.split('/').slice(1);\n    if (parts.length === 1 && parts[0] === '') {\n        return {\n            bytes: new Uint8Array(),\n            string: '/',\n            tuples: [],\n            stringTuples: [],\n            path: null\n        };\n    }\n    for (let p = 0; p < parts.length; p++) {\n        const part = parts[p];\n        const proto = getProtocol(part);\n        if (proto.size === 0) {\n            tuples.push([proto.code]);\n            stringTuples.push([proto.code]);\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        p++; // advance addr part\n        if (p >= parts.length) {\n            throw ParseError('invalid address: ' + str);\n        }\n        // if it's a path proto, take the rest\n        if (proto.path === true) {\n            // should we need to check each path part to see if it's a proto?\n            // This would allow for other protocols to be added after a unix path,\n            // however it would have issues if the path had a protocol name in the path\n            path = cleanPath(parts.slice(p).join('/'));\n            tuples.push([proto.code, convertToBytes(proto.code, path)]);\n            stringTuples.push([proto.code, path]);\n            break;\n        }\n        const bytes = convertToBytes(proto.code, parts[p]);\n        tuples.push([proto.code, bytes]);\n        stringTuples.push([proto.code, convertToString(proto.code, bytes)]);\n    }\n    return {\n        string: stringTuplesToString(stringTuples),\n        bytes: tuplesToBytes(tuples),\n        tuples,\n        stringTuples,\n        path\n    };\n}\nexport function bytesToMultiaddrParts(bytes) {\n    const tuples = [];\n    const stringTuples = [];\n    let path = null;\n    let i = 0;\n    while (i < bytes.length) {\n        const code = varint.decode(bytes, i);\n        const n = varint.encodingLength(code);\n        const p = getProtocol(code);\n        const size = sizeForAddr(p, bytes.slice(i + n));\n        if (size === 0) {\n            tuples.push([code]);\n            stringTuples.push([code]);\n            i += n;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const addr = bytes.slice(i + n, i + n + size);\n        i += (size + n);\n        if (i > bytes.length) { // did not end _exactly_ at buffer.length\n            throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'));\n        }\n        // ok, tuple seems good.\n        tuples.push([code, addr]);\n        const stringAddr = convertToString(code, addr);\n        stringTuples.push([code, stringAddr]);\n        if (p.path === true) {\n            // should we need to check each path part to see if it's a proto?\n            // This would allow for other protocols to be added after a unix path,\n            // however it would have issues if the path had a protocol name in the path\n            path = stringAddr;\n            break;\n        }\n    }\n    return {\n        bytes: Uint8Array.from(bytes),\n        string: stringTuplesToString(stringTuples),\n        tuples,\n        stringTuples,\n        path\n    };\n}\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString(tuples) {\n    const parts = [];\n    tuples.map((tup) => {\n        const proto = getProtocol(tup[0]);\n        parts.push(proto.name);\n        if (tup.length > 1 && tup[1] != null) {\n            parts.push(tup[1]);\n        }\n        return null;\n    });\n    return cleanPath(parts.join('/'));\n}\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes(tuples) {\n    return uint8ArrayConcat(tuples.map((tup) => {\n        const proto = getProtocol(tup[0]);\n        let buf = Uint8Array.from(varint.encode(proto.code));\n        if (tup.length > 1 && tup[1] != null) {\n            buf = uint8ArrayConcat([buf, tup[1]]); // add address buffer\n        }\n        return buf;\n    }));\n}\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr(p, addr) {\n    if (p.size > 0) {\n        return p.size / 8;\n    }\n    else if (p.size === 0) {\n        return 0;\n    }\n    else {\n        const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));\n        return size + varint.encodingLength(size);\n    }\n}\nexport function bytesToTuples(buf) {\n    const tuples = [];\n    let i = 0;\n    while (i < buf.length) {\n        const code = varint.decode(buf, i);\n        const n = varint.encodingLength(code);\n        const p = getProtocol(code);\n        const size = sizeForAddr(p, buf.slice(i + n));\n        if (size === 0) {\n            tuples.push([code]);\n            i += n;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const addr = buf.slice(i + n, i + n + size);\n        i += (size + n);\n        if (i > buf.length) { // did not end _exactly_ at buffer.length\n            throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'));\n        }\n        // ok, tuple seems good.\n        tuples.push([code, addr]);\n    }\n    return tuples;\n}\nexport function cleanPath(str) {\n    return '/' + str.trim().split('/').filter((a) => a).join('/');\n}\nexport function ParseError(str) {\n    return new Error('Error parsing address: ' + str);\n}\n//# sourceMappingURL=codec.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        case 481: // http-path\n            return globalThis.encodeURIComponent(bytes2str(buf));\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        case 481: // http-path\n            return str2bytes(globalThis.decodeURIComponent(str));\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","import { convertToIpNet } from '../convert.js';\nimport { multiaddr } from '../index.js';\n/**\n * A utility class to determine if a Multiaddr contains another\n * multiaddr.\n *\n * This can be used with ipcidr ranges to determine if a given\n * multiaddr is in a ipcidr range.\n *\n * @example\n *\n * ```js\n * import { multiaddr, MultiaddrFilter } from '@multiformats/multiaddr'\n *\n * const range = multiaddr('/ip4/192.168.10.10/ipcidr/24')\n * const filter = new MultiaddrFilter(range)\n *\n * const input = multiaddr('/ip4/192.168.10.2/udp/60')\n * console.info(filter.contains(input)) // true\n * ```\n */\nexport class MultiaddrFilter {\n    multiaddr;\n    netmask;\n    constructor(input) {\n        this.multiaddr = multiaddr(input);\n        this.netmask = convertToIpNet(this.multiaddr);\n    }\n    contains(input) {\n        if (input == null)\n            return false;\n        const m = multiaddr(input);\n        let ip;\n        for (const [code, value] of m.stringTuples()) {\n            if (code === 4 || code === 41) {\n                ip = value;\n                break;\n            }\n        }\n        if (ip === undefined)\n            return false;\n        return this.netmask.contains(ip);\n    }\n}\n//# sourceMappingURL=multiaddr-filter.js.map","/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * const addr =  multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * const addr = multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddr } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddr)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(await ma.resolve(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js';\nimport { getProtocol } from './protocols-table.js';\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new MultiaddrClass(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","import { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport { isIP } from '@chainsafe/is-ip';\nexport const isV4 = isIPv4;\nexport const isV6 = isIPv6;\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip) {\n    let offset = 0;\n    ip = ip.toString().trim();\n    if (isV4(ip)) {\n        const bytes = new Uint8Array(offset + 4);\n        ip.split(/\\./g).forEach((byte) => {\n            bytes[offset++] = parseInt(byte, 10) & 0xff;\n        });\n        return bytes;\n    }\n    if (isV6(ip)) {\n        const sections = ip.split(':', 8);\n        let i;\n        for (i = 0; i < sections.length; i++) {\n            const isv4 = isV4(sections[i]);\n            let v4Buffer;\n            if (isv4) {\n                v4Buffer = toBytes(sections[i]);\n                sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16');\n            }\n            if (v4Buffer != null && ++i < 8) {\n                sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'));\n            }\n        }\n        if (sections[0] === '') {\n            while (sections.length < 8)\n                sections.unshift('0');\n        }\n        else if (sections[sections.length - 1] === '') {\n            while (sections.length < 8)\n                sections.push('0');\n        }\n        else if (sections.length < 8) {\n            for (i = 0; i < sections.length && sections[i] !== ''; i++)\n                ;\n            const argv = [i, 1];\n            for (i = 9 - sections.length; i > 0; i--) {\n                argv.push('0');\n            }\n            sections.splice.apply(sections, argv);\n        }\n        const bytes = new Uint8Array(offset + 16);\n        for (i = 0; i < sections.length; i++) {\n            const word = parseInt(sections[i], 16);\n            bytes[offset++] = (word >> 8) & 0xff;\n            bytes[offset++] = word & 0xff;\n        }\n        return bytes;\n    }\n    throw new Error('invalid ip address');\n};\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf, offset = 0, length) {\n    offset = ~~offset;\n    length = length ?? (buf.length - offset);\n    const view = new DataView(buf.buffer);\n    if (length === 4) {\n        const result = [];\n        // IPv4\n        for (let i = 0; i < length; i++) {\n            result.push(buf[offset + i]);\n        }\n        return result.join('.');\n    }\n    if (length === 16) {\n        const result = [];\n        // IPv6\n        for (let i = 0; i < length; i += 2) {\n            result.push(view.getUint16(offset + i).toString(16));\n        }\n        return result.join(':')\n            .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n            .replace(/:{3,4}/, '::');\n    }\n    return '';\n};\n//# sourceMappingURL=ip.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nimport { isMultiaddr, multiaddr, resolvers } from './index.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new Multiaddr(addr);\n        return new Multiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new Multiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new Multiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const result = await resolver(this, options);\n        return result.map(str => multiaddr(str));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n//# sourceMappingURL=multiaddr.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [481, V, 'http-path'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","import { CodeError } from '@libp2p/interface';\nimport { dns, RecordType } from '@multiformats/dns';\nimport { multiaddr } from '../index.js';\nimport { getProtocol } from '../protocols-table.js';\nconst MAX_RECURSIVE_DEPTH = 32;\nconst { code: dnsaddrCode } = getProtocol('dnsaddr');\nexport const dnsaddrResolver = async function dnsaddrResolver(ma, options = {}) {\n    const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;\n    if (recursionLimit === 0) {\n        throw new CodeError('Max recursive depth reached', 'ERR_MAX_RECURSIVE_DEPTH_REACHED');\n    }\n    const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];\n    const resolver = options?.dns ?? dns();\n    const result = await resolver.query(`_dnsaddr.${hostname}`, {\n        signal: options?.signal,\n        types: [\n            RecordType.TXT\n        ]\n    });\n    const peerId = ma.getPeerId();\n    const output = [];\n    for (const answer of result.Answer) {\n        const addr = answer.data\n            .replace(/[\"']/g, '')\n            .trim()\n            .split('=')[1];\n        if (addr == null) {\n            continue;\n        }\n        if (peerId != null && !addr.includes(peerId)) {\n            continue;\n        }\n        const ma = multiaddr(addr);\n        if (addr.startsWith('/dnsaddr')) {\n            const resolved = await ma.resolve({\n                ...options,\n                maxRecursiveDepth: recursionLimit - 1\n            });\n            output.push(...resolved.map(ma => ma.toString()));\n        }\n        else {\n            output.push(ma.toString());\n        }\n    }\n    return output;\n};\n//# sourceMappingURL=dnsaddr.js.map","export { dnsaddrResolver } from './dnsaddr.js';\n//# sourceMappingURL=index.js.map","// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\nimport { bool as abool, bytes as abytes, number as anumber } from './_assert.js';\nimport { checkOpts, clean, copyBytes, u32 } from './utils.js';\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\nexport const sigma = sigma32_32.slice();\nexport function rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = u32(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? u32(data) : U32_EMPTY;\n    const o32 = isAligned ? u32(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\nexport function createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    anumber(counterLength);\n    anumber(rounds);\n    abool(counterRight);\n    abool(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        abytes(key);\n        abytes(nonce);\n        abytes(data);\n        const len = data.length;\n        if (output === undefined)\n            output = new Uint8Array(len);\n        abytes(output);\n        anumber(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length, k, sigma;\n        if (l === 32) {\n            toClean.push((k = copyBytes(key)));\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce))\n            toClean.push((nonce = copyBytes(nonce)));\n        const k32 = u32(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = u32(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        clean(...toClean);\n        return output;\n    };\n}\n//# sourceMappingURL=_arx.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { bytes as abytes, exists as aexists, output as aoutput } from './_assert.js';\nimport { clean, toBytes } from './utils.js';\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = toBytes(key);\n        abytes(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n        clean(g);\n    }\n    update(data) {\n        aexists(this);\n        const { buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        clean(this.h, this.r, this.buffer, this.pad);\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nexport function wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update(toBytes(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\nexport const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map","// prettier-ignore\nimport { createCipher, rotl } from './_arx.js';\nimport { bytes as abytes } from './_assert.js';\nimport { poly1305 } from './_poly1305.js';\nimport { clean, createView, equalBytes, setBigUint64, wrapCipher, } from './utils.js';\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    clean(authKey, num);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    abytes(key, 32);\n    abytes(nonce);\n    return {\n        encrypt(plaintext, output) {\n            const plength = plaintext.length;\n            const clength = plength + tagLength;\n            if (output) {\n                abytes(output, clength);\n            }\n            else {\n                output = new Uint8Array(clength);\n            }\n            xorStream(key, nonce, plaintext, output, 1);\n            const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n            output.set(tag, plength); // append tag\n            clean(tag);\n            return output;\n        },\n        decrypt(ciphertext, output) {\n            const clength = ciphertext.length;\n            const plength = clength - tagLength;\n            if (clength < tagLength)\n                throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n            if (output) {\n                abytes(output, plength);\n            }\n            else {\n                output = new Uint8Array(plength);\n            }\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!equalBytes(passedTag, tag))\n                throw new Error('invalid tag');\n            xorStream(key, nonce, data, output, 1);\n            clean(tag);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nexport const xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));\n//# sourceMappingURL=chacha.js.map","/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nimport { bytes as abytes, isBytes } from './_assert.js';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`string expected, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if (isBytes(data))\n        data = copyBytes(data);\n    else\n        throw new Error(`Uint8Array expected, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// For runtime check if class implements interface\nexport class Hash {\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = (params, c) => {\n    Object.assign(c, params);\n    return c;\n};\n// Polyfill for Safari 14\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes) {\n    return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const validateW = (W) => {\n        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n            throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);\n    };\n    const opts = (W) => {\n        validateW(W);\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, n, transform) {\n            const W = pointWindowSizes.get(P) || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return this.wNAF(W, comp, n);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax + y = 1 + dxy\nimport { validateBasic, wNAF } from './curve.js';\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, memoized, abool } from './utils.js';\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            abool('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // 0 <= n < MASK\n    // Coordinates larger than Fp.ORDER are allowed for zip215\n    function aCoordinate(title, n) {\n        ut.aInRange('coordinate ' + title, n, _0n, MASK);\n    }\n    function assertPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X\n        const Y2 = modP(Y * Y); // Y\n        const Z2 = modP(Z * Z); // Z\n        const Z4 = modP(Z2 * Z2); // Z\n        const aX2 = modP(X2 * a); // aX\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            aCoordinate('x', ex);\n            aCoordinate('y', ey);\n            aCoordinate('z', ez);\n            aCoordinate('t', et);\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            aCoordinate('x', x);\n            aCoordinate('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            assertPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            assertPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = this.wNAF(n);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            const n = scalar;\n            ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            abool('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = ut.bytesToNumberLE(normed);\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            ut.aInRange('pointHex.y', y, _0n, max);\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(ut.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = ut.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        if (zip215 !== undefined)\n            abool('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map","import { mod } from './modular.js';\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg, count, options) {\n    validateObject(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    abytes(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = mod(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexport function isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexport function createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexport function FpLegendre(order) {\n    // (a | p)  1    if a is a square (mod p), quadratic residue\n    // (a | p)  -1   if a is not a square (mod p), quadratic non residue\n    // (a | p)  0    if a  0 (mod p)\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject, } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => mod(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange('u', u, _0n, P);\n        aInRange('scalar', scalar, _0n, P);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return numberToBytesLE(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return bytesToNumberLE(u);\n    }\n    function decodeScalar(n) {\n        const bytes = ensureBytes('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return bytesToNumberLE(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(`${title} must be valid boolean, got \"${value}\".`);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nimport { validateBasic, wNAF } from './curve.js';\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, memoized, abool } from './utils.js';\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        abool('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return ut.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, N); // disabled by default, enabled for BLS\n        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z)  (x=x/z, y=y/z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            ut.aInRange('scalar', sc, _0n, CURVE.n);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (sc === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, sc);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            abool('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!ut.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        ut.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        validateSigVerOpts(opts);\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || ut.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { twistedEdwards } from './abstract/edwards.js';\nimport { createHasher, expand_message_xmd } from './abstract/hash-to-curve.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { bytesToHex, bytesToNumberLE, ensureBytes, equalBytes, numberToBytesLE, } from './abstract/utils.js';\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = mod(v * v * v, P); // v\n    const v7 = mod(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: _8n,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n}))();\n/**\n * ed25519 curve with EdDSA signatures.\n */\nexport const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(utf8ToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nexport const ed25519ctx = /* @__PURE__ */ (() => twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n}))();\nexport const ed25519ph = /* @__PURE__ */ (() => twistedEdwards(Object.assign({}, ed25519Defaults, {\n    domain: ed25519_domain,\n    prehash: sha512,\n})))();\nexport const x25519 = /* @__PURE__ */ (() => montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = ensureBytes('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = ensureBytes('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if (isNegativeLE(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return numberToBytesLE(s, 32); // 11\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n    const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { inRange, aInRange, bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE, } from './abstract/utils.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n */\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    aInRange('x', x, _1n, secp256k1P); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!inRange(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!inRange(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n */\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash, ikm, salt) {\n    assertHash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash, prk, info, length = 32) {\n    assertHash(hash);\n    assertNumber(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    assertHash(hash);\n    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    assertNumber(c);\n    assertNumber(dkLen);\n    assertNumber(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = toBytes(_password);\n    const salt = toBytes(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexport async function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await asyncLoop(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16_777_619n,\n\t64: 1_099_511_628_211n,\n\t128: 309_485_009_821_345_068_724_781_371n,\n\t256: 374_144_419_156_711_147_060_143_317_175_368_453_031_918_731_002_211n,\n\t512: 35_835_915_874_844_867_368_919_076_489_095_108_449_946_327_955_754_392_558_399_825_615_420_669_938_882_575_126_094_039_892_345_713_852_759n,\n\t1024: 5_016_456_510_113_118_655_434_598_811_035_278_955_030_765_345_404_790_744_303_017_523_831_112_055_108_147_451_509_157_692_220_295_382_716_162_651_878_526_895_249_385_292_291_816_524_375_083_746_691_371_804_094_271_873_160_484_737_966_720_260_389_217_684_476_157_468_082_573n,\n};\n\nconst FNV_OFFSETS = {\n\t32: 2_166_136_261n,\n\t64: 14_695_981_039_346_656_037n,\n\t128: 144_066_263_297_769_815_596_495_629_667_062_367_629n,\n\t256: 100_029_257_958_052_580_907_070_968_620_625_704_837_092_796_014_241_193_945_225_284_501_741_471_925_557n,\n\t512: 9_659_303_129_496_669_498_009_435_400_716_310_466_090_418_745_672_637_896_108_374_329_434_462_657_994_582_932_197_716_438_449_813_051_892_206_539_805_784_495_328_239_340_083_876_191_928_701_583_869_517_785n,\n\t1024: 14_197_795_064_947_621_068_722_070_641_403_218_320_880_622_795_441_933_960_878_474_914_617_582_723_252_296_732_303_717_722_150_864_096_521_202_355_549_365_628_174_669_108_571_814_760_471_015_076_148_029_755_969_804_077_320_157_692_458_563_003_215_304_957_150_157_403_644_460_363_550_505_412_711_285_966_361_610_267_868_082_893_823_963_790_439_336_411_086_884_584_107_735_010_676_915n,\n};\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction fnv1aUint8Array(uint8Array, size) {\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- This is a performance-sensitive loop\n\tfor (let index = 0; index < uint8Array.length; index++) {\n\t\thash ^= BigInt(uint8Array[index]);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nfunction fnv1aEncodeInto(string, size, utf8Buffer) {\n\tif (utf8Buffer.length === 0) {\n\t\tthrow new Error('The `utf8Buffer` option must have a length greater than zero');\n\t}\n\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\tlet remaining = string;\n\n\twhile (remaining.length > 0) {\n\t\tconst result = cachedEncoder.encodeInto(remaining, utf8Buffer);\n\t\tremaining = remaining.slice(result.read);\n\t\tfor (let index = 0; index < result.written; index++) {\n\t\t\thash ^= BigInt(utf8Buffer[index]);\n\t\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t\t}\n\t}\n\n\treturn hash;\n}\n\nexport default function fnv1a(value, {size = 32, utf8Buffer} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (utf8Buffer) {\n\t\t\treturn fnv1aEncodeInto(value, size, utf8Buffer);\n\t\t}\n\n\t\tvalue = cachedEncoder.encode(value);\n\t}\n\n\treturn fnv1aUint8Array(value, size);\n}\n","/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal(signals) {\n    const controller = new globalThis.AbortController();\n    function onAbort() {\n        controller.abort();\n        for (const signal of signals) {\n            if (signal?.removeEventListener != null) {\n                signal.removeEventListener('abort', onAbort);\n            }\n        }\n    }\n    for (const signal of signals) {\n        if (signal?.aborted === true) {\n            onAbort();\n            break;\n        }\n        if (signal?.addEventListener != null) {\n            signal.addEventListener('abort', onAbort);\n        }\n    }\n    function clear() {\n        for (const signal of signals) {\n            if (signal?.removeEventListener != null) {\n                signal.removeEventListener('abort', onAbort);\n            }\n        }\n    }\n    const signal = controller.signal;\n    signal.clear = clear;\n    return signal;\n}\n//# sourceMappingURL=index.js.map","import { createLibp2p } from 'libp2p';\nimport { webSockets } from '@libp2p/websockets';\nimport { noise } from '@chainsafe/libp2p-noise';\nimport { mplex } from '@libp2p/mplex';\nimport { kadDHT } from '@libp2p/kad-dht';\nimport { identify } from '@libp2p/identify';\nimport { pipe } from 'it-pipe';\nimport { fromString, toString } from 'uint8arrays';\n\n// Create the libp2p node\nconst node = await createLibp2p({\n  transports: [webSockets()],\n  connectionEncryption: [noise()],\n  streamMuxers: [mplex()],\n  services: {\n    dht: kadDHT(),\n    identify: identify(),  // Include identify service\n  }\n});\n\n\n// Start the libp2p node\nawait node.start();\nconsole.log('Libp2p node started');\nconsole.log('DHT service:', node.services.dht);\n\n// Correct method to listen for connection events\nnode.addEventListener('peer:connect', (evt) => {\n  const peerId = evt.detail;\n  console.log('Connected to:', peerId.toString());\n});\n\nnode.addEventListener('peer:disconnect', (evt) => {\n  const peerId = evt.detail;\n  console.log('Disconnected from:', peerId.toString());\n});\n\n// Periodically log routing table to check peer discovery\nsetInterval(() => {\n  console.log('Routing Table Peers:', node.services.dht.routingTable.peers);\n}, 5000);\n\n// Check if both nodes are connected to the same DHT\nconst checkDHTConnection = () => {\n  console.log('DHT Routing Table:', node.services.dht.routingTable);\n  console.log('Connected peers:', node.getPeers());\n};\n\nsetInterval(checkDHTConnection, 10000); // Log every 10 seconds\n\nconst advertiseRoom = async (roomId) => {\n  console.log('DHT Network:', node.services.dht.network);\n  const roomKey = `/rooms/${roomId}`;\n  console.log('Your node peer ID:', node.peerId.toString());\n  await node.services.dht.provide(roomKey);\n  console.log(`Room ${roomId} advertised with key ${roomKey}`);\n  console.log('Room advertised: Checking provider status...');\n\n  // Debugging: Check closest peers in the DHT\n  try {\n    const closestPeers = await node.services.dht.getClosestPeers(roomKey);\n    console.log('Closest peers:', closestPeers);\n  } catch (error) {\n    console.error('Error finding closest peers:', error);\n  }\n};\n\n\n\n// Room Join: Find peers in the room\nconst joinRoom = async (roomId) => {\n  console.log('DHT Network:', node.services.dht.network);\n  const roomKey = `/rooms/${roomId}`;\n  console.log('Your node peer ID:', node.peerId.toString());\n  console.log(`Searching for providers of ${roomKey}...`);\n  \n  await new Promise(resolve => setTimeout(() => console.log('Hello'), 1000)); // This is correct\n    \n  try {\n    const peers = await node.services.dht.findProviders(roomKey);\n    if (!Array.isArray(peers) || peers.length === 0) {\n      console.error(`No peers found for room ${roomId}`);\n      return [];\n    }\n    \n    console.log(`Found ${peers.length} peers for room ${roomId}`);\n    peers.forEach(peer => {\n      console.log(`Discovered peer: ${peer.id.toString()}`);\n    });\n    \n    return peers; // Return discovered peers\n  } catch (error) {\n    console.error('Error during peer discovery:', error);\n    return [];\n  }\n};\n\n// Messaging Handler: Handle incoming chat messages\nconst handleChat = async ({ stream }) => {\n  await pipe(\n    stream.source,\n    async function (source) {\n      for await (const msg of source) {\n        console.log(`Received message: ${toString(msg)}`);\n        const chatLog = document.getElementById('chatLog');\n        const li = document.createElement('li');\n        li.textContent = `Peer: ${toString(msg)}`;\n        chatLog.appendChild(li);\n      }\n    }\n  );\n};\n\n// Register the message handler\nnode.handle('/chat/1.0.0', handleChat);\n\n// Send messages to a specific peer\nconst sendMessageToPeer = async (peerId, message) => {\n  const { stream } = await node.dialProtocol(peerId, '/chat/1.0.0');\n  await pipe([fromString(message)], stream.sink);\n  console.log(`Sent message to ${peerId}`);\n};\n\n// Example function to join room and send a message\nconst joinAndSendMessage = async (roomId, message) => {\n  const peers = await joinRoom(roomId);\n  if (peers.length > 0) {\n    await sendMessageToPeer(peers[0].id, message);\n  }\n};\n\n// Expose the functions to the window for testing\nwindow.createRoom = (roomId) => {\n  console.log('Room ID for Create Room:', roomId);  // Log roomId\n  advertiseRoom(roomId);  // Your existing function\n};\n\nwindow.joinRoom = (roomId) => {\n  console.log('Room ID for Join Room:', roomId);  // Log roomId\n  joinRoom(roomId);  // Your existing function\n};\n\nwindow.sendMessage = (roomId, message) => {\n  console.log('Room ID for Send Message:', roomId);  // Log roomId\n  console.log('Message:', message);  // Log the message\n  joinAndSendMessage(roomId, message);  // Your existing function\n};","import drain from 'it-drain';\nimport filter from 'it-filter';\nimport sort from 'it-sort';\nimport take from 'it-take';\nexport class BaseDatastore {\n    put(key, val, options) {\n        return Promise.reject(new Error('.put is not implemented'));\n    }\n    get(key, options) {\n        return Promise.reject(new Error('.get is not implemented'));\n    }\n    has(key, options) {\n        return Promise.reject(new Error('.has is not implemented'));\n    }\n    delete(key, options) {\n        return Promise.reject(new Error('.delete is not implemented'));\n    }\n    async *putMany(source, options = {}) {\n        for await (const { key, value } of source) {\n            await this.put(key, value, options);\n            yield key;\n        }\n    }\n    async *getMany(source, options = {}) {\n        for await (const key of source) {\n            yield {\n                key,\n                value: await this.get(key, options)\n            };\n        }\n    }\n    async *deleteMany(source, options = {}) {\n        for await (const key of source) {\n            await this.delete(key, options);\n            yield key;\n        }\n    }\n    batch() {\n        let puts = [];\n        let dels = [];\n        return {\n            put(key, value) {\n                puts.push({ key, value });\n            },\n            delete(key) {\n                dels.push(key);\n            },\n            commit: async (options) => {\n                await drain(this.putMany(puts, options));\n                puts = [];\n                await drain(this.deleteMany(dels, options));\n                dels = [];\n            }\n        };\n    }\n    /**\n     * Extending classes should override `query` or implement this method\n     */\n    // eslint-disable-next-line require-yield\n    async *_all(q, options) {\n        throw new Error('._all is not implemented');\n    }\n    /**\n     * Extending classes should override `queryKeys` or implement this method\n     */\n    // eslint-disable-next-line require-yield\n    async *_allKeys(q, options) {\n        throw new Error('._allKeys is not implemented');\n    }\n    query(q, options) {\n        let it = this._all(q, options);\n        if (q.prefix != null) {\n            const prefix = q.prefix;\n            it = filter(it, (e) => e.key.toString().startsWith(prefix));\n        }\n        if (Array.isArray(q.filters)) {\n            it = q.filters.reduce((it, f) => filter(it, f), it);\n        }\n        if (Array.isArray(q.orders)) {\n            it = q.orders.reduce((it, f) => sort(it, f), it);\n        }\n        if (q.offset != null) {\n            let i = 0;\n            const offset = q.offset;\n            it = filter(it, () => i++ >= offset);\n        }\n        if (q.limit != null) {\n            it = take(it, q.limit);\n        }\n        return it;\n    }\n    queryKeys(q, options) {\n        let it = this._allKeys(q, options);\n        if (q.prefix != null) {\n            const prefix = q.prefix;\n            it = filter(it, (key) => key.toString().startsWith(prefix));\n        }\n        if (Array.isArray(q.filters)) {\n            it = q.filters.reduce((it, f) => filter(it, f), it);\n        }\n        if (Array.isArray(q.orders)) {\n            it = q.orders.reduce((it, f) => sort(it, f), it);\n        }\n        if (q.offset != null) {\n            const offset = q.offset;\n            let i = 0;\n            it = filter(it, () => i++ >= offset);\n        }\n        if (q.limit != null) {\n            it = take(it, q.limit);\n        }\n        return it;\n    }\n}\n//# sourceMappingURL=base.js.map","import errCode from 'err-code';\nexport function dbOpenFailedError(err) {\n    err = err ?? new Error('Cannot open database');\n    return errCode(err, 'ERR_DB_OPEN_FAILED');\n}\nexport function dbDeleteFailedError(err) {\n    err = err ?? new Error('Delete failed');\n    return errCode(err, 'ERR_DB_DELETE_FAILED');\n}\nexport function dbWriteFailedError(err) {\n    err = err ?? new Error('Write failed');\n    return errCode(err, 'ERR_DB_WRITE_FAILED');\n}\nexport function dbReadFailedError(err) {\n    err = err ?? new Error('Read failed');\n    return errCode(err, 'ERR_DB_READ_FAILED');\n}\nexport function notFoundError(err) {\n    err = err ?? new Error('Not Found');\n    return errCode(err, 'ERR_NOT_FOUND');\n}\nexport function abortedError(err) {\n    err = err ?? new Error('Aborted');\n    return errCode(err, 'ERR_ABORTED');\n}\n//# sourceMappingURL=errors.js.map","import { Key } from 'interface-datastore/key';\nimport { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nexport class MemoryDatastore extends BaseDatastore {\n    data;\n    constructor() {\n        super();\n        this.data = new Map();\n    }\n    put(key, val) {\n        this.data.set(key.toString(), val);\n        return key;\n    }\n    get(key) {\n        const result = this.data.get(key.toString());\n        if (result == null) {\n            throw Errors.notFoundError();\n        }\n        return result;\n    }\n    has(key) {\n        return this.data.has(key.toString());\n    }\n    delete(key) {\n        this.data.delete(key.toString());\n    }\n    *_all() {\n        for (const [key, value] of this.data.entries()) {\n            yield { key: new Key(key), value };\n        }\n    }\n    *_allKeys() {\n        for (const key of this.data.keys()) {\n            yield new Key(key);\n        }\n    }\n}\n//# sourceMappingURL=memory.js.map","// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst clearMethods = new WeakMap();\n\nexport function createDelay({clearTimeout: defaultClear, setTimeout: defaultSet} = {}) {\n\t// We cannot use `async` here as we need the promise identity.\n\treturn (milliseconds, {value, signal} = {}) => {\n\t\t// TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(createAbortError());\n\t\t}\n\n\t\tlet timeoutId;\n\t\tlet settle;\n\t\tlet rejectFunction;\n\t\tconst clear = defaultClear ?? clearTimeout;\n\n\t\tconst signalListener = () => {\n\t\t\tclear(timeoutId);\n\t\t\trejectFunction(createAbortError());\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t\t}\n\t\t};\n\n\t\tconst delayPromise = new Promise((resolve, reject) => {\n\t\t\tsettle = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\trejectFunction = reject;\n\t\t\ttimeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n\t\t});\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tclearMethods.set(delayPromise, () => {\n\t\t\tclear(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t});\n\n\t\treturn delayPromise;\n\t};\n}\n\nconst delay = createDelay();\n\nexport default delay;\n\nexport async function rangeDelay(minimum, maximum, options = {}) {\n\treturn delay(randomInteger(minimum, maximum), options);\n}\n\nexport function clearDelay(promise) {\n\tclearMethods.get(promise)?.();\n}\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","export function getIterator(obj) {\n    if (obj != null) {\n        if (typeof obj[Symbol.iterator] === 'function') {\n            return obj[Symbol.iterator]();\n        }\n        if (typeof obj[Symbol.asyncIterator] === 'function') {\n            return obj[Symbol.asyncIterator]();\n        }\n        if (typeof obj.next === 'function') {\n            return obj; // probably an iterator\n        }\n    }\n    throw new Error('argument is not an iterator or iterable');\n}\n//# sourceMappingURL=index.js.map","import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n    _buf;\n    /**\n     * @param {string | Uint8Array} s\n     * @param {boolean} [clean]\n     */\n    constructor(s, clean) {\n        if (typeof s === 'string') {\n            this._buf = uint8ArrayFromString(s);\n        }\n        else if (s instanceof Uint8Array) {\n            this._buf = s;\n        }\n        else {\n            throw new Error('Invalid key, should be String of Uint8Array');\n        }\n        if (clean == null) {\n            clean = true;\n        }\n        if (clean) {\n            this.clean();\n        }\n        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n            throw new Error('Invalid key');\n        }\n    }\n    /**\n     * Convert to the string representation\n     *\n     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n     * @returns {string}\n     */\n    toString(encoding = 'utf8') {\n        return uint8ArrayToString(this._buf, encoding);\n    }\n    /**\n     * Return the Uint8Array representation of the key\n     *\n     * @returns {Uint8Array}\n     */\n    uint8Array() {\n        return this._buf;\n    }\n    /**\n     * Return string representation of the key\n     *\n     * @returns {string}\n     */\n    get [Symbol.toStringTag]() {\n        return `Key(${this.toString()})`;\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list - The array of namespaces\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     * ```\n     */\n    static withNamespaces(list) {\n        return new Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * Key.random()\n     * // => Key('/344502982398')\n     * ```\n     */\n    static random() {\n        return new Key(Math.random().toString().substring(2));\n    }\n    /**\n     * @param {*} other\n     */\n    static asKey(other) {\n        if (other instanceof Uint8Array || typeof other === 'string') {\n            // we can create a key from this\n            return new Key(other);\n        }\n        if (typeof other.uint8Array === 'function') {\n            // this is an older version or may have crossed the esm/cjs boundary\n            return new Key(other.uint8Array());\n        }\n        return null;\n    }\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    clean() {\n        if (this._buf == null || this._buf.byteLength === 0) {\n            this._buf = pathSepB;\n        }\n        if (this._buf[0] !== pathSep) {\n            const bytes = new Uint8Array(this._buf.byteLength + 1);\n            bytes.fill(pathSep, 0, 1);\n            bytes.set(this._buf, 1);\n            this._buf = bytes;\n        }\n        // normalize does not remove trailing slashes\n        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n            this._buf = this._buf.subarray(0, -1);\n        }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key - The other Key to check against\n     * @returns {boolean}\n     */\n    less(key) {\n        const list1 = this.list();\n        const list2 = key.list();\n        for (let i = 0; i < list1.length; i++) {\n            if (list2.length < i + 1) {\n                return false;\n            }\n            const c1 = list1[i];\n            const c2 = list2[i];\n            if (c1 < c2) {\n                return true;\n            }\n            else if (c1 > c2) {\n                return false;\n            }\n        }\n        return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     * ```\n     */\n    reverse() {\n        return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n    namespaces() {\n        return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     * ```\n     */\n    baseNamespace() {\n        const ns = this.namespaces();\n        return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     * ```\n     */\n    list() {\n        return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     * ```\n     */\n    type() {\n        return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     * ```\n     */\n    name() {\n        return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s - The string to append.\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    instance(s) {\n        return new Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     * ```\n     */\n    path() {\n        let p = this.parent().toString();\n        if (!p.endsWith(pathSepS)) {\n            p += pathSepS;\n        }\n        p += this.type();\n        return new Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     * ```\n     */\n    parent() {\n        const list = this.list();\n        if (list.length === 1) {\n            return new Key(pathSepS);\n        }\n        return new Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key - The child Key to add\n     * @returns {Key}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     * ```\n     */\n    child(key) {\n        if (this.toString() === pathSepS) {\n            return key;\n        }\n        else if (key.toString() === pathSepS) {\n            return this;\n        }\n        return new Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other - The other key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     * ```\n     */\n    isAncestorOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other - The other Key to test against\n     * @returns {boolean}\n     *\n     * @example\n     * ```js\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     * ```\n     */\n    isDecendantOf(other) {\n        if (other.toString() === this.toString()) {\n            return false;\n        }\n        return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Checks if this key has only one namespace.\n     *\n     * @returns {boolean}\n     */\n    isTopLevel() {\n        return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys - The array of keys to concatenate\n     * @returns {Key}\n     */\n    concat(...keys) {\n        return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n    }\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType(ns) {\n    const parts = ns.split(':');\n    if (parts.length < 2) {\n        return '';\n    }\n    return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue(ns) {\n    const parts = ns.split(':');\n    return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten(arr) {\n    return ([]).concat(...arr);\n}\n//# sourceMappingURL=key.js.map","/**\n * @packageDocumentation\n *\n * For when you need a one-liner to collect iterable values.\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n *\n * // This can also be an iterator, etc\n * const values = function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = all(values)\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(values())\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction all(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            const arr = [];\n            for await (const entry of source) {\n                arr.push(entry);\n            }\n            return arr;\n        })();\n    }\n    const arr = [];\n    for (const entry of source) {\n        arr.push(entry);\n    }\n    return arr;\n}\nexport default all;\n//# sourceMappingURL=index.js.map","/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n    name = 'UnexpectedEOFError';\n    code = 'ERR_UNEXPECTED_EOF';\n}\n//# sourceMappingURL=errors.js.map","/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive bytes over streams.\n *\n * @example\n *\n * ```typescript\n * import { byteStream } from 'it-byte-stream'\n *\n * const stream = byteStream(duplex)\n *\n * // read the next chunk\n * const bytes = await stream.read()\n *\n * // read the next five bytes\n * const fiveBytes = await stream.read(5)\n *\n * // write bytes into the stream\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n * ```\n */\nimport { queuelessPushable } from 'it-queueless-pushable';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { UnexpectedEOFError } from './errors.js';\n/**\n * @deprecated This will not be exported in a future release\n */\nexport class CodeError extends Error {\n    code;\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\n/**\n * @deprecated This will not be exported in a future release\n */\nexport class AbortError extends CodeError {\n    type;\n    constructor(message) {\n        super(message, 'ABORT_ERR');\n        this.type = 'aborted';\n        this.name = 'AbortError';\n    }\n}\nexport function byteStream(duplex, opts) {\n    const write = queuelessPushable();\n    duplex.sink(write).catch(async (err) => {\n        await write.end(err);\n    });\n    duplex.sink = async (source) => {\n        for await (const buf of source) {\n            await write.push(buf);\n        }\n        await write.end();\n    };\n    let source = duplex.source;\n    if (duplex.source[Symbol.iterator] != null) {\n        source = duplex.source[Symbol.iterator]();\n    }\n    else if (duplex.source[Symbol.asyncIterator] != null) {\n        source = duplex.source[Symbol.asyncIterator]();\n    }\n    const readBuffer = new Uint8ArrayList();\n    const W = {\n        read: async (bytes, options) => {\n            options?.signal?.throwIfAborted();\n            let listener;\n            const abortPromise = new Promise((resolve, reject) => {\n                listener = () => {\n                    reject(new AbortError('Read aborted'));\n                };\n                options?.signal?.addEventListener('abort', listener);\n            });\n            try {\n                if (bytes == null) {\n                    // just read whatever arrives\n                    const { done, value } = await Promise.race([\n                        source.next(),\n                        abortPromise\n                    ]);\n                    if (done === true) {\n                        return new Uint8ArrayList();\n                    }\n                    return value;\n                }\n                while (readBuffer.byteLength < bytes) {\n                    const { value, done } = await Promise.race([\n                        source.next(),\n                        abortPromise\n                    ]);\n                    if (done === true) {\n                        throw new UnexpectedEOFError('unexpected end of input');\n                    }\n                    readBuffer.append(value);\n                }\n                const buf = readBuffer.sublist(0, bytes);\n                readBuffer.consume(bytes);\n                return buf;\n            }\n            finally {\n                if (listener != null) {\n                    options?.signal?.removeEventListener('abort', listener);\n                }\n            }\n        },\n        write: async (data, options) => {\n            options?.signal?.throwIfAborted();\n            // just write\n            if (data instanceof Uint8Array) {\n                await write.push(data, options);\n            }\n            else {\n                await write.push(data.subarray(), options);\n            }\n        },\n        unwrap: () => {\n            if (readBuffer.byteLength > 0) {\n                const originalStream = duplex.source;\n                duplex.source = (async function* () {\n                    if (opts?.yieldBytes === false) {\n                        yield readBuffer;\n                    }\n                    else {\n                        yield* readBuffer;\n                    }\n                    yield* originalStream;\n                }());\n            }\n            return duplex;\n        }\n    };\n    return W;\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction drain(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n        })();\n    }\n    else {\n        for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    }\n}\nexport default drain;\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\nimport peek from 'it-peekable';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction filter(source, fn) {\n    let index = 0;\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const entry of source) {\n                if (await fn(entry, index++)) {\n                    yield entry;\n                }\n            }\n        })();\n    }\n    // if mapping function returns a promise we have to return an async generator\n    const peekable = peek(source);\n    const { value, done } = peekable.next();\n    if (done === true) {\n        return (function* () { }());\n    }\n    const res = fn(value, index++);\n    // @ts-expect-error .then is not present on O\n    if (typeof res.then === 'function') {\n        return (async function* () {\n            if (await res) {\n                yield value;\n            }\n            for await (const entry of peekable) {\n                if (await fn(entry, index++)) {\n                    yield entry;\n                }\n            }\n        })();\n    }\n    const func = fn;\n    return (function* () {\n        if (res === true) {\n            yield value;\n        }\n        for (const entry of peekable) {\n            if (func(entry, index++)) {\n                yield entry;\n            }\n        }\n    })();\n}\nexport default filter;\n//# sourceMappingURL=index.js.map","/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n    name = 'InvalidMessageLengthError';\n    code = 'ERR_INVALID_MSG_LENGTH';\n}\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n    name = 'InvalidDataLengthError';\n    code = 'ERR_MSG_DATA_TOO_LONG';\n}\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n    name = 'InvalidDataLengthLengthError';\n    code = 'ERR_MSG_LENGTH_TOO_LONG';\n}\n//# sourceMappingURL=errors.js.map","/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n *\n * // write several chunks, all individually length-prefixed\n * await stream.writeV([\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ])\n * ```\n */\nimport { byteStream } from 'it-byte-stream';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError } from './errors.js';\nexport function lpStream(duplex, opts = {}) {\n    const bytes = byteStream(duplex, opts);\n    if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n        // if max data length is set but max length length is not, calculate the\n        // max length length needed to encode max data length\n        opts.maxLengthLength = varint.encodingLength(opts.maxDataLength);\n    }\n    const decodeLength = opts?.lengthDecoder ?? varint.decode;\n    const encodeLength = opts?.lengthEncoder ?? varint.encode;\n    const W = {\n        read: async (options) => {\n            let dataLength = -1;\n            const lengthBuffer = new Uint8ArrayList();\n            while (true) {\n                // read one byte at a time until we can decode a varint\n                lengthBuffer.append(await bytes.read(1, options));\n                try {\n                    dataLength = decodeLength(lengthBuffer);\n                }\n                catch (err) {\n                    if (err instanceof RangeError) {\n                        continue;\n                    }\n                    throw err;\n                }\n                if (dataLength < 0) {\n                    throw new InvalidMessageLengthError('Invalid message length');\n                }\n                if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n                    throw new InvalidDataLengthLengthError('message length length too long');\n                }\n                if (dataLength > -1) {\n                    break;\n                }\n            }\n            if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n                throw new InvalidDataLengthError('message length too long');\n            }\n            return bytes.read(dataLength, options);\n        },\n        write: async (data, options) => {\n            // encode, write\n            await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options);\n        },\n        writeV: async (data, options) => {\n            const list = new Uint8ArrayList(...data.flatMap(buf => ([encodeLength(buf.byteLength), buf])));\n            // encode, write\n            await bytes.write(list, options);\n        },\n        unwrap: () => {\n            return bytes.unwrap();\n        }\n    };\n    return W;\n}\n//# sourceMappingURL=index.js.map","/* eslint max-depth: [\"error\", 6] */\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError, UnexpectedEOFError } from './errors.js';\nimport { isAsyncIterable } from './utils.js';\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n    ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n    ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = (buf) => {\n    const length = varint.decode(buf);\n    defaultDecoder.bytes = varint.encodingLength(length);\n    return length;\n};\ndefaultDecoder.bytes = 0;\nexport function decode(source, options) {\n    const buffer = new Uint8ArrayList();\n    let mode = ReadMode.LENGTH;\n    let dataLength = -1;\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n    function* maybeYield() {\n        while (buffer.byteLength > 0) {\n            if (mode === ReadMode.LENGTH) {\n                // read length, ignore errors for short reads\n                try {\n                    dataLength = lengthDecoder(buffer);\n                    if (dataLength < 0) {\n                        throw new InvalidMessageLengthError('Invalid message length');\n                    }\n                    if (dataLength > maxDataLength) {\n                        throw new InvalidDataLengthError('Message length too long');\n                    }\n                    const dataLengthLength = lengthDecoder.bytes;\n                    buffer.consume(dataLengthLength);\n                    if (options?.onLength != null) {\n                        options.onLength(dataLength);\n                    }\n                    mode = ReadMode.DATA;\n                }\n                catch (err) {\n                    if (err instanceof RangeError) {\n                        if (buffer.byteLength > maxLengthLength) {\n                            throw new InvalidDataLengthLengthError('Message length length too long');\n                        }\n                        break;\n                    }\n                    throw err;\n                }\n            }\n            if (mode === ReadMode.DATA) {\n                if (buffer.byteLength < dataLength) {\n                    // not enough data, wait for more\n                    break;\n                }\n                const data = buffer.sublist(0, dataLength);\n                buffer.consume(dataLength);\n                if (options?.onData != null) {\n                    options.onData(data);\n                }\n                yield data;\n                mode = ReadMode.LENGTH;\n            }\n        }\n    }\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const buf of source) {\n                buffer.append(buf);\n                yield* maybeYield();\n            }\n            if (buffer.byteLength > 0) {\n                throw new UnexpectedEOFError('Unexpected end of input');\n            }\n        })();\n    }\n    return (function* () {\n        for (const buf of source) {\n            buffer.append(buf);\n            yield* maybeYield();\n        }\n        if (buffer.byteLength > 0) {\n            throw new UnexpectedEOFError('Unexpected end of input');\n        }\n    })();\n}\ndecode.fromReader = (reader, options) => {\n    let byteLength = 1; // Read single byte chunks until the length is known\n    const varByteSource = (async function* () {\n        while (true) {\n            try {\n                const { done, value } = await reader.next(byteLength);\n                if (done === true) {\n                    return;\n                }\n                if (value != null) {\n                    yield value;\n                }\n            }\n            catch (err) {\n                if (err.code === 'ERR_UNDER_READ') {\n                    return { done: true, value: null };\n                }\n                throw err;\n            }\n            finally {\n                // Reset the byteLength so we continue to check for varints\n                byteLength = 1;\n            }\n        }\n    }());\n    /**\n     * Once the length has been parsed, read chunk for that length\n     */\n    const onLength = (l) => { byteLength = l; };\n    return decode(varByteSource, {\n        ...(options ?? {}),\n        onLength\n    });\n};\n//# sourceMappingURL=decode.js.map","import * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nimport { isAsyncIterable } from './utils.js';\nconst defaultEncoder = (length) => {\n    const lengthLength = varint.encodingLength(length);\n    const lengthBuf = allocUnsafe(lengthLength);\n    varint.encode(length, lengthBuf);\n    defaultEncoder.bytes = lengthLength;\n    return lengthBuf;\n};\ndefaultEncoder.bytes = 0;\nexport function encode(source, options) {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    function* maybeYield(chunk) {\n        // length + data\n        const length = encodeLength(chunk.byteLength);\n        // yield only Uint8Arrays\n        if (length instanceof Uint8Array) {\n            yield length;\n        }\n        else {\n            yield* length;\n        }\n        // yield only Uint8Arrays\n        if (chunk instanceof Uint8Array) {\n            yield chunk;\n        }\n        else {\n            yield* chunk;\n        }\n    }\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const chunk of source) {\n                yield* maybeYield(chunk);\n            }\n        })();\n    }\n    return (function* () {\n        for (const chunk of source) {\n            yield* maybeYield(chunk);\n        }\n    })();\n}\nencode.single = (chunk, options) => {\n    options = options ?? {};\n    const encodeLength = options.lengthEncoder ?? defaultEncoder;\n    return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);\n};\n//# sourceMappingURL=encode.js.map","/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n    name = 'InvalidMessageLengthError';\n    code = 'ERR_INVALID_MSG_LENGTH';\n}\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n    name = 'InvalidDataLengthError';\n    code = 'ERR_MSG_DATA_TOO_LONG';\n}\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n    name = 'InvalidDataLengthLengthError';\n    code = 'ERR_MSG_LENGTH_TOO_LONG';\n}\n/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n    name = 'UnexpectedEOFError';\n    code = 'ERR_UNEXPECTED_EOF';\n}\n//# sourceMappingURL=errors.js.map","/**\n * @packageDocumentation\n *\n * Encode/decode streams of bytes with length-prefixes.\n *\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as lp from 'it-length-prefixed'\n *\n * const encoded = []\n *\n * // encode\n * await pipe(\n *   [uint8ArrayFromString('hello world')],\n *   (source) => lp.encode(source),\n *   async source => {\n *     for await (const chunk of source) {\n *       encoded.push(chunk.slice()) // (.slice converts Uint8ArrayList to Uint8Array)\n *     }\n *   }\n * )\n *\n * console.log(encoded)\n * // => [Buffer <0b 68 65 6c 6c 6f 20 77 6f 72 6c 64>]\n *\n * const decoded = []\n *\n * // decode\n * await pipe(\n *   encoded, // e.g. from above\n *   (source) => lp.decode(source),\n *   async source => {\n *     for await (const chunk of source) {\n *       decoded.push(chunk.slice()) // (.slice converts Uint8ArrayList to Uint8Array)\n *     }\n *   }\n * )\n *\n * console.log(decoded)\n * // => [Buffer <68 65 6c 6c 6f 20 77 6f 72 6c 64>]\n * ```\n */\nexport { encode } from './encode.js';\nexport { decode } from './decode.js';\n//# sourceMappingURL=index.js.map","export function isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\n//# sourceMappingURL=utils.js.map","/**\n * @packageDocumentation\n *\n * Counts the number of items in an (async)iterable.\n *\n * N.b. will consume the iterable\n *\n * @example\n *\n * ```javascript\n * import length from 'it-length'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = length(values)\n *\n * console.info(res) // 5\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import length from 'it-length'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await length(values())\n *\n * console.info(res) // 5\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction length(source) {\n    if (isAsyncIterable(source)) {\n        return (async () => {\n            let count = 0;\n            for await (const _ of source) { // eslint-disable-line no-unused-vars,@typescript-eslint/no-unused-vars\n                count++;\n            }\n            return count;\n        })();\n    }\n    else {\n        let count = 0;\n        for (const _ of source) { // eslint-disable-line no-unused-vars,@typescript-eslint/no-unused-vars\n            count++;\n        }\n        return count;\n    }\n}\nexport default length;\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Convert one value from an (async)iterator into another.\n *\n * @example\n *\n * ```javascript\n * import map from 'it-map'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const result = map(values, (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n *\n * Async sources and transforms must be awaited:\n *\n * ```javascript\n * import map from 'it-map'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const result = await map(values(), async (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n */\nimport peek from 'it-peekable';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction map(source, func) {\n    let index = 0;\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            for await (const val of source) {\n                yield func(val, index++);\n            }\n        })();\n    }\n    // if mapping function returns a promise we have to return an async generator\n    const peekable = peek(source);\n    const { value, done } = peekable.next();\n    if (done === true) {\n        return (function* () { }());\n    }\n    const res = func(value, index++);\n    // @ts-expect-error .then is not present on O\n    if (typeof res.then === 'function') {\n        return (async function* () {\n            yield await res;\n            for await (const val of peekable) {\n                yield func(val, index++);\n            }\n        })();\n    }\n    const fn = func;\n    return (function* () {\n        yield res;\n        for (const val of peekable) {\n            yield fn(val, index++);\n        }\n    })();\n}\nexport default map;\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\nimport { pushable } from 'it-pushable';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction merge(...sources) {\n    const syncSources = [];\n    for (const source of sources) {\n        if (!isAsyncIterable(source)) {\n            syncSources.push(source);\n        }\n    }\n    if (syncSources.length === sources.length) {\n        // all sources are synchronous\n        return (function* () {\n            for (const source of syncSources) {\n                yield* source;\n            }\n        })();\n    }\n    return (async function* () {\n        const output = pushable({\n            objectMode: true\n        });\n        void Promise.resolve().then(async () => {\n            try {\n                await Promise.all(sources.map(async (source) => {\n                    for await (const item of source) {\n                        output.push(item);\n                    }\n                }));\n                output.end();\n            }\n            catch (err) {\n                output.end(err);\n            }\n        });\n        yield* output;\n    })();\n}\nexport default merge;\n//# sourceMappingURL=index.js.map","import { pair } from './index.js';\n/**\n * Two duplex streams that are attached to each other\n */\nexport function duplexPair() {\n    const a = pair();\n    const b = pair();\n    return [\n        {\n            source: a.source,\n            sink: b.sink\n        },\n        {\n            source: b.source,\n            sink: a.sink\n        }\n    ];\n}\n//# sourceMappingURL=duplex.js.map","import defer from 'p-defer';\n/**\n * A pair of streams where one drains from the other\n */\nexport function pair() {\n    const deferred = defer();\n    let piped = false;\n    return {\n        sink: async (source) => {\n            if (piped) {\n                throw new Error('already piped');\n            }\n            piped = true;\n            deferred.resolve(source);\n        },\n        source: (async function* () {\n            const source = await deferred.promise;\n            yield* source;\n        }())\n    };\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\nimport defer from 'p-defer';\nconst CustomEvent = globalThis.CustomEvent ?? Event;\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function* parallel(source, options = {}) {\n    let concurrency = options.concurrency ?? Infinity;\n    if (concurrency < 1) {\n        concurrency = Infinity;\n    }\n    const ordered = options.ordered == null ? false : options.ordered;\n    const emitter = new EventTarget();\n    const ops = [];\n    let slotAvailable = defer();\n    let resultAvailable = defer();\n    let sourceFinished = false;\n    let sourceErr;\n    let opErred = false;\n    emitter.addEventListener('task-complete', () => {\n        resultAvailable.resolve();\n    });\n    void Promise.resolve().then(async () => {\n        try {\n            for await (const task of source) {\n                if (ops.length === concurrency) {\n                    slotAvailable = defer();\n                    await slotAvailable.promise;\n                }\n                if (opErred) {\n                    break;\n                }\n                const op = {\n                    done: false\n                };\n                ops.push(op);\n                task()\n                    .then(result => {\n                    op.done = true;\n                    op.ok = true;\n                    op.value = result;\n                    emitter.dispatchEvent(new CustomEvent('task-complete'));\n                }, err => {\n                    op.done = true;\n                    op.err = err;\n                    emitter.dispatchEvent(new CustomEvent('task-complete'));\n                });\n            }\n            sourceFinished = true;\n            emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }\n        catch (err) {\n            sourceErr = err;\n            emitter.dispatchEvent(new CustomEvent('task-complete'));\n        }\n    });\n    function valuesAvailable() {\n        if (ordered) {\n            return ops[0]?.done;\n        }\n        return Boolean(ops.find(op => op.done));\n    }\n    function* yieldOrderedValues() {\n        while ((ops.length > 0) && ops[0].done) {\n            const op = ops[0];\n            ops.shift();\n            if (op.ok) {\n                yield op.value;\n            }\n            else {\n                // allow the source to exit\n                opErred = true;\n                slotAvailable.resolve();\n                throw op.err;\n            }\n            slotAvailable.resolve();\n        }\n    }\n    function* yieldUnOrderedValues() {\n        // more values can become available while we wait for `yield`\n        // to return control to this function\n        while (valuesAvailable()) {\n            for (let i = 0; i < ops.length; i++) {\n                if (ops[i].done) {\n                    const op = ops[i];\n                    ops.splice(i, 1);\n                    i--;\n                    if (op.ok) {\n                        yield op.value;\n                    }\n                    else {\n                        opErred = true;\n                        slotAvailable.resolve();\n                        throw op.err;\n                    }\n                    slotAvailable.resolve();\n                }\n            }\n        }\n    }\n    while (true) {\n        if (!valuesAvailable()) {\n            resultAvailable = defer();\n            await resultAvailable.promise;\n        }\n        if (sourceErr != null) {\n            // the source threw an error, propagate it\n            throw sourceErr;\n        }\n        if (ordered) {\n            yield* yieldOrderedValues();\n        }\n        else {\n            yield* yieldUnOrderedValues();\n        }\n        if (sourceFinished && ops.length === 0) {\n            // not waiting for any results and no more tasks so we are done\n            break;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\nfunction peekable(iterable) {\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n        // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n        ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n        // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n        : [iterable[Symbol.iterator](), Symbol.iterator];\n    const queue = [];\n    // @ts-expect-error can't use symbol to index peekable\n    return {\n        peek: () => {\n            return iterator.next();\n        },\n        push: (value) => {\n            queue.push(value);\n        },\n        next: () => {\n            if (queue.length > 0) {\n                return {\n                    done: false,\n                    value: queue.shift()\n                };\n            }\n            return iterator.next();\n        },\n        [symbol]() {\n            return this;\n        }\n    };\n}\nexport default peekable;\n//# sourceMappingURL=index.js.map","import { pushable } from 'it-pushable';\nimport merge from 'it-merge';\nexport function pipe(first, ...rest) {\n    if (first == null) {\n        throw new Error('Empty pipeline');\n    }\n    // Duplex at start: wrap in function and return duplex source\n    if (isDuplex(first)) {\n        const duplex = first;\n        first = () => duplex.source;\n        // Iterable at start: wrap in function\n    }\n    else if (isIterable(first) || isAsyncIterable(first)) {\n        const source = first;\n        first = () => source;\n    }\n    const fns = [first, ...rest];\n    if (fns.length > 1) {\n        // Duplex at end: use duplex sink\n        if (isDuplex(fns[fns.length - 1])) {\n            fns[fns.length - 1] = fns[fns.length - 1].sink;\n        }\n    }\n    if (fns.length > 2) {\n        // Duplex in the middle, consume source with duplex sink and return duplex source\n        for (let i = 1; i < fns.length - 1; i++) {\n            if (isDuplex(fns[i])) {\n                fns[i] = duplexPipelineFn(fns[i]);\n            }\n        }\n    }\n    return rawPipe(...fns);\n}\nexport const rawPipe = (...fns) => {\n    let res;\n    while (fns.length > 0) {\n        res = fns.shift()(res);\n    }\n    return res;\n};\nconst isAsyncIterable = (obj) => {\n    return obj?.[Symbol.asyncIterator] != null;\n};\nconst isIterable = (obj) => {\n    return obj?.[Symbol.iterator] != null;\n};\nconst isDuplex = (obj) => {\n    if (obj == null) {\n        return false;\n    }\n    return obj.sink != null && obj.source != null;\n};\nconst duplexPipelineFn = (duplex) => {\n    return (source) => {\n        const p = duplex.sink(source);\n        if (p?.then != null) {\n            const stream = pushable({\n                objectMode: true\n            });\n            p.then(() => {\n                stream.end();\n            }, (err) => {\n                stream.end(err);\n            });\n            let sourceWrap;\n            const source = duplex.source;\n            if (isAsyncIterable(source)) {\n                sourceWrap = async function* () {\n                    yield* source;\n                    stream.end();\n                };\n            }\n            else if (isIterable(source)) {\n                sourceWrap = function* () {\n                    yield* source;\n                    stream.end();\n                };\n            }\n            else {\n                throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable');\n            }\n            return merge(stream, sourceWrap());\n        }\n        return duplex.source;\n    };\n};\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed Protobuf encoded\n * messages over streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-protobuf-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n *\n * // write a message to the stream\n * stream.write({\n *   foo: 'bar'\n * }, MessageType)\n *\n * // read a message from the stream\n * const res = await stream.read(MessageType)\n * ```\n */\nimport { lpStream } from 'it-length-prefixed-stream';\nexport function pbStream(duplex, opts) {\n    const lp = lpStream(duplex, opts);\n    const W = {\n        read: async (proto, options) => {\n            // readLP, decode\n            const value = await lp.read(options);\n            return proto.decode(value);\n        },\n        write: async (message, proto, options) => {\n            // encode, writeLP\n            await lp.write(proto.encode(message), options);\n        },\n        writeV: async (messages, proto, options) => {\n            // encode, writeLP\n            await lp.writeV(messages.map(message => proto.encode(message)), options);\n        },\n        pb: (proto) => {\n            return {\n                read: async (options) => W.read(proto, options),\n                write: async (d, options) => W.write(d, proto, options),\n                writeV: async (d, options) => W.writeV(d, proto, options),\n                unwrap: () => W\n            };\n        },\n        unwrap: () => {\n            return lp.unwrap();\n        }\n    };\n    return W;\n}\n//# sourceMappingURL=index.js.map","// ported from https://www.npmjs.com/package/fast-fifo\nclass FixedFIFO {\n    buffer;\n    mask;\n    top;\n    btm;\n    next;\n    constructor(hwm) {\n        if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n            throw new Error('Max size for a FixedFIFO should be a power of two');\n        }\n        this.buffer = new Array(hwm);\n        this.mask = hwm - 1;\n        this.top = 0;\n        this.btm = 0;\n        this.next = null;\n    }\n    push(data) {\n        if (this.buffer[this.top] !== undefined) {\n            return false;\n        }\n        this.buffer[this.top] = data;\n        this.top = (this.top + 1) & this.mask;\n        return true;\n    }\n    shift() {\n        const last = this.buffer[this.btm];\n        if (last === undefined) {\n            return undefined;\n        }\n        this.buffer[this.btm] = undefined;\n        this.btm = (this.btm + 1) & this.mask;\n        return last;\n    }\n    isEmpty() {\n        return this.buffer[this.btm] === undefined;\n    }\n}\nexport class FIFO {\n    size;\n    hwm;\n    head;\n    tail;\n    constructor(options = {}) {\n        this.hwm = options.splitLimit ?? 16;\n        this.head = new FixedFIFO(this.hwm);\n        this.tail = this.head;\n        this.size = 0;\n    }\n    calculateSize(obj) {\n        if (obj?.byteLength != null) {\n            return obj.byteLength;\n        }\n        return 1;\n    }\n    push(val) {\n        if (val?.value != null) {\n            this.size += this.calculateSize(val.value);\n        }\n        if (!this.head.push(val)) {\n            const prev = this.head;\n            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);\n            this.head.push(val);\n        }\n    }\n    shift() {\n        let val = this.tail.shift();\n        if (val === undefined && (this.tail.next != null)) {\n            const next = this.tail.next;\n            this.tail.next = null;\n            this.tail = next;\n            val = this.tail.shift();\n        }\n        if (val?.value != null) {\n            this.size -= this.calculateSize(val.value);\n        }\n        return val;\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n}\n//# sourceMappingURL=fifo.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport deferred from 'p-defer';\nimport { FIFO } from './fifo.js';\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error if done is false, value will be present\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error if done is false value should be pushed\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    let drain = deferred();\n    const waitNext = async () => {\n        try {\n            if (!buffer.isEmpty()) {\n                return getNext(buffer);\n            }\n            if (ended) {\n                return { done: true };\n            }\n            return await new Promise((resolve, reject) => {\n                onNext = (next) => {\n                    onNext = null;\n                    buffer.push(next);\n                    try {\n                        resolve(getNext(buffer));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    return pushable;\n                };\n            });\n        }\n        finally {\n            if (buffer.isEmpty()) {\n                // settle promise in the microtask queue to give consumers a chance to\n                // await after calling .push\n                queueMicrotask(() => {\n                    drain.resolve();\n                    drain = deferred();\n                });\n            }\n        }\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        },\n        onEmpty: async (options) => {\n            const signal = options?.signal;\n            signal?.throwIfAborted();\n            if (buffer.isEmpty()) {\n                return;\n            }\n            let cancel;\n            let listener;\n            if (signal != null) {\n                cancel = new Promise((resolve, reject) => {\n                    listener = () => {\n                        reject(new AbortError());\n                    };\n                    signal.addEventListener('abort', listener);\n                });\n            }\n            try {\n                await Promise.race([\n                    drain.promise,\n                    cancel\n                ]);\n            }\n            finally {\n                if (listener != null && signal != null) {\n                    signal?.removeEventListener('abort', listener);\n                }\n            }\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        },\n        onEmpty: (opts) => {\n            return _pushable.onEmpty(opts);\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\nimport deferred, {} from 'p-defer';\nimport { raceSignal } from 'race-signal';\nclass QueuelessPushable {\n    readNext;\n    haveNext;\n    ended;\n    nextResult;\n    constructor() {\n        this.ended = false;\n        this.readNext = deferred();\n        this.haveNext = deferred();\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    async next() {\n        if (this.nextResult == null) {\n            // wait for the supplier to push a value\n            await this.haveNext.promise;\n        }\n        if (this.nextResult == null) {\n            throw new Error('HaveNext promise resolved but nextResult was undefined');\n        }\n        const nextResult = this.nextResult;\n        this.nextResult = undefined;\n        // signal to the supplier that we read the value\n        this.readNext.resolve();\n        this.readNext = deferred();\n        return nextResult;\n    }\n    async throw(err) {\n        this.ended = true;\n        if (err != null) {\n            // this can cause unhandled promise rejections if nothing is awaiting the\n            // next value so attach a dummy catch listener to the promise\n            this.haveNext.promise.catch(() => { });\n            this.haveNext.reject(err);\n        }\n        const result = {\n            done: true,\n            value: undefined\n        };\n        return result;\n    }\n    async return() {\n        const result = {\n            done: true,\n            value: undefined\n        };\n        await this._push(undefined);\n        return result;\n    }\n    async push(value, options) {\n        await this._push(value, options);\n    }\n    async end(err, options) {\n        if (err != null) {\n            await this.throw(err);\n        }\n        else {\n            // abortable return\n            await this._push(undefined, options);\n        }\n    }\n    async _push(value, options) {\n        if (value != null && this.ended) {\n            throw new Error('Cannot push value onto an ended pushable');\n        }\n        // wait for all values to be read\n        while (this.nextResult != null) {\n            await this.readNext.promise;\n        }\n        if (value != null) {\n            this.nextResult = { done: false, value };\n        }\n        else {\n            this.ended = true;\n            this.nextResult = { done: true, value: undefined };\n        }\n        // let the consumer know we have a new value\n        this.haveNext.resolve();\n        this.haveNext = deferred();\n        // wait for the consumer to have finished processing the value and requested\n        // the next one or for the passed signal to abort the waiting\n        await raceSignal(this.readNext.promise, options?.signal, options);\n    }\n}\nexport function queuelessPushable() {\n    return new QueuelessPushable();\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\nimport all from 'it-all';\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction sort(source, sorter) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            const arr = await all(source);\n            yield* arr.sort(sorter);\n        })();\n    }\n    return (function* () {\n        const arr = all(source);\n        yield* arr.sort(sorter);\n    })();\n}\nexport default sort;\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\nfunction isAsyncIterable(thing) {\n    return thing[Symbol.asyncIterator] != null;\n}\nfunction take(source, limit) {\n    if (isAsyncIterable(source)) {\n        return (async function* () {\n            let items = 0;\n            if (limit < 1) {\n                return;\n            }\n            for await (const entry of source) {\n                yield entry;\n                items++;\n                if (items === limit) {\n                    return;\n                }\n            }\n        })();\n    }\n    return (function* () {\n        let items = 0;\n        if (limit < 1) {\n            return;\n        }\n        for (const entry of source) {\n            yield entry;\n            items++;\n            if (items === limit) {\n                return;\n            }\n        }\n    })();\n}\nexport default take;\n//# sourceMappingURL=index.js.map","// load websocket library if we are not in the browser\nimport duplex from './duplex.js';\nimport WebSocket from './web-socket.js';\nimport wsurl from './ws-url.js';\nexport function connect(addr, opts) {\n    const location = typeof window === 'undefined' ? undefined : window.location;\n    opts = opts ?? {};\n    const url = wsurl(addr, location);\n    // it's necessary to stringify the URL object otherwise react-native crashes\n    const socket = new WebSocket(url.toString(), opts.websocket);\n    return duplex(socket, opts);\n}\n//# sourceMappingURL=client.js.map","import sink from './sink.js';\nimport source from './source.js';\nexport default (socket, options) => {\n    options = options ?? {};\n    const connectedSource = source(socket);\n    let remoteAddress = options.remoteAddress;\n    let remotePort = options.remotePort;\n    if (socket.url != null) {\n        // only client->server sockets have urls, server->client connections do not\n        try {\n            const url = new URL(socket.url);\n            remoteAddress = url.hostname;\n            remotePort = parseInt(url.port, 10);\n        }\n        catch { }\n    }\n    if (remoteAddress == null || remotePort == null) {\n        throw new Error('Remote connection did not have address and/or port');\n    }\n    const duplex = {\n        sink: sink(socket, options),\n        source: connectedSource,\n        connected: async () => { await connectedSource.connected(); },\n        close: async () => {\n            if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {\n                await new Promise((resolve) => {\n                    socket.addEventListener('close', () => {\n                        resolve();\n                    });\n                    socket.close();\n                });\n            }\n        },\n        destroy: () => {\n            if (socket.terminate != null) {\n                socket.terminate();\n            }\n            else {\n                socket.close();\n            }\n        },\n        remoteAddress,\n        remotePort,\n        socket\n    };\n    return duplex;\n};\n//# sourceMappingURL=duplex.js.map","export default async (socket) => {\n    // if the socket is closing or closed, return end\n    if (socket.readyState >= 2) {\n        throw new Error('socket closed');\n    }\n    // if open, return\n    if (socket.readyState === 1) {\n        return;\n    }\n    await new Promise((resolve, reject) => {\n        function cleanup() {\n            socket.removeEventListener('open', handleOpen);\n            socket.removeEventListener('error', handleErr);\n        }\n        function handleOpen() {\n            cleanup();\n            resolve();\n        }\n        function handleErr(event) {\n            cleanup();\n            reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));\n        }\n        socket.addEventListener('open', handleOpen);\n        socket.addEventListener('error', handleErr);\n    });\n};\n//# sourceMappingURL=ready.js.map","import ready from './ready.js';\nexport default (socket, options) => {\n    options = options ?? {};\n    options.closeOnEnd = options.closeOnEnd !== false;\n    const sink = async (source) => {\n        for await (const data of source) {\n            try {\n                await ready(socket);\n            }\n            catch (err) {\n                if (err.message === 'socket closed')\n                    break;\n                throw err;\n            }\n            // the ready promise resolved without error but the socket was closing so\n            // exit the loop and don't send data\n            if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {\n                break;\n            }\n            socket.send(data);\n        }\n        if (options.closeOnEnd != null && socket.readyState <= 1) {\n            await new Promise((resolve, reject) => {\n                socket.addEventListener('close', event => {\n                    if (event.wasClean || event.code === 1006) {\n                        resolve();\n                    }\n                    else {\n                        const err = Object.assign(new Error('ws error'), { event });\n                        reject(err);\n                    }\n                });\n                setTimeout(() => { socket.close(); });\n            });\n        }\n    };\n    return sink;\n};\n//# sourceMappingURL=sink.js.map","import { EventIterator } from 'event-iterator';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\n// copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\nfunction isArrayBuffer(obj) {\n    return (obj instanceof ArrayBuffer) ||\n        (obj?.constructor?.name === 'ArrayBuffer' && typeof obj?.byteLength === 'number');\n}\nexport default (socket) => {\n    socket.binaryType = 'arraybuffer';\n    const connected = async () => {\n        await new Promise((resolve, reject) => {\n            if (isConnected) {\n                resolve();\n                return;\n            }\n            if (connError != null) {\n                reject(connError);\n                return;\n            }\n            const cleanUp = (cont) => {\n                socket.removeEventListener('open', onOpen);\n                socket.removeEventListener('error', onError);\n                cont();\n            };\n            const onOpen = () => { cleanUp(resolve); };\n            const onError = (event) => {\n                cleanUp(() => { reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)); });\n            };\n            socket.addEventListener('open', onOpen);\n            socket.addEventListener('error', onError);\n        });\n    };\n    const source = (async function* () {\n        const messages = new EventIterator(({ push, stop, fail }) => {\n            const onMessage = (event) => {\n                let data = null;\n                if (typeof event.data === 'string') {\n                    data = uint8ArrayFromString(event.data);\n                }\n                if (isArrayBuffer(event.data)) {\n                    data = new Uint8Array(event.data);\n                }\n                if (event.data instanceof Uint8Array) {\n                    data = event.data;\n                }\n                if (data == null) {\n                    return;\n                }\n                push(data);\n            };\n            const onError = (event) => { fail(event.error ?? new Error('Socket error')); };\n            socket.addEventListener('message', onMessage);\n            socket.addEventListener('error', onError);\n            socket.addEventListener('close', stop);\n            return () => {\n                socket.removeEventListener('message', onMessage);\n                socket.removeEventListener('error', onError);\n                socket.removeEventListener('close', stop);\n            };\n        }, { highWaterMark: Infinity });\n        await connected();\n        for await (const chunk of messages) {\n            yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;\n        }\n    }());\n    let isConnected = socket.readyState === 1;\n    let connError;\n    socket.addEventListener('open', () => {\n        isConnected = true;\n        connError = null;\n    });\n    socket.addEventListener('close', () => {\n        isConnected = false;\n        connError = null;\n    });\n    socket.addEventListener('error', event => {\n        if (!isConnected) {\n            connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);\n        }\n    });\n    return Object.assign(source, {\n        connected\n    });\n};\n//# sourceMappingURL=source.js.map","/* eslint-env browser */\nexport default WebSocket;\n//# sourceMappingURL=web-socket.browser.js.map","const map = { 'http:': 'ws:', 'https:': 'wss:' };\nconst defaultProtocol = 'ws:';\nexport default (url, location) => {\n    if (url.startsWith('//')) {\n        url = `${location?.protocol ?? defaultProtocol}${url}`;\n    }\n    if (url.startsWith('/') && location != null) {\n        const proto = location.protocol ?? defaultProtocol;\n        const host = location.host;\n        const port = location.port != null && host?.endsWith(`:${location.port}`) !== true ? `:${location.port}` : '';\n        url = `${proto}//${host}${port}${url}`;\n    }\n    const wsUrl = new URL(url);\n    for (const [httpProto, wsProto] of Object.entries(map)) {\n        if (wsUrl.protocol === httpProto) {\n            wsUrl.protocol = wsProto;\n        }\n    }\n    return wsUrl;\n};\n//# sourceMappingURL=ws-url.js.map","import { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { debounce } from './utils.js';\nconst defaultAddressFilter = (addrs) => addrs;\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId(ma, peerId) {\n    const observedPeerIdStr = ma.getPeerId();\n    // strip our peer id if it has been passed\n    if (observedPeerIdStr != null) {\n        const observedPeerId = peerIdFromString(observedPeerIdStr);\n        // use same encoding for comparison\n        if (observedPeerId.equals(peerId)) {\n            ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));\n        }\n    }\n    return ma;\n}\nexport class DefaultAddressManager {\n    log;\n    components;\n    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n    listen;\n    announce;\n    observed;\n    announceFilter;\n    /**\n     * Responsible for managing the peer addresses.\n     * Peers can specify their listen and announce addresses.\n     * The listen addresses will be used by the libp2p transports to listen for new connections,\n     * while the announce addresses will be used for the peer addresses' to other peers in the network.\n     */\n    constructor(components, init = {}) {\n        const { listen = [], announce = [] } = init;\n        this.components = components;\n        this.log = components.logger.forComponent('libp2p:address-manager');\n        this.listen = listen.map(ma => ma.toString());\n        this.announce = new Set(announce.map(ma => ma.toString()));\n        this.observed = new Map();\n        this.announceFilter = init.announceFilter ?? defaultAddressFilter;\n        // this method gets called repeatedly on startup when transports start listening so\n        // debounce it so we don't cause multiple self:peer:update events to be emitted\n        this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000);\n        // update our stored addresses when new transports listen\n        components.events.addEventListener('transport:listening', () => {\n            this._updatePeerStoreAddresses();\n        });\n        // update our stored addresses when existing transports stop listening\n        components.events.addEventListener('transport:close', () => {\n            this._updatePeerStoreAddresses();\n        });\n    }\n    [Symbol.toStringTag] = '@libp2p/address-manager';\n    _updatePeerStoreAddresses() {\n        // if announce addresses have been configured, ensure they make it into our peer\n        // record for things like identify\n        const addrs = this.getAnnounceAddrs()\n            .concat(this.components.transportManager.getAddrs())\n            .concat([...this.observed.entries()]\n            .filter(([_, metadata]) => metadata.confident)\n            .map(([str]) => multiaddr(str))).map(ma => {\n            // strip our peer id if it is present\n            if (ma.getPeerId() === this.components.peerId.toString()) {\n                return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);\n            }\n            return ma;\n        });\n        this.components.peerStore.patch(this.components.peerId, {\n            multiaddrs: addrs\n        })\n            .catch(err => { this.log.error('error updating addresses', err); });\n    }\n    /**\n     * Get peer listen multiaddrs\n     */\n    getListenAddrs() {\n        return Array.from(this.listen).map((a) => multiaddr(a));\n    }\n    /**\n     * Get peer announcing multiaddrs\n     */\n    getAnnounceAddrs() {\n        return Array.from(this.announce).map((a) => multiaddr(a));\n    }\n    /**\n     * Get observed multiaddrs\n     */\n    getObservedAddrs() {\n        return Array.from(this.observed).map(([a]) => multiaddr(a));\n    }\n    /**\n     * Add peer observed addresses\n     */\n    addObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        // do not trigger the change:addresses event if we already know about this address\n        if (this.observed.has(addrString)) {\n            return;\n        }\n        this.observed.set(addrString, {\n            confident: false\n        });\n    }\n    confirmObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        const metadata = this.observed.get(addrString) ?? {\n            confident: false\n        };\n        const startingConfidence = metadata.confident;\n        this.observed.set(addrString, {\n            confident: true\n        });\n        // only trigger the 'self:peer:update' event if our confidence in an address has changed\n        if (!startingConfidence) {\n            this._updatePeerStoreAddresses();\n        }\n    }\n    removeObservedAddr(addr) {\n        addr = stripPeerId(addr, this.components.peerId);\n        const addrString = addr.toString();\n        this.observed.delete(addrString);\n    }\n    getAddresses() {\n        let addrs = this.getAnnounceAddrs().map(ma => ma.toString());\n        if (addrs.length === 0) {\n            // no configured announce addrs, add configured listen addresses\n            addrs = this.components.transportManager.getAddrs().map(ma => ma.toString());\n        }\n        // add observed addresses we are confident in\n        addrs = addrs.concat(Array.from(this.observed)\n            .filter(([ma, metadata]) => metadata.confident)\n            .map(([ma]) => ma));\n        // dedupe multiaddrs\n        const addrSet = new Set(addrs);\n        // Create advertising list\n        return this.announceFilter(Array.from(addrSet)\n            .map(str => multiaddr(str)))\n            .map(ma => {\n            // do not append our peer id to a path multiaddr as it will become invalid\n            if (ma.protos().pop()?.path === true) {\n                return ma;\n            }\n            if (ma.getPeerId() === this.components.peerId.toString()) {\n                return ma;\n            }\n            return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);\n        });\n    }\n}\n//# sourceMappingURL=index.js.map","export function debounce(func, wait) {\n    let timeout;\n    return function () {\n        const later = function () {\n            timeout = undefined;\n            func();\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n//# sourceMappingURL=utils.js.map","import { CodeError, serviceCapabilities, serviceDependencies } from '@libp2p/interface';\nimport { isStartable } from '@libp2p/interface';\nimport { defaultLogger } from '@libp2p/logger';\nclass DefaultComponents {\n    components = {};\n    _started = false;\n    constructor(init = {}) {\n        this.components = {};\n        for (const [key, value] of Object.entries(init)) {\n            this.components[key] = value;\n        }\n        if (this.components.logger == null) {\n            this.components.logger = defaultLogger();\n        }\n    }\n    isStarted() {\n        return this._started;\n    }\n    async _invokeStartableMethod(methodName) {\n        await Promise.all(Object.values(this.components)\n            .filter(obj => isStartable(obj))\n            .map(async (startable) => {\n            await startable[methodName]?.();\n        }));\n    }\n    async beforeStart() {\n        await this._invokeStartableMethod('beforeStart');\n    }\n    async start() {\n        await this._invokeStartableMethod('start');\n        this._started = true;\n    }\n    async afterStart() {\n        await this._invokeStartableMethod('afterStart');\n    }\n    async beforeStop() {\n        await this._invokeStartableMethod('beforeStop');\n    }\n    async stop() {\n        await this._invokeStartableMethod('stop');\n        this._started = false;\n    }\n    async afterStop() {\n        await this._invokeStartableMethod('afterStop');\n    }\n}\nconst OPTIONAL_SERVICES = [\n    'metrics',\n    'connectionProtector',\n    'dns'\n];\nconst NON_SERVICE_PROPERTIES = [\n    'components',\n    'isStarted',\n    'beforeStart',\n    'start',\n    'afterStart',\n    'beforeStop',\n    'stop',\n    'afterStop',\n    'then',\n    '_invokeStartableMethod'\n];\nexport function defaultComponents(init = {}) {\n    const components = new DefaultComponents(init);\n    const proxy = new Proxy(components, {\n        get(target, prop, receiver) {\n            if (typeof prop === 'string' && !NON_SERVICE_PROPERTIES.includes(prop)) {\n                const service = components.components[prop];\n                if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n                    throw new CodeError(`${prop} not set`, 'ERR_SERVICE_MISSING');\n                }\n                return service;\n            }\n            return Reflect.get(target, prop, receiver);\n        },\n        set(target, prop, value) {\n            if (typeof prop === 'string') {\n                components.components[prop] = value;\n            }\n            else {\n                Reflect.set(target, prop, value);\n            }\n            return true;\n        }\n    });\n    // @ts-expect-error component keys are proxied\n    return proxy;\n}\nexport function checkServiceDependencies(components) {\n    const serviceCapabilities = {};\n    for (const service of Object.values(components.components)) {\n        for (const capability of getServiceCapabilities(service)) {\n            serviceCapabilities[capability] = true;\n        }\n    }\n    for (const service of Object.values(components.components)) {\n        for (const capability of getServiceDependencies(service)) {\n            if (serviceCapabilities[capability] !== true) {\n                throw new CodeError(`Service \"${getServiceName(service)}\" required capability \"${capability}\" but it was not provided by any component, you may need to add additional configuration when creating your node.`, 'ERR_UNMET_SERVICE_DEPENDENCIES');\n            }\n        }\n    }\n}\nfunction getServiceCapabilities(service) {\n    if (Array.isArray(service?.[serviceCapabilities])) {\n        return service[serviceCapabilities];\n    }\n    return [];\n}\nfunction getServiceDependencies(service) {\n    if (Array.isArray(service?.[serviceDependencies])) {\n        return service[serviceDependencies];\n    }\n    return [];\n}\nfunction getServiceName(service) {\n    return service?.[Symbol.toStringTag] ?? service?.toString() ?? 'unknown';\n}\n//# sourceMappingURL=components.js.map","import { CodeError, FaultTolerance } from '@libp2p/interface';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { defaultAddressSort } from '@libp2p/utils/address-sort';\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers';\nimport mergeOptions from 'merge-options';\nimport { codes, messages } from './errors.js';\nconst DefaultConfig = {\n    addresses: {\n        listen: [],\n        announce: [],\n        noAnnounce: [],\n        announceFilter: (multiaddrs) => multiaddrs\n    },\n    connectionManager: {\n        resolvers: {\n            dnsaddr: dnsaddrResolver\n        },\n        addressSorter: defaultAddressSort\n    },\n    transportManager: {\n        faultTolerance: FaultTolerance.FATAL_ALL\n    }\n};\nexport async function validateConfig(opts) {\n    const resultingOptions = mergeOptions(DefaultConfig, opts);\n    if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) { // eslint-disable-line no-undef\n        throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes.ERR_PROTECTOR_REQUIRED);\n    }\n    if (resultingOptions.privateKey != null && !(await peerIdFromKeys(resultingOptions.privateKey.public.bytes, resultingOptions.privateKey.bytes)).equals(resultingOptions.peerId)) {\n        throw new CodeError('Private key doesn\\'t match peer id', codes.ERR_INVALID_KEY);\n    }\n    return resultingOptions;\n}\n//# sourceMappingURL=config.js.map","import { isPrivateIp } from '@libp2p/utils/private-ip';\n/**\n * Returns a connection gater that disallows dialling private addresses by\n * default. Browsers are severely limited in their resource usage so don't\n * waste time trying to dial undiallable addresses.\n */\nexport function connectionGater(gater = {}) {\n    return {\n        denyDialPeer: async () => false,\n        denyDialMultiaddr: async (multiaddr) => {\n            const tuples = multiaddr.stringTuples();\n            if (tuples[0][0] === 4 || tuples[0][0] === 41) {\n                return Boolean(isPrivateIp(`${tuples[0][1]}`));\n            }\n            return false;\n        },\n        denyInboundConnection: async () => false,\n        denyOutboundConnection: async () => false,\n        denyInboundEncryptedConnection: async () => false,\n        denyOutboundEncryptedConnection: async () => false,\n        denyInboundUpgradedConnection: async () => false,\n        denyOutboundUpgradedConnection: async () => false,\n        filterMultiaddrForPeer: async () => true,\n        ...gater\n    };\n}\n//# sourceMappingURL=connection-gater.browser.js.map","import { PeerMap, PeerSet } from '@libp2p/peer-collections';\nimport { PeerQueue } from '@libp2p/utils/peer-queue';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE, AUTO_DIAL_INTERVAL, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PEER_RETRY_THRESHOLD, AUTO_DIAL_PRIORITY, LAST_DIAL_FAILURE_KEY, MIN_CONNECTIONS } from './constants.js';\nconst defaultOptions = {\n    minConnections: MIN_CONNECTIONS,\n    maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,\n    autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n    autoDialPriority: AUTO_DIAL_PRIORITY,\n    autoDialInterval: AUTO_DIAL_INTERVAL,\n    autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,\n    autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE\n};\nexport class AutoDial {\n    connectionManager;\n    peerStore;\n    queue;\n    minConnections;\n    autoDialPriority;\n    autoDialIntervalMs;\n    autoDialMaxQueueLength;\n    autoDialPeerRetryThresholdMs;\n    autoDialDiscoveredPeersDebounce;\n    autoDialInterval;\n    started;\n    running;\n    log;\n    /**\n     * Proactively tries to connect to known peers stored in the PeerStore.\n     * It will keep the number of connections below the upper limit and sort\n     * the peers to connect based on whether we know their keys and protocols.\n     */\n    constructor(components, init) {\n        this.connectionManager = components.connectionManager;\n        this.peerStore = components.peerStore;\n        this.minConnections = init.minConnections ?? defaultOptions.minConnections;\n        this.autoDialPriority = init.autoDialPriority ?? defaultOptions.autoDialPriority;\n        this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions.autoDialInterval;\n        this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions.maxQueueLength;\n        this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold;\n        this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce;\n        this.log = components.logger.forComponent('libp2p:connection-manager:auto-dial');\n        this.started = false;\n        this.running = false;\n        this.queue = new PeerQueue({\n            concurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n            metricName: 'libp2p_autodial_queue',\n            metrics: components.metrics\n        });\n        this.queue.addEventListener('error', (evt) => {\n            this.log.error('error during auto-dial', evt.detail);\n        });\n        // check the min connection limit whenever a peer disconnects\n        components.events.addEventListener('connection:close', () => {\n            this.autoDial()\n                .catch(err => {\n                this.log.error(err);\n            });\n        });\n        // sometimes peers are discovered in quick succession so add a small\n        // debounce to ensure all eligible peers are autodialed\n        let debounce;\n        // when new peers are discovered, dial them if we don't have\n        // enough connections\n        components.events.addEventListener('peer:discovery', () => {\n            clearTimeout(debounce);\n            debounce = setTimeout(() => {\n                this.autoDial()\n                    .catch(err => {\n                    this.log.error(err);\n                });\n            }, this.autoDialDiscoveredPeersDebounce);\n        });\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    afterStart() {\n        this.autoDial()\n            .catch(err => {\n            this.log.error('error while autodialing', err);\n        });\n    }\n    stop() {\n        // clear the queue\n        this.queue.clear();\n        clearTimeout(this.autoDialInterval);\n        this.started = false;\n        this.running = false;\n    }\n    async autoDial() {\n        if (!this.started || this.running) {\n            return;\n        }\n        const connections = this.connectionManager.getConnectionsMap();\n        const numConnections = connections.size;\n        // already have enough connections\n        if (numConnections >= this.minConnections) {\n            if (this.minConnections > 0) {\n                this.log.trace('have enough connections %d/%d', numConnections, this.minConnections);\n            }\n            // no need to schedule next autodial as it will be run when on\n            // connection:close event\n            return;\n        }\n        if (this.queue.size > this.autoDialMaxQueueLength) {\n            this.log('not enough connections %d/%d but auto dial queue is full', numConnections, this.minConnections);\n            this.sheduleNextAutodial();\n            return;\n        }\n        this.running = true;\n        this.log('not enough connections %d/%d - will dial peers to increase the number of connections', numConnections, this.minConnections);\n        const dialQueue = new PeerSet(\n        // @ts-expect-error boolean filter removes falsy peer IDs\n        this.connectionManager.getDialQueue()\n            .map(queue => queue.peerId)\n            .filter(Boolean));\n        // sort peers on whether we know protocols or public keys for them\n        const peers = await this.peerStore.all({\n            filters: [\n                // remove some peers\n                (peer) => {\n                    // remove peers without addresses\n                    if (peer.addresses.length === 0) {\n                        this.log.trace('not autodialing %p because they have no addresses', peer.id);\n                        return false;\n                    }\n                    // remove peers we are already connected to\n                    if (connections.has(peer.id)) {\n                        this.log.trace('not autodialing %p because they are already connected', peer.id);\n                        return false;\n                    }\n                    // remove peers we are already dialling\n                    if (dialQueue.has(peer.id)) {\n                        this.log.trace('not autodialing %p because they are already being dialed', peer.id);\n                        return false;\n                    }\n                    // remove peers already in the autodial queue\n                    if (this.queue.has(peer.id)) {\n                        this.log.trace('not autodialing %p because they are already being autodialed', peer.id);\n                        return false;\n                    }\n                    return true;\n                }\n            ]\n        });\n        // shuffle the peers - this is so peers with the same tag values will be\n        // dialled in a different order each time\n        const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);\n        // sort shuffled peers by tag value\n        const peerValues = new PeerMap();\n        for (const peer of shuffledPeers) {\n            if (peerValues.has(peer.id)) {\n                continue;\n            }\n            // sum all tag values\n            peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {\n                return acc + curr.value;\n            }, 0));\n        }\n        // sort by value, highest to lowest\n        const sortedPeers = shuffledPeers.sort((a, b) => {\n            const peerAValue = peerValues.get(a.id) ?? 0;\n            const peerBValue = peerValues.get(b.id) ?? 0;\n            if (peerAValue > peerBValue) {\n                return -1;\n            }\n            if (peerAValue < peerBValue) {\n                return 1;\n            }\n            return 0;\n        });\n        const peersThatHaveNotFailed = sortedPeers.filter(peer => {\n            const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY);\n            if (lastDialFailure == null) {\n                return true;\n            }\n            const lastDialFailureTimestamp = parseInt(uint8ArrayToString(lastDialFailure));\n            if (isNaN(lastDialFailureTimestamp)) {\n                return true;\n            }\n            // only dial if the time since the last failure is above the retry threshold\n            return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;\n        });\n        this.log('selected %d/%d peers to dial', peersThatHaveNotFailed.length, peers.length);\n        for (const peer of peersThatHaveNotFailed) {\n            this.queue.add(async () => {\n                const numConnections = this.connectionManager.getConnectionsMap().size;\n                // Check to see if we still need to auto dial\n                if (numConnections >= this.minConnections) {\n                    this.log('got enough connections now %d/%d', numConnections, this.minConnections);\n                    this.queue.clear();\n                    return;\n                }\n                this.log('connecting to a peerStore stored peer %p', peer.id);\n                await this.connectionManager.openConnection(peer.id, {\n                    priority: this.autoDialPriority\n                });\n            }, {\n                peerId: peer.id\n            }).catch(err => {\n                this.log.error('could not connect to peerStore stored peer', err);\n            });\n        }\n        this.running = false;\n        this.sheduleNextAutodial();\n    }\n    sheduleNextAutodial() {\n        if (!this.started) {\n            return;\n        }\n        this.autoDialInterval = setTimeout(() => {\n            this.autoDial()\n                .catch(err => {\n                this.log.error('error while autodialing', err);\n            });\n        }, this.autoDialIntervalMs);\n    }\n}\n//# sourceMappingURL=auto-dial.js.map","import { PeerMap } from '@libp2p/peer-collections';\nimport { safelyCloseConnectionIfUnused } from '@libp2p/utils/close';\nimport { MAX_CONNECTIONS } from './constants.js';\nconst defaultOptions = {\n    maxConnections: MAX_CONNECTIONS,\n    allow: []\n};\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n    maxConnections;\n    connectionManager;\n    peerStore;\n    allow;\n    events;\n    log;\n    constructor(components, init = {}) {\n        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;\n        this.allow = init.allow ?? defaultOptions.allow;\n        this.connectionManager = components.connectionManager;\n        this.peerStore = components.peerStore;\n        this.events = components.events;\n        this.log = components.logger.forComponent('libp2p:connection-manager:connection-pruner');\n        // check the max connection limit whenever a peer connects\n        components.events.addEventListener('connection:open', () => {\n            this.maybePruneConnections()\n                .catch(err => {\n                this.log.error(err);\n            });\n        });\n    }\n    /**\n     * If we have more connections than our maximum, select some excess connections\n     * to prune based on peer value\n     */\n    async maybePruneConnections() {\n        const connections = this.connectionManager.getConnections();\n        const numConnections = connections.length;\n        this.log('checking max connections limit %d/%d', numConnections, this.maxConnections);\n        if (numConnections <= this.maxConnections) {\n            return;\n        }\n        const peerValues = new PeerMap();\n        // work out peer values\n        for (const connection of connections) {\n            const remotePeer = connection.remotePeer;\n            if (peerValues.has(remotePeer)) {\n                continue;\n            }\n            peerValues.set(remotePeer, 0);\n            try {\n                const peer = await this.peerStore.get(remotePeer);\n                // sum all tag values\n                peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n                    return acc + curr.value;\n                }, 0));\n            }\n            catch (err) {\n                if (err.code !== 'ERR_NOT_FOUND') {\n                    this.log.error('error loading peer tags', err);\n                }\n            }\n        }\n        const sortedConnections = this.sortConnections(connections, peerValues);\n        // close some connections\n        const toPrune = Math.max(numConnections - this.maxConnections, 0);\n        const toClose = [];\n        for (const connection of sortedConnections) {\n            this.log('too many connections open - closing a connection to %p', connection.remotePeer);\n            // check allow list\n            const connectionInAllowList = this.allow.some((ma) => {\n                return connection.remoteAddr.toString().startsWith(ma.toString());\n            });\n            // Connections in the allow list should be excluded from pruning\n            if (!connectionInAllowList) {\n                toClose.push(connection);\n            }\n            if (toClose.length === toPrune) {\n                break;\n            }\n        }\n        // close connections\n        await Promise.all(toClose.map(async (connection) => {\n            await safelyCloseConnectionIfUnused(connection, {\n                signal: AbortSignal.timeout(1000)\n            });\n        }));\n        // despatch prune event\n        this.events.safeDispatchEvent('connection:prune', { detail: toClose });\n    }\n    sortConnections(connections, peerValues) {\n        return connections\n            // sort by connection age, newest to oldest\n            .sort((a, b) => {\n            const connectionALifespan = a.timeline.open;\n            const connectionBLifespan = b.timeline.open;\n            if (connectionALifespan < connectionBLifespan) {\n                return 1;\n            }\n            if (connectionALifespan > connectionBLifespan) {\n                return -1;\n            }\n            return 0;\n        })\n            // sort by direction, incoming first then outgoing\n            .sort((a, b) => {\n            if (a.direction === 'outbound' && b.direction === 'inbound') {\n                return 1;\n            }\n            if (a.direction === 'inbound' && b.direction === 'outbound') {\n                return -1;\n            }\n            return 0;\n        })\n            // sort by number of streams, lowest to highest\n            .sort((a, b) => {\n            if (a.streams.length > b.streams.length) {\n                return 1;\n            }\n            if (a.streams.length < b.streams.length) {\n                return -1;\n            }\n            return 0;\n        })\n            // sort by tag value, lowest to highest\n            .sort((a, b) => {\n            const peerAValue = peerValues.get(a.remotePeer) ?? 0;\n            const peerBValue = peerValues.get(b.remotePeer) ?? 0;\n            if (peerAValue > peerBValue) {\n                return 1;\n            }\n            if (peerAValue < peerBValue) {\n                return -1;\n            }\n            return 0;\n        });\n    }\n}\n//# sourceMappingURL=connection-pruner.js.map","export * from './constants.defaults.js';\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#minConnections\n */\nexport const MIN_CONNECTIONS = 5;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */\nexport const MAX_CONNECTIONS = 100;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */\nexport const MAX_PARALLEL_DIALS = 50;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialPeerRetryThreshold\n */\nexport const AUTO_DIAL_PEER_RETRY_THRESHOLD = 1000 * 60 * 7;\n//# sourceMappingURL=constants.browser.js.map","/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 5e3;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */\nexport const INBOUND_UPGRADE_TIMEOUT = 2e3;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialInterval\n */\nexport const AUTO_DIAL_INTERVAL = 5000;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialConcurrency\n */\nexport const AUTO_DIAL_CONCURRENCY = 25;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialPriority\n */\nexport const AUTO_DIAL_PRIORITY = 0;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialMaxQueueLength\n */\nexport const AUTO_DIAL_MAX_QUEUE_LENGTH = 100;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialDiscoveredPeersDebounce\n */\nexport const AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5;\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10;\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempted failed with the relevant\n * peer stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure';\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxDialQueueLength\n */\nexport const MAX_DIAL_QUEUE_LENGTH = 500;\n//# sourceMappingURL=constants.defaults.js.map","/* eslint-disable max-depth */\nimport { CodeError, AggregateCodeError, ERR_TIMEOUT, setMaxListeners } from '@libp2p/interface';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { defaultAddressSort } from '@libp2p/utils/address-sort';\nimport { PriorityQueue } from '@libp2p/utils/priority-queue';\nimport { resolvers, multiaddr } from '@multiformats/multiaddr';\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers';\nimport { Circuit } from '@multiformats/multiaddr-matcher';\nimport { anySignal } from 'any-signal';\nimport { CustomProgressEvent } from 'progress-events';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { codes } from '../errors.js';\nimport { getPeerAddress } from '../get-peer.js';\nimport { DIAL_TIMEOUT, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL, LAST_DIAL_FAILURE_KEY, MAX_DIAL_QUEUE_LENGTH } from './constants.js';\nimport { resolveMultiaddrs } from './utils.js';\nimport { DEFAULT_DIAL_PRIORITY } from './index.js';\nconst defaultOptions = {\n    addressSorter: defaultAddressSort,\n    maxParallelDials: MAX_PARALLEL_DIALS,\n    maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,\n    maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n    dialTimeout: DIAL_TIMEOUT,\n    resolvers: {\n        dnsaddr: dnsaddrResolver\n    }\n};\nexport class DialQueue {\n    queue;\n    components;\n    addressSorter;\n    maxPeerAddrsToDial;\n    maxDialQueueLength;\n    dialTimeout;\n    shutDownController;\n    connections;\n    log;\n    constructor(components, init = {}) {\n        this.addressSorter = init.addressSorter ?? defaultOptions.addressSorter;\n        this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial;\n        this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions.maxDialQueueLength;\n        this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout;\n        this.connections = init.connections ?? new PeerMap();\n        this.log = components.logger.forComponent('libp2p:connection-manager:dial-queue');\n        this.components = components;\n        this.shutDownController = new AbortController();\n        setMaxListeners(Infinity, this.shutDownController.signal);\n        for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n            resolvers.set(key, value);\n        }\n        // controls dial concurrency\n        this.queue = new PriorityQueue({\n            concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,\n            metricName: 'libp2p_dial_queue',\n            metrics: components.metrics\n        });\n        // a started job errored\n        this.queue.addEventListener('error', (event) => {\n            this.log.error('error in dial queue', event.detail);\n        });\n    }\n    start() {\n        this.shutDownController = new AbortController();\n        setMaxListeners(Infinity, this.shutDownController.signal);\n    }\n    /**\n     * Clears any pending dials\n     */\n    stop() {\n        this.shutDownController.abort();\n        this.queue.abort();\n    }\n    /**\n     * Connects to a given peer, multiaddr or list of multiaddrs.\n     *\n     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n     * multiaddrs are passed only those will be dialled.\n     *\n     * Where a list of multiaddrs is passed, if any contain a peer id then all\n     * multiaddrs in the list must contain the same peer id.\n     *\n     * The dial to the first address that is successfully able to upgrade a\n     * connection will be used, all other dials will be aborted when that happens.\n     */\n    async dial(peerIdOrMultiaddr, options = {}) {\n        const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);\n        // make sure we don't have an existing connection to any of the addresses we\n        // are about to dial\n        const existingConnection = Array.from(this.connections.values()).flat().find(conn => {\n            if (options.force === true) {\n                return false;\n            }\n            if (conn.remotePeer.equals(peerId)) {\n                return true;\n            }\n            return multiaddrs.find(addr => {\n                return addr.equals(conn.remoteAddr);\n            });\n        });\n        if (existingConnection != null) {\n            this.log('already connected to %a', existingConnection.remoteAddr);\n            options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'));\n            return existingConnection;\n        }\n        // ready to dial, all async work finished - make sure we don't have any\n        // pending dials in progress for this peer or set of multiaddrs\n        const existingDial = this.queue.queue.find(job => {\n            if (peerId?.equals(job.options.peerId) === true) {\n                return true;\n            }\n            // does the dial contain any of the target multiaddrs?\n            const addresses = job.options.multiaddrs;\n            if (addresses == null) {\n                return false;\n            }\n            for (const multiaddr of multiaddrs) {\n                if (addresses.has(multiaddr.toString())) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        if (existingDial != null) {\n            this.log('joining existing dial target for %p', peerId);\n            // add all multiaddrs to the dial target\n            for (const multiaddr of multiaddrs) {\n                existingDial.options.multiaddrs.add(multiaddr.toString());\n            }\n            options.onProgress?.(new CustomProgressEvent('dial-queue:already-in-dial-queue'));\n            return existingDial.join(options);\n        }\n        if (this.queue.size >= this.maxDialQueueLength) {\n            throw new CodeError('Dial queue is full', 'ERR_DIAL_QUEUE_FULL');\n        }\n        this.log('creating dial target for %p', peerId, multiaddrs.map(ma => ma.toString()));\n        options.onProgress?.(new CustomProgressEvent('dial-queue:add-to-dial-queue'));\n        return this.queue.add(async (options) => {\n            options?.onProgress?.(new CustomProgressEvent('dial-queue:start-dial'));\n            // create abort conditions - need to do this before `calculateMultiaddrs` as\n            // we may be about to resolve a dns addr which can time out\n            const signal = this.createDialAbortController(options?.signal);\n            let addrsToDial;\n            try {\n                // load addresses from address book, resolve and dnsaddrs, filter\n                // undiallables, add peer IDs, etc\n                addrsToDial = await this.calculateMultiaddrs(peerId, options?.multiaddrs, {\n                    ...options,\n                    signal\n                });\n                options?.onProgress?.(new CustomProgressEvent('dial-queue:calculated-addresses', addrsToDial));\n                addrsToDial.map(({ multiaddr }) => multiaddr.toString()).forEach(addr => {\n                    options?.multiaddrs.add(addr);\n                });\n            }\n            catch (err) {\n                signal.clear();\n                throw err;\n            }\n            try {\n                let dialed = 0;\n                const errors = [];\n                for (const address of addrsToDial) {\n                    if (dialed === this.maxPeerAddrsToDial) {\n                        this.log('dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others', dialed, peerId);\n                        throw new CodeError('Peer had more than maxPeerAddrsToDial', codes.ERR_TOO_MANY_ADDRESSES);\n                    }\n                    dialed++;\n                    try {\n                        const conn = await this.components.transportManager.dial(address.multiaddr, {\n                            ...options,\n                            signal\n                        });\n                        this.log('dial to %a succeeded', address.multiaddr);\n                        return conn;\n                    }\n                    catch (err) {\n                        this.log.error('dial failed to %a', address.multiaddr, err);\n                        if (peerId != null) {\n                            // record the failed dial\n                            try {\n                                await this.components.peerStore.patch(peerId, {\n                                    metadata: {\n                                        [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n                                    }\n                                });\n                            }\n                            catch (err) {\n                                this.log.error('could not update last dial failure key for %p', peerId, err);\n                            }\n                        }\n                        // the user/dial timeout/shutdown controller signal aborted\n                        if (signal.aborted) {\n                            throw new CodeError(err.message, ERR_TIMEOUT);\n                        }\n                        errors.push(err);\n                    }\n                }\n                if (errors.length === 1) {\n                    throw errors[0];\n                }\n                throw new AggregateCodeError(errors, 'All multiaddr dials failed', codes.ERR_TRANSPORT_DIAL_FAILED);\n            }\n            finally {\n                // clean up abort signals/controllers\n                signal.clear();\n            }\n        }, {\n            peerId,\n            priority: options.priority ?? DEFAULT_DIAL_PRIORITY,\n            multiaddrs: new Set(multiaddrs.map(ma => ma.toString())),\n            signal: options.signal,\n            onProgress: options.onProgress\n        });\n    }\n    createDialAbortController(userSignal) {\n        // let any signal abort the dial\n        const signal = anySignal([\n            AbortSignal.timeout(this.dialTimeout),\n            this.shutDownController.signal,\n            userSignal\n        ]);\n        // This emitter gets listened to a lot\n        setMaxListeners(Infinity, signal);\n        return signal;\n    }\n    // eslint-disable-next-line complexity\n    async calculateMultiaddrs(peerId, multiaddrs = new Set(), options = {}) {\n        const addrs = [...multiaddrs].map(ma => ({\n            multiaddr: multiaddr(ma),\n            isCertified: false\n        }));\n        // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n        if (peerId != null) {\n            if (this.components.peerId.equals(peerId)) {\n                throw new CodeError('Tried to dial self', codes.ERR_DIALED_SELF);\n            }\n            if ((await this.components.connectionGater.denyDialPeer?.(peerId)) === true) {\n                throw new CodeError('The dial request is blocked by gater.allowDialPeer', codes.ERR_PEER_DIAL_INTERCEPTED);\n            }\n            // if just a peer id was passed, load available multiaddrs for this peer\n            // from the peer store\n            if (addrs.length === 0) {\n                this.log('loading multiaddrs for %p', peerId);\n                try {\n                    const peer = await this.components.peerStore.get(peerId);\n                    addrs.push(...peer.addresses);\n                    this.log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()));\n                }\n                catch (err) {\n                    if (err.code !== codes.ERR_NOT_FOUND) {\n                        throw err;\n                    }\n                }\n            }\n            // if we still don't have any addresses for this peer, try a lookup\n            // using the peer routing\n            if (addrs.length === 0) {\n                this.log('looking up multiaddrs for %p in the peer routing', peerId);\n                try {\n                    const peerInfo = await this.components.peerRouting.findPeer(peerId);\n                    this.log('found multiaddrs for %p in the peer routing', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()));\n                    addrs.push(...peerInfo.multiaddrs.map(multiaddr => ({\n                        multiaddr,\n                        isCertified: false\n                    })));\n                }\n                catch (err) {\n                    if (err.code !== codes.ERR_NO_ROUTERS_AVAILABLE) {\n                        this.log.error('looking up multiaddrs for %p in the peer routing failed', peerId, err);\n                    }\n                }\n            }\n        }\n        // resolve addresses - this can result in a one-to-many translation when\n        // dnsaddrs are resolved\n        let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {\n            const result = await resolveMultiaddrs(addr.multiaddr, {\n                dns: this.components.dns,\n                ...options,\n                log: this.log\n            });\n            if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n                return addr;\n            }\n            return result.map(multiaddr => ({\n                multiaddr,\n                isCertified: false\n            }));\n        })))\n            .flat();\n        // ensure the peer id is appended to the multiaddr\n        if (peerId != null) {\n            const peerIdMultiaddr = `/p2p/${peerId.toString()}`;\n            resolvedAddresses = resolvedAddresses.map(addr => {\n                const lastProto = addr.multiaddr.protos().pop();\n                // do not append peer id to path multiaddrs\n                if (lastProto?.path === true) {\n                    return addr;\n                }\n                // append peer id to multiaddr if it is not already present\n                if (addr.multiaddr.getPeerId() == null) {\n                    return {\n                        multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n                        isCertified: addr.isCertified\n                    };\n                }\n                return addr;\n            });\n        }\n        const filteredAddrs = resolvedAddresses.filter(addr => {\n            // filter out any multiaddrs that we do not have transports for\n            if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {\n                return false;\n            }\n            // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n            // - this can happen with addresses like bootstrap.libp2p.io that resolve\n            // to multiple different peers\n            const addrPeerId = addr.multiaddr.getPeerId();\n            if (peerId != null && addrPeerId != null) {\n                return peerId.equals(addrPeerId);\n            }\n            return true;\n        });\n        // deduplicate addresses\n        const dedupedAddrs = new Map();\n        for (const addr of filteredAddrs) {\n            const maStr = addr.multiaddr.toString();\n            const existing = dedupedAddrs.get(maStr);\n            if (existing != null) {\n                existing.isCertified = existing.isCertified || addr.isCertified || false;\n                continue;\n            }\n            dedupedAddrs.set(maStr, addr);\n        }\n        const dedupedMultiaddrs = [...dedupedAddrs.values()];\n        // make sure we actually have some addresses to dial\n        if (dedupedMultiaddrs.length === 0) {\n            throw new CodeError('The dial request has no valid addresses', codes.ERR_NO_VALID_ADDRESSES);\n        }\n        const gatedAdrs = [];\n        for (const addr of dedupedMultiaddrs) {\n            if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n                continue;\n            }\n            gatedAdrs.push(addr);\n        }\n        const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);\n        // make sure we actually have some addresses to dial\n        if (sortedGatedAddrs.length === 0) {\n            throw new CodeError('The connection gater denied all addresses in the dial request', codes.ERR_NO_VALID_ADDRESSES);\n        }\n        this.log.trace('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()));\n        this.log.trace('addresses for %p after filtering', peerId ?? 'unknown peer', sortedGatedAddrs.map(({ multiaddr }) => multiaddr.toString()));\n        return sortedGatedAddrs;\n    }\n    async isDialable(multiaddr, options = {}) {\n        if (!Array.isArray(multiaddr)) {\n            multiaddr = [multiaddr];\n        }\n        try {\n            const addresses = await this.calculateMultiaddrs(undefined, new Set(multiaddr.map(ma => ma.toString())), options);\n            if (options.runOnTransientConnection === false) {\n                // return true if any resolved multiaddrs are not relay addresses\n                return addresses.find(addr => {\n                    return !Circuit.matches(addr.multiaddr);\n                }) != null;\n            }\n            return true;\n        }\n        catch (err) {\n            this.log.trace('error calculating if multiaddr(s) were dialable', err);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=dial-queue.js.map","import { CodeError, KEEP_ALIVE } from '@libp2p/interface';\nimport { PeerMap } from '@libp2p/peer-collections';\nimport { defaultAddressSort } from '@libp2p/utils/address-sort';\nimport { RateLimiter } from '@libp2p/utils/rate-limiter';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers';\nimport { CustomProgressEvent } from 'progress-events';\nimport { codes } from '../errors.js';\nimport { getPeerAddress } from '../get-peer.js';\nimport { AutoDial } from './auto-dial.js';\nimport { ConnectionPruner } from './connection-pruner.js';\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PEER_RETRY_THRESHOLD, AUTO_DIAL_PRIORITY, DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_DIAL_QUEUE_LENGTH, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL, MIN_CONNECTIONS } from './constants.js';\nimport { DialQueue } from './dial-queue.js';\nexport const DEFAULT_DIAL_PRIORITY = 50;\nconst defaultOptions = {\n    minConnections: MIN_CONNECTIONS,\n    maxConnections: MAX_CONNECTIONS,\n    inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n    maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,\n    autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n    autoDialPriority: AUTO_DIAL_PRIORITY,\n    autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,\n    autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,\n    autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE\n};\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager {\n    started;\n    connections;\n    allow;\n    deny;\n    maxIncomingPendingConnections;\n    incomingPendingConnections;\n    maxConnections;\n    dialQueue;\n    autoDial;\n    connectionPruner;\n    inboundConnectionRateLimiter;\n    peerStore;\n    metrics;\n    events;\n    log;\n    constructor(components, init = {}) {\n        this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections;\n        const minConnections = init.minConnections ?? defaultOptions.minConnections;\n        if (this.maxConnections < minConnections) {\n            throw new CodeError('Connection Manager maxConnections must be greater than minConnections', codes.ERR_INVALID_PARAMETERS);\n        }\n        /**\n         * Map of connections per peer\n         */\n        this.connections = new PeerMap();\n        this.started = false;\n        this.peerStore = components.peerStore;\n        this.metrics = components.metrics;\n        this.events = components.events;\n        this.log = components.logger.forComponent('libp2p:connection-manager');\n        this.onConnect = this.onConnect.bind(this);\n        this.onDisconnect = this.onDisconnect.bind(this);\n        this.events.addEventListener('connection:open', this.onConnect);\n        this.events.addEventListener('connection:close', this.onDisconnect);\n        // allow/deny lists\n        this.allow = (init.allow ?? []).map(ma => multiaddr(ma));\n        this.deny = (init.deny ?? []).map(ma => multiaddr(ma));\n        this.incomingPendingConnections = 0;\n        this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections;\n        // controls individual peers trying to dial us too quickly\n        this.inboundConnectionRateLimiter = new RateLimiter({\n            points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n            duration: 1\n        });\n        // controls what happens when we don't have enough connections\n        this.autoDial = new AutoDial({\n            connectionManager: this,\n            peerStore: components.peerStore,\n            events: components.events,\n            logger: components.logger\n        }, {\n            minConnections,\n            autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n            autoDialPriority: init.autoDialPriority ?? defaultOptions.autoDialPriority,\n            autoDialPeerRetryThreshold: init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold,\n            autoDialDiscoveredPeersDebounce: init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce,\n            maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength\n        });\n        // controls what happens when we have too many connections\n        this.connectionPruner = new ConnectionPruner({\n            connectionManager: this,\n            peerStore: components.peerStore,\n            events: components.events,\n            logger: components.logger\n        }, {\n            maxConnections: this.maxConnections,\n            allow: this.allow\n        });\n        this.dialQueue = new DialQueue(components, {\n            addressSorter: init.addressSorter ?? defaultAddressSort,\n            maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n            maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,\n            maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n            dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n            resolvers: init.resolvers ?? {\n                dnsaddr: dnsaddrResolver\n            },\n            connections: this.connections\n        });\n    }\n    [Symbol.toStringTag] = '@libp2p/connection-manager';\n    isStarted() {\n        return this.started;\n    }\n    /**\n     * Starts the Connection Manager. If Metrics are not enabled on libp2p\n     * only event loop and connection limits will be monitored.\n     */\n    async start() {\n        // track inbound/outbound connections\n        this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n            calculate: () => {\n                const metric = {\n                    inbound: 0,\n                    outbound: 0\n                };\n                for (const conns of this.connections.values()) {\n                    for (const conn of conns) {\n                        if (conn.direction === 'inbound') {\n                            metric.inbound++;\n                        }\n                        else {\n                            metric.outbound++;\n                        }\n                    }\n                }\n                return metric;\n            }\n        });\n        // track total number of streams per protocol\n        this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n            label: 'protocol',\n            calculate: () => {\n                const metric = {};\n                for (const conns of this.connections.values()) {\n                    for (const conn of conns) {\n                        for (const stream of conn.streams) {\n                            const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`;\n                            metric[key] = (metric[key] ?? 0) + 1;\n                        }\n                    }\n                }\n                return metric;\n            }\n        });\n        // track 90th percentile of streams per protocol\n        this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n            label: 'protocol',\n            calculate: () => {\n                const allStreams = {};\n                for (const conns of this.connections.values()) {\n                    for (const conn of conns) {\n                        const streams = {};\n                        for (const stream of conn.streams) {\n                            const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`;\n                            streams[key] = (streams[key] ?? 0) + 1;\n                        }\n                        for (const [protocol, count] of Object.entries(streams)) {\n                            allStreams[protocol] = allStreams[protocol] ?? [];\n                            allStreams[protocol].push(count);\n                        }\n                    }\n                }\n                const metric = {};\n                for (let [protocol, counts] of Object.entries(allStreams)) {\n                    counts = counts.sort((a, b) => a - b);\n                    const index = Math.floor(counts.length * 0.9);\n                    metric[protocol] = counts[index];\n                }\n                return metric;\n            }\n        });\n        this.dialQueue.start();\n        this.autoDial.start();\n        this.started = true;\n        this.log('started');\n    }\n    async afterStart() {\n        // re-connect to any peers with the KEEP_ALIVE tag\n        void Promise.resolve()\n            .then(async () => {\n            const keepAlivePeers = await this.peerStore.all({\n                filters: [(peer) => {\n                        return peer.tags.has(KEEP_ALIVE);\n                    }]\n            });\n            await Promise.all(keepAlivePeers.map(async (peer) => {\n                await this.openConnection(peer.id)\n                    .catch(err => {\n                    this.log.error(err);\n                });\n            }));\n        })\n            .catch(err => {\n            this.log.error(err);\n        });\n        this.autoDial.afterStart();\n    }\n    /**\n     * Stops the Connection Manager\n     */\n    async stop() {\n        this.dialQueue.stop();\n        this.autoDial.stop();\n        // Close all connections we're tracking\n        const tasks = [];\n        for (const connectionList of this.connections.values()) {\n            for (const connection of connectionList) {\n                tasks.push((async () => {\n                    try {\n                        await connection.close();\n                    }\n                    catch (err) {\n                        this.log.error(err);\n                    }\n                })());\n            }\n        }\n        this.log('closing %d connections', tasks.length);\n        await Promise.all(tasks);\n        this.connections.clear();\n        this.log('stopped');\n    }\n    onConnect(evt) {\n        void this._onConnect(evt).catch(err => {\n            this.log.error(err);\n        });\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     */\n    async _onConnect(evt) {\n        const { detail: connection } = evt;\n        if (!this.started) {\n            // This can happen when we are in the process of shutting down the node\n            await connection.close();\n            return;\n        }\n        const peerId = connection.remotePeer;\n        const storedConns = this.connections.get(peerId);\n        let isNewPeer = false;\n        if (storedConns != null) {\n            storedConns.push(connection);\n        }\n        else {\n            isNewPeer = true;\n            this.connections.set(peerId, [connection]);\n        }\n        // only need to store RSA public keys, all other types are embedded in the peer id\n        if (peerId.publicKey != null && peerId.type === 'RSA') {\n            await this.peerStore.patch(peerId, {\n                publicKey: peerId.publicKey\n            });\n        }\n        if (isNewPeer) {\n            this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer });\n        }\n    }\n    /**\n     * Removes the connection from tracking\n     */\n    onDisconnect(evt) {\n        const { detail: connection } = evt;\n        if (!this.started) {\n            // This can happen when we are in the process of shutting down the node\n            return;\n        }\n        const peerId = connection.remotePeer;\n        let storedConn = this.connections.get(peerId);\n        if (storedConn != null && storedConn.length > 1) {\n            storedConn = storedConn.filter((conn) => conn.id !== connection.id);\n            this.connections.set(peerId, storedConn);\n        }\n        else if (storedConn != null) {\n            this.connections.delete(peerId);\n            this.events.safeDispatchEvent('peer:disconnect', { detail: connection.remotePeer });\n        }\n    }\n    getConnections(peerId) {\n        if (peerId != null) {\n            return this.connections.get(peerId) ?? [];\n        }\n        let conns = [];\n        for (const c of this.connections.values()) {\n            conns = conns.concat(c);\n        }\n        return conns;\n    }\n    getConnectionsMap() {\n        return this.connections;\n    }\n    async openConnection(peerIdOrMultiaddr, options = {}) {\n        if (!this.isStarted()) {\n            throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED);\n        }\n        options.signal?.throwIfAborted();\n        const { peerId } = getPeerAddress(peerIdOrMultiaddr);\n        if (peerId != null && options.force !== true) {\n            this.log('dial %p', peerId);\n            const existingConnection = this.getConnections(peerId)\n                .find(conn => !conn.transient);\n            if (existingConnection != null) {\n                this.log('had an existing non-transient connection to %p', peerId);\n                options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'));\n                return existingConnection;\n            }\n        }\n        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n            ...options,\n            priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n        });\n        let peerConnections = this.connections.get(connection.remotePeer);\n        if (peerConnections == null) {\n            peerConnections = [];\n            this.connections.set(connection.remotePeer, peerConnections);\n        }\n        // we get notified of connections via the Upgrader emitting \"connection\"\n        // events, double check we aren't already tracking this connection before\n        // storing it\n        let trackedConnection = false;\n        for (const conn of peerConnections) {\n            if (conn.id === connection.id) {\n                trackedConnection = true;\n            }\n        }\n        if (!trackedConnection) {\n            peerConnections.push(connection);\n        }\n        return connection;\n    }\n    async closeConnections(peerId, options = {}) {\n        const connections = this.connections.get(peerId) ?? [];\n        await Promise.all(connections.map(async (connection) => {\n            try {\n                await connection.close(options);\n            }\n            catch (err) {\n                connection.abort(err);\n            }\n        }));\n    }\n    async acceptIncomingConnection(maConn) {\n        // check deny list\n        const denyConnection = this.deny.some(ma => {\n            return maConn.remoteAddr.toString().startsWith(ma.toString());\n        });\n        if (denyConnection) {\n            this.log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr);\n            return false;\n        }\n        // check allow list\n        const allowConnection = this.allow.some(ma => {\n            return maConn.remoteAddr.toString().startsWith(ma.toString());\n        });\n        if (allowConnection) {\n            this.incomingPendingConnections++;\n            return true;\n        }\n        // check pending connections\n        if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n            this.log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr);\n            return false;\n        }\n        if (maConn.remoteAddr.isThinWaistAddress()) {\n            const host = maConn.remoteAddr.nodeAddress().address;\n            try {\n                await this.inboundConnectionRateLimiter.consume(host, 1);\n            }\n            catch {\n                this.log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, host);\n                return false;\n            }\n        }\n        if (this.getConnections().length < this.maxConnections) {\n            this.incomingPendingConnections++;\n            return true;\n        }\n        this.log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr);\n        return false;\n    }\n    afterUpgradeInbound() {\n        this.incomingPendingConnections--;\n    }\n    getDialQueue() {\n        const statusMap = {\n            queued: 'queued',\n            running: 'active',\n            errored: 'error',\n            complete: 'success'\n        };\n        return this.dialQueue.queue.queue.map(job => {\n            return {\n                id: job.id,\n                status: statusMap[job.status],\n                peerId: job.options.peerId,\n                multiaddrs: [...job.options.multiaddrs].map(ma => multiaddr(ma))\n            };\n        });\n    }\n    async isDialable(multiaddr, options = {}) {\n        return this.dialQueue.isDialable(multiaddr, options);\n    }\n}\n//# sourceMappingURL=index.js.map","import { resolvers } from '@multiformats/multiaddr';\n/**\n * Recursively resolve DNSADDR multiaddrs\n */\nexport async function resolveMultiaddrs(ma, options) {\n    // check multiaddr resolvers\n    let resolvable = false;\n    for (const key of resolvers.keys()) {\n        resolvable = ma.protoNames().includes(key);\n        if (resolvable) {\n            break;\n        }\n    }\n    // return multiaddr if it is not resolvable\n    if (!resolvable) {\n        return [ma];\n    }\n    const output = await ma.resolve(options);\n    options.log('resolved %s to', ma, output.map(ma => ma.toString()));\n    return output;\n}\n//# sourceMappingURL=utils.js.map","import { randomBytes } from '@libp2p/crypto';\nimport { serviceCapabilities } from '@libp2p/interface';\nimport { AdaptiveTimeout } from '@libp2p/utils/adaptive-timeout';\nimport { byteStream } from 'it-byte-stream';\nconst DEFAULT_PING_INTERVAL_MS = 10000;\nconst PROTOCOL_VERSION = '1.0.0';\nconst PROTOCOL_NAME = 'ping';\nconst PROTOCOL_PREFIX = 'ipfs';\nconst PING_LENGTH = 32;\nexport class ConnectionMonitor {\n    protocol;\n    components;\n    log;\n    heartbeatInterval;\n    pingIntervalMs;\n    abortController;\n    timeout;\n    constructor(components, init = {}) {\n        this.components = components;\n        this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;\n        this.log = components.logger.forComponent('libp2p:connection-monitor');\n        this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;\n        this.timeout = new AdaptiveTimeout({\n            ...(init.pingTimeout ?? {}),\n            metrics: components.metrics,\n            metricName: 'libp2p_connection_monitor_ping_time_milliseconds'\n        });\n    }\n    [Symbol.toStringTag] = '@libp2p/connection-monitor';\n    [serviceCapabilities] = [\n        '@libp2p/connection-monitor'\n    ];\n    start() {\n        this.abortController = new AbortController();\n        this.heartbeatInterval = setInterval(() => {\n            this.components.connectionManager.getConnections().forEach(conn => {\n                Promise.resolve().then(async () => {\n                    let start = Date.now();\n                    try {\n                        const signal = this.timeout.getTimeoutSignal({\n                            signal: this.abortController?.signal\n                        });\n                        const stream = await conn.newStream(this.protocol, {\n                            signal,\n                            runOnTransientConnection: true\n                        });\n                        const bs = byteStream(stream);\n                        start = Date.now();\n                        await Promise.all([\n                            bs.write(randomBytes(PING_LENGTH), {\n                                signal\n                            }),\n                            bs.read(PING_LENGTH, {\n                                signal\n                            })\n                        ]);\n                        conn.rtt = Date.now() - start;\n                        await bs.unwrap().close({\n                            signal\n                        });\n                    }\n                    catch (err) {\n                        if (err.code !== 'ERR_UNSUPPORTED_PROTOCOL') {\n                            throw err;\n                        }\n                        // protocol was unsupported, but that's ok as it means the remote\n                        // peer was still alive. We ran multistream-select which means two\n                        // round trips (e.g. 1x for the mss header, then another for the\n                        // protocol) so divide the time it took by two\n                        conn.rtt = (Date.now() - start) / 2;\n                    }\n                })\n                    .catch(err => {\n                    this.log.error('error during heartbeat, aborting connection', err);\n                    conn.abort(err);\n                });\n            });\n        }, this.pingIntervalMs);\n    }\n    stop() {\n        this.abortController?.abort();\n        if (this.heartbeatInterval != null) {\n            clearInterval(this.heartbeatInterval);\n        }\n    }\n}\n//# sourceMappingURL=connection-monitor.js.map","import { connectionSymbol, CodeError, setMaxListeners } from '@libp2p/interface';\nconst CLOSE_TIMEOUT = 500;\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl {\n    /**\n     * Connection identifier.\n     */\n    id;\n    /**\n     * Observed multiaddr of the remote peer\n     */\n    remoteAddr;\n    /**\n     * Remote peer id\n     */\n    remotePeer;\n    direction;\n    timeline;\n    multiplexer;\n    encryption;\n    status;\n    transient;\n    log;\n    /**\n     * User provided tags\n     *\n     */\n    tags;\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n    _newStream;\n    /**\n     * Reference to the close function of the raw connection\n     */\n    _close;\n    _abort;\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n    _getStreams;\n    /**\n     * An implementation of the js-libp2p connection.\n     * Any libp2p transport should use an upgrader to return this connection.\n     */\n    constructor(init) {\n        const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;\n        this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`;\n        this.remoteAddr = remoteAddr;\n        this.remotePeer = remotePeer;\n        this.direction = init.direction;\n        this.status = 'open';\n        this.timeline = init.timeline;\n        this.multiplexer = init.multiplexer;\n        this.encryption = init.encryption;\n        this.transient = init.transient ?? false;\n        this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);\n        if (this.remoteAddr.getPeerId() == null) {\n            this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);\n        }\n        this._newStream = newStream;\n        this._close = close;\n        this._abort = abort;\n        this._getStreams = getStreams;\n        this.tags = [];\n    }\n    [Symbol.toStringTag] = 'Connection';\n    [connectionSymbol] = true;\n    /**\n     * Get all the streams of the muxer\n     */\n    get streams() {\n        return this._getStreams();\n    }\n    /**\n     * Create a new stream from this connection\n     */\n    async newStream(protocols, options) {\n        if (this.status === 'closing') {\n            throw new CodeError('the connection is being closed', 'ERR_CONNECTION_BEING_CLOSED');\n        }\n        if (this.status === 'closed') {\n            throw new CodeError('the connection is closed', 'ERR_CONNECTION_CLOSED');\n        }\n        if (!Array.isArray(protocols)) {\n            protocols = [protocols];\n        }\n        if (this.transient && options?.runOnTransientConnection !== true) {\n            throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION');\n        }\n        const stream = await this._newStream(protocols, options);\n        stream.direction = 'outbound';\n        return stream;\n    }\n    /**\n     * Close the connection\n     */\n    async close(options = {}) {\n        if (this.status === 'closed' || this.status === 'closing') {\n            return;\n        }\n        this.log('closing connection to %a', this.remoteAddr);\n        this.status = 'closing';\n        if (options.signal == null) {\n            const signal = AbortSignal.timeout(CLOSE_TIMEOUT);\n            setMaxListeners(Infinity, signal);\n            options = {\n                ...options,\n                signal\n            };\n        }\n        try {\n            this.log.trace('closing all streams');\n            // close all streams gracefully - this can throw if we're not multiplexed\n            await Promise.all(this.streams.map(async (s) => s.close(options)));\n            this.log.trace('closing underlying transport');\n            // close raw connection\n            await this._close(options);\n            this.log.trace('updating timeline with close time');\n            this.status = 'closed';\n            this.timeline.close = Date.now();\n        }\n        catch (err) {\n            this.log.error('error encountered during graceful close of connection to %a', this.remoteAddr, err);\n            this.abort(err);\n        }\n    }\n    abort(err) {\n        this.log.error('aborting connection to %a due to error', this.remoteAddr, err);\n        this.status = 'closing';\n        this.streams.forEach(s => { s.abort(err); });\n        this.log.error('all streams aborted', this.streams.length);\n        // Abort raw connection\n        this._abort(err);\n        this.timeline.close = Date.now();\n        this.status = 'closed';\n    }\n}\nexport function createConnection(init) {\n    return new ConnectionImpl(init);\n}\n//# sourceMappingURL=index.js.map","import { CodeError } from '@libp2p/interface';\nimport { PeerSet } from '@libp2p/peer-collections';\nimport merge from 'it-merge';\nimport { codes, messages } from './errors.js';\nexport class CompoundContentRouting {\n    routers;\n    started;\n    components;\n    constructor(components, init) {\n        this.routers = init.routers ?? [];\n        this.started = false;\n        this.components = components;\n    }\n    [Symbol.toStringTag] = '@libp2p/content-routing';\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        this.started = true;\n    }\n    async stop() {\n        this.started = false;\n    }\n    /**\n     * Iterates over all content routers in parallel to find providers of the given key\n     */\n    async *findProviders(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        const self = this;\n        const seen = new PeerSet();\n        for await (const peer of merge(...self.routers.map(router => router.findProviders(key, options)))) {\n            // the peer was yielded by a content router without multiaddrs and we\n            // failed to load them\n            if (peer == null) {\n                continue;\n            }\n            // store the addresses for the peer if found\n            if (peer.multiaddrs.length > 0) {\n                await this.components.peerStore.merge(peer.id, {\n                    multiaddrs: peer.multiaddrs\n                });\n            }\n            // deduplicate peers\n            if (seen.has(peer.id)) {\n                continue;\n            }\n            seen.add(peer.id);\n            yield peer;\n        }\n    }\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key\n     */\n    async provide(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        await Promise.all(this.routers.map(async (router) => {\n            await router.provide(key, options);\n        }));\n    }\n    /**\n     * Store the given key/value pair in the available content routings\n     */\n    async put(key, value, options) {\n        if (!this.isStarted()) {\n            throw new CodeError(messages.NOT_STARTED_YET, codes.ERR_NODE_NOT_STARTED);\n        }\n        await Promise.all(this.routers.map(async (router) => {\n            await router.put(key, value, options);\n        }));\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     */\n    async get(key, options) {\n        if (!this.isStarted()) {\n            throw new CodeError(messages.NOT_STARTED_YET, codes.ERR_NODE_NOT_STARTED);\n        }\n        return Promise.any(this.routers.map(async (router) => {\n            return router.get(key, options);\n        }));\n    }\n}\n//# sourceMappingURL=content-routing.js.map","export var messages;\n(function (messages) {\n    messages[\"NOT_STARTED_YET\"] = \"The libp2p node is not started yet\";\n    messages[\"ERR_PROTECTOR_REQUIRED\"] = \"Private network is enforced, but no protector was provided\";\n    messages[\"NOT_FOUND\"] = \"Not found\";\n})(messages || (messages = {}));\nexport var codes;\n(function (codes) {\n    codes[\"ERR_PROTECTOR_REQUIRED\"] = \"ERR_PROTECTOR_REQUIRED\";\n    codes[\"ERR_PEER_DIAL_INTERCEPTED\"] = \"ERR_PEER_DIAL_INTERCEPTED\";\n    codes[\"ERR_CONNECTION_INTERCEPTED\"] = \"ERR_CONNECTION_INTERCEPTED\";\n    codes[\"ERR_INVALID_PROTOCOLS_FOR_STREAM\"] = \"ERR_INVALID_PROTOCOLS_FOR_STREAM\";\n    codes[\"ERR_CONNECTION_ENDED\"] = \"ERR_CONNECTION_ENDED\";\n    codes[\"ERR_CONNECTION_FAILED\"] = \"ERR_CONNECTION_FAILED\";\n    codes[\"ERR_NODE_NOT_STARTED\"] = \"ERR_NODE_NOT_STARTED\";\n    codes[\"ERR_ALREADY_ABORTED\"] = \"ERR_ALREADY_ABORTED\";\n    codes[\"ERR_TOO_MANY_ADDRESSES\"] = \"ERR_TOO_MANY_ADDRESSES\";\n    codes[\"ERR_NO_VALID_ADDRESSES\"] = \"ERR_NO_VALID_ADDRESSES\";\n    codes[\"ERR_RELAYED_DIAL\"] = \"ERR_RELAYED_DIAL\";\n    codes[\"ERR_DIALED_SELF\"] = \"ERR_DIALED_SELF\";\n    codes[\"ERR_DISCOVERED_SELF\"] = \"ERR_DISCOVERED_SELF\";\n    codes[\"ERR_DUPLICATE_TRANSPORT\"] = \"ERR_DUPLICATE_TRANSPORT\";\n    codes[\"ERR_ENCRYPTION_FAILED\"] = \"ERR_ENCRYPTION_FAILED\";\n    codes[\"ERR_HOP_REQUEST_FAILED\"] = \"ERR_HOP_REQUEST_FAILED\";\n    codes[\"ERR_INVALID_KEY\"] = \"ERR_INVALID_KEY\";\n    codes[\"ERR_INVALID_MESSAGE\"] = \"ERR_INVALID_MESSAGE\";\n    codes[\"ERR_INVALID_PARAMETERS\"] = \"ERR_INVALID_PARAMETERS\";\n    codes[\"ERR_INVALID_PEER\"] = \"ERR_INVALID_PEER\";\n    codes[\"ERR_MUXER_UNAVAILABLE\"] = \"ERR_MUXER_UNAVAILABLE\";\n    codes[\"ERR_NOT_FOUND\"] = \"ERR_NOT_FOUND\";\n    codes[\"ERR_TRANSPORT_UNAVAILABLE\"] = \"ERR_TRANSPORT_UNAVAILABLE\";\n    codes[\"ERR_TRANSPORT_DIAL_FAILED\"] = \"ERR_TRANSPORT_DIAL_FAILED\";\n    codes[\"ERR_UNSUPPORTED_PROTOCOL\"] = \"ERR_UNSUPPORTED_PROTOCOL\";\n    codes[\"ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED\"] = \"ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED\";\n    codes[\"ERR_INVALID_MULTIADDR\"] = \"ERR_INVALID_MULTIADDR\";\n    codes[\"ERR_SIGNATURE_NOT_VALID\"] = \"ERR_SIGNATURE_NOT_VALID\";\n    codes[\"ERR_FIND_SELF\"] = \"ERR_FIND_SELF\";\n    codes[\"ERR_NO_ROUTERS_AVAILABLE\"] = \"ERR_NO_ROUTERS_AVAILABLE\";\n    codes[\"ERR_CONNECTION_NOT_MULTIPLEXED\"] = \"ERR_CONNECTION_NOT_MULTIPLEXED\";\n    codes[\"ERR_NO_DIAL_TOKENS\"] = \"ERR_NO_DIAL_TOKENS\";\n    codes[\"ERR_INVALID_CMS\"] = \"ERR_INVALID_CMS\";\n    codes[\"ERR_MISSING_KEYS\"] = \"ERR_MISSING_KEYS\";\n    codes[\"ERR_NO_KEY\"] = \"ERR_NO_KEY\";\n    codes[\"ERR_INVALID_KEY_NAME\"] = \"ERR_INVALID_KEY_NAME\";\n    codes[\"ERR_INVALID_KEY_TYPE\"] = \"ERR_INVALID_KEY_TYPE\";\n    codes[\"ERR_KEY_ALREADY_EXISTS\"] = \"ERR_KEY_ALREADY_EXISTS\";\n    codes[\"ERR_INVALID_KEY_SIZE\"] = \"ERR_INVALID_KEY_SIZE\";\n    codes[\"ERR_KEY_NOT_FOUND\"] = \"ERR_KEY_NOT_FOUND\";\n    codes[\"ERR_OLD_KEY_NAME_INVALID\"] = \"ERR_OLD_KEY_NAME_INVALID\";\n    codes[\"ERR_NEW_KEY_NAME_INVALID\"] = \"ERR_NEW_KEY_NAME_INVALID\";\n    codes[\"ERR_PASSWORD_REQUIRED\"] = \"ERR_PASSWORD_REQUIRED\";\n    codes[\"ERR_PEM_REQUIRED\"] = \"ERR_PEM_REQUIRED\";\n    codes[\"ERR_CANNOT_READ_KEY\"] = \"ERR_CANNOT_READ_KEY\";\n    codes[\"ERR_MISSING_PRIVATE_KEY\"] = \"ERR_MISSING_PRIVATE_KEY\";\n    codes[\"ERR_MISSING_PUBLIC_KEY\"] = \"ERR_MISSING_PUBLIC_KEY\";\n    codes[\"ERR_INVALID_OLD_PASS_TYPE\"] = \"ERR_INVALID_OLD_PASS_TYPE\";\n    codes[\"ERR_INVALID_NEW_PASS_TYPE\"] = \"ERR_INVALID_NEW_PASS_TYPE\";\n    codes[\"ERR_INVALID_PASS_LENGTH\"] = \"ERR_INVALID_PASS_LENGTH\";\n    codes[\"ERR_NOT_IMPLEMENTED\"] = \"ERR_NOT_IMPLEMENTED\";\n    codes[\"ERR_WRONG_PING_ACK\"] = \"ERR_WRONG_PING_ACK\";\n    codes[\"ERR_INVALID_RECORD\"] = \"ERR_INVALID_RECORD\";\n    codes[\"ERR_ALREADY_SUCCEEDED\"] = \"ERR_ALREADY_SUCCEEDED\";\n    codes[\"ERR_NO_HANDLER_FOR_PROTOCOL\"] = \"ERR_NO_HANDLER_FOR_PROTOCOL\";\n    codes[\"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\"] = \"ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS\";\n    codes[\"ERR_CONNECTION_DENIED\"] = \"ERR_CONNECTION_DENIED\";\n    codes[\"ERR_TRANSFER_LIMIT_EXCEEDED\"] = \"ERR_TRANSFER_LIMIT_EXCEEDED\";\n})(codes || (codes = {}));\n//# sourceMappingURL=errors.js.map","import { CodeError, isPeerId } from '@libp2p/interface';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { codes } from './errors.js';\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */\nexport function getPeerAddress(peer) {\n    if (isPeerId(peer)) {\n        return { peerId: peer, multiaddrs: [] };\n    }\n    if (!Array.isArray(peer)) {\n        peer = [peer];\n    }\n    let peerId;\n    if (peer.length > 0) {\n        const peerIdStr = peer[0].getPeerId();\n        peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr);\n        // ensure PeerId is either not set or is consistent\n        peer.forEach(ma => {\n            if (!isMultiaddr(ma)) {\n                throw new CodeError('Invalid Multiaddr', codes.ERR_INVALID_MULTIADDR);\n            }\n            const maPeerIdStr = ma.getPeerId();\n            if (maPeerIdStr == null) {\n                if (peerId != null) {\n                    throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS);\n                }\n            }\n            else {\n                const maPeerId = peerIdFromString(maPeerIdStr);\n                if (peerId?.equals(maPeerId) !== true) {\n                    throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS);\n                }\n            }\n        });\n    }\n    return {\n        peerId,\n        multiaddrs: peer\n    };\n}\n//# sourceMappingURL=get-peer.js.map","/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\nimport { createLibp2pNode } from './libp2p.js';\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncryption: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p(options = {}) {\n    const node = await createLibp2pNode(options);\n    if (options.start !== false) {\n        await node.start();\n    }\n    return node;\n}\n//# sourceMappingURL=index.js.map","import { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys';\nimport { contentRoutingSymbol, CodeError, TypedEventEmitter, CustomEvent, setMaxListeners, peerDiscoverySymbol, peerRoutingSymbol } from '@libp2p/interface';\nimport { defaultLogger } from '@libp2p/logger';\nimport { PeerSet } from '@libp2p/peer-collections';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory';\nimport { PersistentPeerStore } from '@libp2p/peer-store';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { MemoryDatastore } from 'datastore-core/memory';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { DefaultAddressManager } from './address-manager/index.js';\nimport { checkServiceDependencies, defaultComponents } from './components.js';\nimport { connectionGater } from './config/connection-gater.js';\nimport { validateConfig } from './config.js';\nimport { DefaultConnectionManager } from './connection-manager/index.js';\nimport { ConnectionMonitor } from './connection-monitor.js';\nimport { CompoundContentRouting } from './content-routing.js';\nimport { codes } from './errors.js';\nimport { DefaultPeerRouting } from './peer-routing.js';\nimport { RandomWalk } from './random-walk.js';\nimport { DefaultRegistrar } from './registrar.js';\nimport { DefaultTransportManager } from './transport-manager.js';\nimport { DefaultUpgrader } from './upgrader.js';\nimport * as pkg from './version.js';\nexport class Libp2pNode extends TypedEventEmitter {\n    peerId;\n    peerStore;\n    contentRouting;\n    peerRouting;\n    metrics;\n    services;\n    logger;\n    status;\n    components;\n    log;\n    constructor(init) {\n        super();\n        this.status = 'stopped';\n        // event bus - components can listen to this emitter to be notified of system events\n        // and also cause them to be emitted\n        const events = new TypedEventEmitter();\n        const originalDispatch = events.dispatchEvent.bind(events);\n        events.dispatchEvent = (evt) => {\n            const internalResult = originalDispatch(evt);\n            const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));\n            return internalResult || externalResult;\n        };\n        // This emitter gets listened to a lot\n        setMaxListeners(Infinity, events);\n        this.peerId = init.peerId;\n        this.logger = init.logger ?? defaultLogger();\n        this.log = this.logger.forComponent('libp2p');\n        // @ts-expect-error {} may not be of type T\n        this.services = {};\n        // @ts-expect-error defaultComponents is missing component types added later\n        const components = this.components = defaultComponents({\n            peerId: init.peerId,\n            privateKey: init.privateKey,\n            nodeInfo: init.nodeInfo ?? {\n                name: pkg.name,\n                version: pkg.version\n            },\n            logger: this.logger,\n            events,\n            datastore: init.datastore ?? new MemoryDatastore(),\n            connectionGater: connectionGater(init.connectionGater),\n            dns: init.dns\n        });\n        this.peerStore = this.configureComponent('peerStore', new PersistentPeerStore(components, {\n            addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n            ...init.peerStore\n        }));\n        // Create Metrics\n        if (init.metrics != null) {\n            this.metrics = this.configureComponent('metrics', init.metrics(this.components));\n        }\n        components.events.addEventListener('peer:update', evt => {\n            // if there was no peer previously in the peer store this is a new peer\n            if (evt.detail.previous == null) {\n                const peerInfo = {\n                    id: evt.detail.peer.id,\n                    multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr)\n                };\n                components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo });\n            }\n        });\n        // Set up connection protector if configured\n        if (init.connectionProtector != null) {\n            this.configureComponent('connectionProtector', init.connectionProtector(components));\n        }\n        // Set up the Upgrader\n        this.components.upgrader = new DefaultUpgrader(this.components, {\n            connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n            muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n            inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout\n        });\n        // Setup the transport manager\n        this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager));\n        // Create the Connection Manager\n        this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager));\n        if (init.connectionMonitor?.enabled !== false) {\n            // Create the Connection Monitor if not disabled\n            this.configureComponent('connectionMonitor', new ConnectionMonitor(this.components, init.connectionMonitor));\n        }\n        // Create the Registrar\n        this.configureComponent('registrar', new DefaultRegistrar(this.components));\n        // Addresses {listen, announce, noAnnounce}\n        this.configureComponent('addressManager', new DefaultAddressManager(this.components, init.addresses));\n        // Peer routers\n        const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));\n        this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n            routers: peerRouters\n        }));\n        // Content routers\n        const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));\n        this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n            routers: contentRouters\n        }));\n        // Random walk\n        this.configureComponent('randomWalk', new RandomWalk(this.components));\n        (init.peerDiscovery ?? []).forEach((fn, index) => {\n            const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));\n            service.addEventListener('peer', (evt) => {\n                this.#onDiscoveryPeer(evt);\n            });\n        });\n        // Transport modules\n        init.transports?.forEach((fn, index) => {\n            this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));\n        });\n        // User defined modules\n        if (init.services != null) {\n            for (const name of Object.keys(init.services)) {\n                const createService = init.services[name];\n                const service = createService(this.components);\n                if (service == null) {\n                    this.log.error('service factory %s returned null or undefined instance', name);\n                    continue;\n                }\n                this.services[name] = service;\n                this.configureComponent(name, service);\n                if (service[contentRoutingSymbol] != null) {\n                    this.log('registering service %s for content routing', name);\n                    contentRouters.push(service[contentRoutingSymbol]);\n                }\n                if (service[peerRoutingSymbol] != null) {\n                    this.log('registering service %s for peer routing', name);\n                    peerRouters.push(service[peerRoutingSymbol]);\n                }\n                if (service[peerDiscoverySymbol] != null) {\n                    this.log('registering service %s for peer discovery', name);\n                    service[peerDiscoverySymbol].addEventListener?.('peer', (evt) => {\n                        this.#onDiscoveryPeer(evt);\n                    });\n                }\n            }\n        }\n        // Ensure all services have their required dependencies\n        checkServiceDependencies(components);\n    }\n    configureComponent(name, component) {\n        if (component == null) {\n            this.log.error('component %s was null or undefined', name);\n        }\n        // @ts-expect-error cannot assign props\n        this.components[name] = component;\n        return component;\n    }\n    /**\n     * Starts the libp2p node and all its subsystems\n     */\n    async start() {\n        if (this.status !== 'stopped') {\n            return;\n        }\n        this.status = 'starting';\n        this.log('libp2p is starting');\n        try {\n            await this.components.beforeStart?.();\n            await this.components.start();\n            await this.components.afterStart?.();\n            this.status = 'started';\n            this.safeDispatchEvent('start', { detail: this });\n            this.log('libp2p has started');\n        }\n        catch (err) {\n            this.log.error('An error occurred starting libp2p', err);\n            // set status to 'started' so this.stop() will stop any running components\n            this.status = 'started';\n            await this.stop();\n            throw err;\n        }\n    }\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     */\n    async stop() {\n        if (this.status !== 'started') {\n            return;\n        }\n        this.log('libp2p is stopping');\n        this.status = 'stopping';\n        await this.components.beforeStop?.();\n        await this.components.stop();\n        await this.components.afterStop?.();\n        this.status = 'stopped';\n        this.safeDispatchEvent('stop', { detail: this });\n        this.log('libp2p has stopped');\n    }\n    getConnections(peerId) {\n        return this.components.connectionManager.getConnections(peerId);\n    }\n    getDialQueue() {\n        return this.components.connectionManager.getDialQueue();\n    }\n    getPeers() {\n        const peerSet = new PeerSet();\n        for (const conn of this.components.connectionManager.getConnections()) {\n            peerSet.add(conn.remotePeer);\n        }\n        return Array.from(peerSet);\n    }\n    async dial(peer, options = {}) {\n        return this.components.connectionManager.openConnection(peer, {\n            // ensure any userland dials take top priority in the queue\n            priority: 75,\n            ...options\n        });\n    }\n    async dialProtocol(peer, protocols, options = {}) {\n        if (protocols == null) {\n            throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n        }\n        protocols = Array.isArray(protocols) ? protocols : [protocols];\n        if (protocols.length === 0) {\n            throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n        }\n        const connection = await this.dial(peer, options);\n        return connection.newStream(protocols, options);\n    }\n    getMultiaddrs() {\n        return this.components.addressManager.getAddresses();\n    }\n    getProtocols() {\n        return this.components.registrar.getProtocols();\n    }\n    async hangUp(peer, options = {}) {\n        if (isMultiaddr(peer)) {\n            peer = peerIdFromString(peer.getPeerId() ?? '');\n        }\n        await this.components.connectionManager.closeConnections(peer, options);\n    }\n    /**\n     * Get the public key for the given peer id\n     */\n    async getPublicKey(peer, options = {}) {\n        this.log('getPublicKey %p', peer);\n        if (peer.publicKey != null) {\n            return peer.publicKey;\n        }\n        try {\n            const peerInfo = await this.peerStore.get(peer);\n            if (peerInfo.id.publicKey != null) {\n                return peerInfo.id.publicKey;\n            }\n        }\n        catch (err) {\n            if (err.code !== codes.ERR_NOT_FOUND) {\n                throw err;\n            }\n        }\n        const peerKey = uint8ArrayConcat([\n            uint8ArrayFromString('/pk/'),\n            peer.multihash.digest\n        ]);\n        // search any available content routing methods\n        const bytes = await this.contentRouting.get(peerKey, options);\n        // ensure the returned key is valid\n        unmarshalPublicKey(bytes);\n        await this.peerStore.patch(peer, {\n            publicKey: bytes\n        });\n        return bytes;\n    }\n    async handle(protocols, handler, options) {\n        if (!Array.isArray(protocols)) {\n            protocols = [protocols];\n        }\n        await Promise.all(protocols.map(async (protocol) => {\n            await this.components.registrar.handle(protocol, handler, options);\n        }));\n    }\n    async unhandle(protocols) {\n        if (!Array.isArray(protocols)) {\n            protocols = [protocols];\n        }\n        await Promise.all(protocols.map(async (protocol) => {\n            await this.components.registrar.unhandle(protocol);\n        }));\n    }\n    async register(protocol, topology) {\n        return this.components.registrar.register(protocol, topology);\n    }\n    unregister(id) {\n        this.components.registrar.unregister(id);\n    }\n    async isDialable(multiaddr, options = {}) {\n        return this.components.connectionManager.isDialable(multiaddr, options);\n    }\n    /**\n     * Called whenever peer discovery services emit `peer` events and adds peers\n     * to the peer store.\n     */\n    #onDiscoveryPeer(evt) {\n        const { detail: peer } = evt;\n        if (peer.id.toString() === this.peerId.toString()) {\n            this.log.error(new Error(codes.ERR_DISCOVERED_SELF));\n            return;\n        }\n        void this.components.peerStore.merge(peer.id, {\n            multiaddrs: peer.multiaddrs\n        })\n            .catch(err => { this.log.error(err); });\n    }\n}\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */\nexport async function createLibp2pNode(options = {}) {\n    const peerId = options.peerId ??= await createEd25519PeerId();\n    if (peerId.privateKey == null) {\n        throw new CodeError('peer id was missing private key', 'ERR_MISSING_PRIVATE_KEY');\n    }\n    options.privateKey ??= await unmarshalPrivateKey(peerId.privateKey);\n    return new Libp2pNode(await validateConfig(options));\n}\n//# sourceMappingURL=libp2p.js.map","import { CodeError } from '@libp2p/interface';\nimport { createScalableCuckooFilter } from '@libp2p/utils/filters';\nimport merge from 'it-merge';\nimport parallel from 'it-parallel';\nimport { codes, messages } from './errors.js';\nexport class DefaultPeerRouting {\n    log;\n    peerId;\n    peerStore;\n    routers;\n    constructor(components, init = {}) {\n        this.log = components.logger.forComponent('libp2p:peer-routing');\n        this.peerId = components.peerId;\n        this.peerStore = components.peerStore;\n        this.routers = init.routers ?? [];\n    }\n    [Symbol.toStringTag] = '@libp2p/peer-routing';\n    /**\n     * Iterates over all peer routers in parallel to find the given peer\n     */\n    async findPeer(id, options) {\n        if (this.routers.length === 0) {\n            throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        if (id.toString() === this.peerId.toString()) {\n            throw new CodeError('Should not try to find self', codes.ERR_FIND_SELF);\n        }\n        const self = this;\n        const source = merge(...this.routers.map(router => (async function* () {\n            try {\n                yield await router.findPeer(id, options);\n            }\n            catch (err) {\n                self.log.error(err);\n            }\n        })()));\n        for await (const peer of source) {\n            if (peer == null) {\n                continue;\n            }\n            // store the addresses for the peer if found\n            if (peer.multiaddrs.length > 0) {\n                await this.peerStore.merge(peer.id, {\n                    multiaddrs: peer.multiaddrs\n                });\n            }\n            return peer;\n        }\n        throw new CodeError(messages.NOT_FOUND, codes.ERR_NOT_FOUND);\n    }\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     */\n    async *getClosestPeers(key, options = {}) {\n        if (this.routers.length === 0) {\n            throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE);\n        }\n        const self = this;\n        const seen = createScalableCuckooFilter(1024);\n        for await (const peer of parallel(async function* () {\n            const source = merge(...self.routers.map(router => router.getClosestPeers(key, options)));\n            for await (let peer of source) {\n                yield async () => {\n                    // find multiaddrs if they are missing\n                    if (peer.multiaddrs.length === 0) {\n                        try {\n                            peer = await self.findPeer(peer.id, {\n                                ...options,\n                                useCache: false\n                            });\n                        }\n                        catch (err) {\n                            self.log.error('could not find peer multiaddrs', err);\n                            return;\n                        }\n                    }\n                    return peer;\n                };\n            }\n        }())) {\n            if (peer == null) {\n                continue;\n            }\n            // store the addresses for the peer if found\n            if (peer.multiaddrs.length > 0) {\n                await this.peerStore.merge(peer.id, {\n                    multiaddrs: peer.multiaddrs\n                });\n            }\n            // deduplicate peers\n            if (seen.has(peer.id.toBytes())) {\n                continue;\n            }\n            seen.add(peer.id.toBytes());\n            yield peer;\n        }\n    }\n}\n//# sourceMappingURL=peer-routing.js.map","import { randomBytes } from '@libp2p/crypto';\nimport { TypedEventEmitter, setMaxListeners } from '@libp2p/interface';\nimport { anySignal } from 'any-signal';\nimport pDefer, {} from 'p-defer';\nimport { raceEvent } from 'race-event';\nimport { raceSignal } from 'race-signal';\nexport class RandomWalk extends TypedEventEmitter {\n    peerRouting;\n    log;\n    walking;\n    walkers;\n    shutdownController;\n    walkController;\n    needNext;\n    constructor(components) {\n        super();\n        this.log = components.logger.forComponent('libp2p:random-walk');\n        this.peerRouting = components.peerRouting;\n        this.walkers = 0;\n        this.walking = false;\n        // stops any in-progress walks when the node is shut down\n        this.shutdownController = new AbortController();\n        setMaxListeners(Infinity, this.shutdownController.signal);\n    }\n    [Symbol.toStringTag] = '@libp2p/random-walk';\n    start() {\n        this.shutdownController = new AbortController();\n        setMaxListeners(Infinity, this.shutdownController.signal);\n    }\n    stop() {\n        this.shutdownController.abort();\n    }\n    async *walk(options) {\n        if (!this.walking) {\n            // start the query that causes walk:peer events to be emitted\n            this.startWalk();\n        }\n        this.walkers++;\n        const signal = anySignal([this.shutdownController.signal, options?.signal]);\n        setMaxListeners(Infinity, signal);\n        try {\n            while (true) {\n                // if another consumer has paused the query, start it again\n                this.needNext?.resolve();\n                this.needNext = pDefer();\n                // wait for a walk:peer or walk:error event\n                const event = await raceEvent(this, 'walk:peer', signal, {\n                    errorEvent: 'walk:error'\n                });\n                yield event.detail;\n            }\n        }\n        finally {\n            signal.clear();\n            this.walkers--;\n            // stop the walk if no more consumers are interested\n            if (this.walkers === 0) {\n                this.walkController?.abort();\n                this.walkController = undefined;\n            }\n        }\n    }\n    startWalk() {\n        this.walking = true;\n        // the signal for this controller will be aborted if no more random peers\n        // are required\n        this.walkController = new AbortController();\n        setMaxListeners(Infinity, this.walkController.signal);\n        const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);\n        setMaxListeners(Infinity, signal);\n        const start = Date.now();\n        let found = 0;\n        Promise.resolve().then(async () => {\n            this.log('start walk');\n            // find peers until no more consumers are interested\n            while (this.walkers > 0) {\n                try {\n                    const data = randomBytes(32);\n                    let s = Date.now();\n                    for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {\n                        if (signal.aborted) {\n                            this.log('aborting walk');\n                        }\n                        signal.throwIfAborted();\n                        this.log('found peer %p after %dms for %d walkers', peer.id, Date.now() - s, this.walkers);\n                        found++;\n                        this.safeDispatchEvent('walk:peer', {\n                            detail: peer\n                        });\n                        // if we only have one consumer, pause the query until they request\n                        // another random peer or they signal they are no longer interested\n                        if (this.walkers === 1 && this.needNext != null) {\n                            this.log('wait for need next');\n                            await raceSignal(this.needNext.promise, signal);\n                        }\n                        s = Date.now();\n                    }\n                    this.log('walk iteration for %b and %d walkers finished, found %d peers', data, this.walkers, found);\n                }\n                catch (err) {\n                    this.log.error('randomwalk errored', err);\n                    this.safeDispatchEvent('walk:error', {\n                        detail: err\n                    });\n                }\n            }\n            this.log('no walkers left, ended walk');\n        })\n            .catch(err => {\n            this.log.error('randomwalk errored', err);\n        })\n            .finally(() => {\n            this.log('finished walk, found %d peers after %dms', found, Date.now() - start);\n            this.walking = false;\n        });\n    }\n}\n//# sourceMappingURL=random-walk.js.map","import { CodeError } from '@libp2p/interface';\nimport merge from 'merge-options';\nimport { codes } from './errors.js';\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32;\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64;\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar {\n    log;\n    topologies;\n    handlers;\n    components;\n    constructor(components) {\n        this.log = components.logger.forComponent('libp2p:registrar');\n        this.topologies = new Map();\n        this.handlers = new Map();\n        this.components = components;\n        this._onDisconnect = this._onDisconnect.bind(this);\n        this._onPeerUpdate = this._onPeerUpdate.bind(this);\n        this._onPeerIdentify = this._onPeerIdentify.bind(this);\n        this.components.events.addEventListener('peer:disconnect', this._onDisconnect);\n        this.components.events.addEventListener('peer:update', this._onPeerUpdate);\n        this.components.events.addEventListener('peer:identify', this._onPeerIdentify);\n    }\n    [Symbol.toStringTag] = '@libp2p/registrar';\n    getProtocols() {\n        return Array.from(new Set([\n            ...this.handlers.keys()\n        ])).sort();\n    }\n    getHandler(protocol) {\n        const handler = this.handlers.get(protocol);\n        if (handler == null) {\n            throw new CodeError(`No handler registered for protocol ${protocol}`, codes.ERR_NO_HANDLER_FOR_PROTOCOL);\n        }\n        return handler;\n    }\n    getTopologies(protocol) {\n        const topologies = this.topologies.get(protocol);\n        if (topologies == null) {\n            return [];\n        }\n        return [\n            ...topologies.values()\n        ];\n    }\n    /**\n     * Registers the `handler` for each protocol\n     */\n    async handle(protocol, handler, opts) {\n        if (this.handlers.has(protocol)) {\n            throw new CodeError(`Handler already registered for protocol ${protocol}`, codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);\n        }\n        const options = merge.bind({ ignoreUndefined: true })({\n            maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n            maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n        }, opts);\n        this.handlers.set(protocol, {\n            handler,\n            options\n        });\n        // Add new protocol to self protocols in the peer store\n        await this.components.peerStore.merge(this.components.peerId, {\n            protocols: [protocol]\n        });\n    }\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     */\n    async unhandle(protocols) {\n        const protocolList = Array.isArray(protocols) ? protocols : [protocols];\n        protocolList.forEach(protocol => {\n            this.handlers.delete(protocol);\n        });\n        // Update self protocols in the peer store\n        await this.components.peerStore.patch(this.components.peerId, {\n            protocols: this.getProtocols()\n        });\n    }\n    /**\n     * Register handlers for a set of multicodecs given\n     */\n    async register(protocol, topology) {\n        if (topology == null) {\n            throw new CodeError('invalid topology', codes.ERR_INVALID_PARAMETERS);\n        }\n        // Create topology\n        const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;\n        let topologies = this.topologies.get(protocol);\n        if (topologies == null) {\n            topologies = new Map();\n            this.topologies.set(protocol, topologies);\n        }\n        topologies.set(id, topology);\n        return id;\n    }\n    /**\n     * Unregister topology\n     */\n    unregister(id) {\n        for (const [protocol, topologies] of this.topologies.entries()) {\n            if (topologies.has(id)) {\n                topologies.delete(id);\n                if (topologies.size === 0) {\n                    this.topologies.delete(protocol);\n                }\n            }\n        }\n    }\n    /**\n     * Remove a disconnected peer from the record\n     */\n    _onDisconnect(evt) {\n        const remotePeer = evt.detail;\n        void this.components.peerStore.get(remotePeer)\n            .then(peer => {\n            for (const protocol of peer.protocols) {\n                const topologies = this.topologies.get(protocol);\n                if (topologies == null) {\n                    // no topologies are interested in this protocol\n                    continue;\n                }\n                for (const topology of topologies.values()) {\n                    if (topology.filter?.has(remotePeer) === false) {\n                        continue;\n                    }\n                    topology.filter?.remove(remotePeer);\n                    topology.onDisconnect?.(remotePeer);\n                }\n            }\n        })\n            .catch(err => {\n            if (err.code === codes.ERR_NOT_FOUND) {\n                // peer has not completed identify so they are not in the peer store\n                return;\n            }\n            this.log.error('could not inform topologies of disconnecting peer %p', remotePeer, err);\n        });\n    }\n    /**\n     * When a peer is updated, if they have removed supported protocols notify any\n     * topologies interested in the removed protocols.\n     */\n    _onPeerUpdate(evt) {\n        const { peer, previous } = evt.detail;\n        const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol));\n        for (const protocol of removed) {\n            const topologies = this.topologies.get(protocol);\n            if (topologies == null) {\n                // no topologies are interested in this protocol\n                continue;\n            }\n            for (const topology of topologies.values()) {\n                if (topology.filter?.has(peer.id) === false) {\n                    continue;\n                }\n                topology.filter?.remove(peer.id);\n                topology.onDisconnect?.(peer.id);\n            }\n        }\n    }\n    /**\n     * After identify has completed and we have received the list of supported\n     * protocols, notify any topologies interested in those protocols.\n     */\n    _onPeerIdentify(evt) {\n        const protocols = evt.detail.protocols;\n        const connection = evt.detail.connection;\n        const peerId = evt.detail.peerId;\n        for (const protocol of protocols) {\n            const topologies = this.topologies.get(protocol);\n            if (topologies == null) {\n                // no topologies are interested in this protocol\n                continue;\n            }\n            for (const topology of topologies.values()) {\n                if (connection.transient && topology.notifyOnTransient !== true) {\n                    continue;\n                }\n                if (topology.filter?.has(peerId) === true) {\n                    continue;\n                }\n                topology.filter?.add(peerId);\n                topology.onConnect?.(peerId, connection);\n            }\n        }\n    }\n}\n//# sourceMappingURL=registrar.js.map","import { CodeError, FaultTolerance } from '@libp2p/interface';\nimport { trackedMap } from '@libp2p/utils/tracked-map';\nimport { CustomProgressEvent } from 'progress-events';\nimport { codes } from './errors.js';\nexport class DefaultTransportManager {\n    log;\n    components;\n    transports;\n    listeners;\n    faultTolerance;\n    started;\n    constructor(components, init = {}) {\n        this.log = components.logger.forComponent('libp2p:transports');\n        this.components = components;\n        this.started = false;\n        this.transports = new Map();\n        this.listeners = trackedMap({\n            name: 'libp2p_transport_manager_listeners',\n            metrics: this.components.metrics\n        });\n        this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;\n    }\n    [Symbol.toStringTag] = '@libp2p/transport-manager';\n    /**\n     * Adds a `Transport` to the manager\n     */\n    add(transport) {\n        const tag = transport[Symbol.toStringTag];\n        if (tag == null) {\n            throw new CodeError('Transport must have a valid tag', codes.ERR_INVALID_KEY);\n        }\n        if (this.transports.has(tag)) {\n            throw new CodeError(`There is already a transport with the tag ${tag}`, codes.ERR_DUPLICATE_TRANSPORT);\n        }\n        this.log('adding transport %s', tag);\n        this.transports.set(tag, transport);\n        if (!this.listeners.has(tag)) {\n            this.listeners.set(tag, []);\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    start() {\n        this.started = true;\n    }\n    async afterStart() {\n        // Listen on the provided transports for the provided addresses\n        const addrs = this.components.addressManager.getListenAddrs();\n        await this.listen(addrs);\n    }\n    /**\n     * Stops all listeners\n     */\n    async stop() {\n        const tasks = [];\n        for (const [key, listeners] of this.listeners) {\n            this.log('closing listeners for %s', key);\n            while (listeners.length > 0) {\n                const listener = listeners.pop();\n                if (listener == null) {\n                    continue;\n                }\n                tasks.push(listener.close());\n            }\n        }\n        await Promise.all(tasks);\n        this.log('all listeners closed');\n        for (const key of this.listeners.keys()) {\n            this.listeners.set(key, []);\n        }\n        this.started = false;\n    }\n    /**\n     * Dials the given Multiaddr over it's supported transport\n     */\n    async dial(ma, options) {\n        const transport = this.dialTransportForMultiaddr(ma);\n        if (transport == null) {\n            throw new CodeError(`No transport available for address ${String(ma)}`, codes.ERR_TRANSPORT_UNAVAILABLE);\n        }\n        options?.onProgress?.(new CustomProgressEvent('transport-manager:selected-transport', transport[Symbol.toStringTag]));\n        try {\n            // @ts-expect-error the transport has a typed onProgress option but we\n            // can't predict what transport implementation we selected so all we can\n            // do is pass the onProgress handler in and hope for the best\n            return await transport.dial(ma, {\n                ...options,\n                upgrader: this.components.upgrader\n            });\n        }\n        catch (err) {\n            if (err.code == null) {\n                err.code = codes.ERR_TRANSPORT_DIAL_FAILED;\n            }\n            throw err;\n        }\n    }\n    /**\n     * Returns all Multiaddr's the listeners are using\n     */\n    getAddrs() {\n        let addrs = [];\n        for (const listeners of this.listeners.values()) {\n            for (const listener of listeners) {\n                addrs = [...addrs, ...listener.getAddrs()];\n            }\n        }\n        return addrs;\n    }\n    /**\n     * Returns all the transports instances\n     */\n    getTransports() {\n        return Array.of(...this.transports.values());\n    }\n    /**\n     * Returns all the listener instances\n     */\n    getListeners() {\n        return Array.of(...this.listeners.values()).flat();\n    }\n    /**\n     * Finds a transport that matches the given Multiaddr\n     */\n    dialTransportForMultiaddr(ma) {\n        for (const transport of this.transports.values()) {\n            const addrs = transport.dialFilter([ma]);\n            if (addrs.length > 0) {\n                return transport;\n            }\n        }\n    }\n    /**\n     * Finds a transport that matches the given Multiaddr\n     */\n    listenTransportForMultiaddr(ma) {\n        for (const transport of this.transports.values()) {\n            const addrs = transport.listenFilter([ma]);\n            if (addrs.length > 0) {\n                return transport;\n            }\n        }\n    }\n    /**\n     * Starts listeners for each listen Multiaddr\n     */\n    async listen(addrs) {\n        if (!this.isStarted()) {\n            throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED);\n        }\n        if (addrs == null || addrs.length === 0) {\n            this.log('no addresses were provided for listening, this node is dial only');\n            return;\n        }\n        const couldNotListen = [];\n        for (const [key, transport] of this.transports.entries()) {\n            const supportedAddrs = transport.listenFilter(addrs);\n            const tasks = [];\n            // For each supported multiaddr, create a listener\n            for (const addr of supportedAddrs) {\n                this.log('creating listener for %s on %a', key, addr);\n                const listener = transport.createListener({\n                    upgrader: this.components.upgrader\n                });\n                let listeners = this.listeners.get(key) ?? [];\n                if (listeners == null) {\n                    listeners = [];\n                    this.listeners.set(key, listeners);\n                }\n                listeners.push(listener);\n                // Track listen/close events\n                listener.addEventListener('listening', () => {\n                    this.components.events.safeDispatchEvent('transport:listening', {\n                        detail: listener\n                    });\n                });\n                listener.addEventListener('close', () => {\n                    const index = listeners.findIndex(l => l === listener);\n                    // remove the listener\n                    listeners.splice(index, 1);\n                    this.components.events.safeDispatchEvent('transport:close', {\n                        detail: listener\n                    });\n                });\n                // We need to attempt to listen on everything\n                tasks.push(listener.listen(addr));\n            }\n            // Keep track of transports we had no addresses for\n            if (tasks.length === 0) {\n                couldNotListen.push(key);\n                continue;\n            }\n            const results = await Promise.allSettled(tasks);\n            // If we are listening on at least 1 address, succeed.\n            // TODO: we should look at adding a retry (`p-retry`) here to better support\n            // listening on remote addresses as they may be offline. We could then potentially\n            // just wait for any (`p-any`) listener to succeed on each transport before returning\n            const isListening = results.find(r => r.status === 'fulfilled');\n            if ((isListening == null) && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n                throw new CodeError(`Transport (${key}) could not listen on any available address`, codes.ERR_NO_VALID_ADDRESSES);\n            }\n        }\n        // If no transports were able to listen, throw an error. This likely\n        // means we were given addresses we do not have transports for\n        if (couldNotListen.length === this.transports.size) {\n            const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`;\n            if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n                throw new CodeError(message, codes.ERR_NO_VALID_ADDRESSES);\n            }\n            this.log(`libp2p in dial mode only: ${message}`);\n        }\n    }\n    /**\n     * Removes the given transport from the manager.\n     * If a transport has any running listeners, they will be closed.\n     */\n    async remove(key) {\n        const listeners = this.listeners.get(key) ?? [];\n        this.log.trace('removing transport %s', key);\n        // Close any running listeners\n        const tasks = [];\n        this.log.trace('closing listeners for %s', key);\n        while (listeners.length > 0) {\n            const listener = listeners.pop();\n            if (listener == null) {\n                continue;\n            }\n            tasks.push(listener.close());\n        }\n        await Promise.all(tasks);\n        this.transports.delete(key);\n        this.listeners.delete(key);\n    }\n    /**\n     * Removes all transports from the manager.\n     * If any listeners are running, they will be closed.\n     *\n     * @async\n     */\n    async removeAll() {\n        const tasks = [];\n        for (const key of this.transports.keys()) {\n            tasks.push(this.remove(key));\n        }\n        await Promise.all(tasks);\n    }\n}\n//# sourceMappingURL=transport-manager.js.map","import { CodeError, ERR_TIMEOUT, setMaxListeners } from '@libp2p/interface';\nimport * as mss from '@libp2p/multistream-select';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { CustomProgressEvent } from 'progress-events';\nimport { createConnection } from './connection/index.js';\nimport { INBOUND_UPGRADE_TIMEOUT } from './connection-manager/constants.js';\nimport { codes } from './errors.js';\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js';\nconst DEFAULT_PROTOCOL_SELECT_TIMEOUT = 30000;\nfunction findIncomingStreamLimit(protocol, registrar) {\n    try {\n        const { options } = registrar.getHandler(protocol);\n        return options.maxInboundStreams;\n    }\n    catch (err) {\n        if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n            throw err;\n        }\n    }\n    return DEFAULT_MAX_INBOUND_STREAMS;\n}\nfunction findOutgoingStreamLimit(protocol, registrar, options = {}) {\n    try {\n        const { options } = registrar.getHandler(protocol);\n        if (options.maxOutboundStreams != null) {\n            return options.maxOutboundStreams;\n        }\n    }\n    catch (err) {\n        if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n            throw err;\n        }\n    }\n    return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n}\nfunction countStreams(protocol, direction, connection) {\n    let streamCount = 0;\n    connection.streams.forEach(stream => {\n        if (stream.direction === direction && stream.protocol === protocol) {\n            streamCount++;\n        }\n    });\n    return streamCount;\n}\nexport class DefaultUpgrader {\n    components;\n    connectionEncryption;\n    muxers;\n    inboundUpgradeTimeout;\n    events;\n    constructor(components, init) {\n        this.components = components;\n        this.connectionEncryption = new Map();\n        init.connectionEncryption.forEach(encrypter => {\n            this.connectionEncryption.set(encrypter.protocol, encrypter);\n        });\n        this.muxers = new Map();\n        init.muxers.forEach(muxer => {\n            this.muxers.set(muxer.protocol, muxer);\n        });\n        this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;\n        this.events = components.events;\n    }\n    [Symbol.toStringTag] = '@libp2p/upgrader';\n    async shouldBlockConnection(remotePeer, maConn, connectionType) {\n        const connectionGater = this.components.connectionGater[connectionType];\n        if (connectionGater !== undefined) {\n            if (await connectionGater(remotePeer, maConn)) {\n                throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes.ERR_CONNECTION_INTERCEPTED);\n            }\n        }\n    }\n    /**\n     * Upgrades an inbound connection\n     */\n    async upgradeInbound(maConn, opts) {\n        const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);\n        if (!accept) {\n            throw new CodeError('connection denied', codes.ERR_CONNECTION_DENIED);\n        }\n        let encryptedConn;\n        let remotePeer;\n        let upgradedConn;\n        let muxerFactory;\n        let cryptoProtocol;\n        const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);\n        const onAbort = () => {\n            maConn.abort(new CodeError('inbound upgrade timeout', ERR_TIMEOUT));\n        };\n        signal.addEventListener('abort', onAbort, { once: true });\n        setMaxListeners(Infinity, signal);\n        try {\n            if ((await this.components.connectionGater.denyInboundConnection?.(maConn)) === true) {\n                throw new CodeError('The multiaddr connection is blocked by gater.acceptConnection', codes.ERR_CONNECTION_INTERCEPTED);\n            }\n            this.components.metrics?.trackMultiaddrConnection(maConn);\n            maConn.log('starting the inbound connection upgrade');\n            // Protect\n            let protectedConn = maConn;\n            if (opts?.skipProtection !== true) {\n                const protector = this.components.connectionProtector;\n                if (protector != null) {\n                    maConn.log('protecting the inbound connection');\n                    protectedConn = await protector.protect(maConn);\n                }\n            }\n            try {\n                // Encrypt the connection\n                encryptedConn = protectedConn;\n                if (opts?.skipEncryption !== true) {\n                    opts?.onProgress?.(new CustomProgressEvent('upgrader:encrypt-inbound-connection'));\n                    ({\n                        conn: encryptedConn,\n                        remotePeer,\n                        protocol: cryptoProtocol\n                    } = await this._encryptInbound(protectedConn));\n                    const maConn = {\n                        ...protectedConn,\n                        ...encryptedConn\n                    };\n                    await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundEncryptedConnection');\n                }\n                else {\n                    const idStr = maConn.remoteAddr.getPeerId();\n                    if (idStr == null) {\n                        throw new CodeError('inbound connection that skipped encryption must have a peer id', codes.ERR_INVALID_MULTIADDR);\n                    }\n                    const remotePeerId = peerIdFromString(idStr);\n                    cryptoProtocol = 'native';\n                    remotePeer = remotePeerId;\n                }\n                upgradedConn = encryptedConn;\n                if (opts?.muxerFactory != null) {\n                    muxerFactory = opts.muxerFactory;\n                }\n                else if (this.muxers.size > 0) {\n                    opts?.onProgress?.(new CustomProgressEvent('upgrader:multiplex-inbound-connection'));\n                    // Multiplex the connection\n                    const multiplexed = await this._multiplexInbound({\n                        ...protectedConn,\n                        ...encryptedConn\n                    }, this.muxers);\n                    muxerFactory = multiplexed.muxerFactory;\n                    upgradedConn = multiplexed.stream;\n                }\n            }\n            catch (err) {\n                maConn.log.error('failed to upgrade inbound connection', err);\n                throw err;\n            }\n            await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundUpgradedConnection');\n            maConn.log('successfully upgraded inbound connection');\n            return this._createConnection({\n                cryptoProtocol,\n                direction: 'inbound',\n                maConn,\n                upgradedConn,\n                muxerFactory,\n                remotePeer,\n                transient: opts?.transient\n            });\n        }\n        finally {\n            signal.removeEventListener('abort', onAbort);\n            this.components.connectionManager.afterUpgradeInbound();\n        }\n    }\n    /**\n     * Upgrades an outbound connection\n     */\n    async upgradeOutbound(maConn, opts) {\n        const idStr = maConn.remoteAddr.getPeerId();\n        let remotePeerId;\n        if (idStr != null) {\n            remotePeerId = peerIdFromString(idStr);\n            await this.shouldBlockConnection(remotePeerId, maConn, 'denyOutboundConnection');\n        }\n        let encryptedConn;\n        let remotePeer;\n        let upgradedConn;\n        let cryptoProtocol;\n        let muxerFactory;\n        this.components.metrics?.trackMultiaddrConnection(maConn);\n        maConn.log('starting the outbound connection upgrade');\n        // If the transport natively supports encryption, skip connection\n        // protector and encryption\n        // Protect\n        let protectedConn = maConn;\n        if (opts?.skipProtection !== true) {\n            const protector = this.components.connectionProtector;\n            if (protector != null) {\n                protectedConn = await protector.protect(maConn);\n            }\n        }\n        try {\n            // Encrypt the connection\n            encryptedConn = protectedConn;\n            if (opts?.skipEncryption !== true) {\n                ({\n                    conn: encryptedConn,\n                    remotePeer,\n                    protocol: cryptoProtocol\n                } = await this._encryptOutbound(protectedConn, remotePeerId));\n                const maConn = {\n                    ...protectedConn,\n                    ...encryptedConn\n                };\n                await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundEncryptedConnection');\n            }\n            else {\n                if (remotePeerId == null) {\n                    throw new CodeError('Encryption was skipped but no peer id was passed', codes.ERR_INVALID_PEER);\n                }\n                cryptoProtocol = 'native';\n                remotePeer = remotePeerId;\n            }\n            upgradedConn = encryptedConn;\n            if (opts?.muxerFactory != null) {\n                muxerFactory = opts.muxerFactory;\n            }\n            else if (this.muxers.size > 0) {\n                // Multiplex the connection\n                const multiplexed = await this._multiplexOutbound({\n                    ...protectedConn,\n                    ...encryptedConn\n                }, this.muxers);\n                muxerFactory = multiplexed.muxerFactory;\n                upgradedConn = multiplexed.stream;\n            }\n        }\n        catch (err) {\n            maConn.log.error('failed to upgrade outbound connection', err);\n            await maConn.close(err);\n            throw err;\n        }\n        await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundUpgradedConnection');\n        maConn.log('successfully upgraded outbound connection');\n        return this._createConnection({\n            cryptoProtocol,\n            direction: 'outbound',\n            maConn,\n            upgradedConn,\n            muxerFactory,\n            remotePeer,\n            transient: opts?.transient\n        });\n    }\n    /**\n     * A convenience method for generating a new `Connection`\n     */\n    _createConnection(opts) {\n        const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;\n        let muxer;\n        let newStream;\n        let connection; // eslint-disable-line prefer-const\n        if (muxerFactory != null) {\n            // Create the muxer\n            muxer = muxerFactory.createStreamMuxer({\n                direction,\n                // Run anytime a remote stream is created\n                onIncomingStream: muxedStream => {\n                    if (connection == null) {\n                        return;\n                    }\n                    void Promise.resolve()\n                        .then(async () => {\n                        const protocols = this.components.registrar.getProtocols();\n                        const { stream, protocol } = await mss.handle(muxedStream, protocols, {\n                            log: muxedStream.log,\n                            yieldBytes: false\n                        });\n                        if (connection == null) {\n                            return;\n                        }\n                        connection.log('incoming stream opened on %s', protocol);\n                        const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);\n                        const streamCount = countStreams(protocol, 'inbound', connection);\n                        if (streamCount === incomingLimit) {\n                            const err = new CodeError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`, codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);\n                            muxedStream.abort(err);\n                            throw err;\n                        }\n                        // after the handshake the returned stream can have early data so override\n                        // the souce/sink\n                        muxedStream.source = stream.source;\n                        muxedStream.sink = stream.sink;\n                        muxedStream.protocol = protocol;\n                        // allow closing the write end of a not-yet-negotiated stream\n                        if (stream.closeWrite != null) {\n                            muxedStream.closeWrite = stream.closeWrite;\n                        }\n                        // allow closing the read end of a not-yet-negotiated stream\n                        if (stream.closeRead != null) {\n                            muxedStream.closeRead = stream.closeRead;\n                        }\n                        // make sure we don't try to negotiate a stream we are closing\n                        if (stream.close != null) {\n                            muxedStream.close = stream.close;\n                        }\n                        // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                        // the peerstore should ensure that the peer is registered with that protocol\n                        await this.components.peerStore.merge(remotePeer, {\n                            protocols: [protocol]\n                        });\n                        this.components.metrics?.trackProtocolStream(muxedStream, connection);\n                        this._onStream({ connection, stream: muxedStream, protocol });\n                    })\n                        .catch(async (err) => {\n                        connection.log.error('error handling incoming stream id %s', muxedStream.id, err.message, err.code, err.stack);\n                        if (muxedStream.timeline.close == null) {\n                            await muxedStream.close();\n                        }\n                    });\n                }\n            });\n            newStream = async (protocols, options = {}) => {\n                if (muxer == null) {\n                    throw new CodeError('Stream is not multiplexed', codes.ERR_MUXER_UNAVAILABLE);\n                }\n                connection.log('starting new stream for protocols %s', protocols);\n                const muxedStream = await muxer.newStream();\n                connection.log.trace('started new stream %s for protocols %s', muxedStream.id, protocols);\n                try {\n                    if (options.signal == null) {\n                        muxedStream.log('no abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols);\n                        const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT);\n                        setMaxListeners(Infinity, signal);\n                        options = {\n                            ...options,\n                            signal\n                        };\n                    }\n                    muxedStream.log.trace('selecting protocol from protocols %s', protocols);\n                    const { stream, protocol } = await mss.select(muxedStream, protocols, {\n                        ...options,\n                        log: muxedStream.log,\n                        yieldBytes: true\n                    });\n                    muxedStream.log('selected protocol %s', protocol);\n                    const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);\n                    const streamCount = countStreams(protocol, 'outbound', connection);\n                    if (streamCount >= outgoingLimit) {\n                        const err = new CodeError(`Too many outbound protocol streams for protocol \"${protocol}\" - ${streamCount}/${outgoingLimit}`, codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);\n                        muxedStream.abort(err);\n                        throw err;\n                    }\n                    // If a protocol stream has been successfully negotiated and is to be passed to the application,\n                    // the peerstore should ensure that the peer is registered with that protocol\n                    await this.components.peerStore.merge(remotePeer, {\n                        protocols: [protocol]\n                    });\n                    // after the handshake the returned stream can have early data so override\n                    // the souce/sink\n                    muxedStream.source = stream.source;\n                    muxedStream.sink = stream.sink;\n                    muxedStream.protocol = protocol;\n                    // allow closing the write end of a not-yet-negotiated stream\n                    if (stream.closeWrite != null) {\n                        muxedStream.closeWrite = stream.closeWrite;\n                    }\n                    // allow closing the read end of a not-yet-negotiated stream\n                    if (stream.closeRead != null) {\n                        muxedStream.closeRead = stream.closeRead;\n                    }\n                    // make sure we don't try to negotiate a stream we are closing\n                    if (stream.close != null) {\n                        muxedStream.close = stream.close;\n                    }\n                    this.components.metrics?.trackProtocolStream(muxedStream, connection);\n                    return muxedStream;\n                }\n                catch (err) {\n                    connection.log.error('could not create new stream for protocols %s', protocols, err);\n                    if (muxedStream.timeline.close == null) {\n                        muxedStream.abort(err);\n                    }\n                    if (err.code != null) {\n                        throw err;\n                    }\n                    throw new CodeError(String(err), codes.ERR_UNSUPPORTED_PROTOCOL);\n                }\n            };\n            // Pipe all data through the muxer\n            void Promise.all([\n                muxer.sink(upgradedConn.source),\n                upgradedConn.sink(muxer.source)\n            ]).catch(err => {\n                connection.log.error('error piping data through muxer', err);\n            });\n        }\n        const _timeline = maConn.timeline;\n        maConn.timeline = new Proxy(_timeline, {\n            set: (...args) => {\n                if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n                    // Wait for close to finish before notifying of the closure\n                    (async () => {\n                        try {\n                            if (connection.status === 'open') {\n                                await connection.close();\n                            }\n                        }\n                        catch (err) {\n                            connection.log.error('error closing connection after timeline close', err);\n                        }\n                        finally {\n                            this.events.safeDispatchEvent('connection:close', {\n                                detail: connection\n                            });\n                        }\n                    })().catch(err => {\n                        connection.log.error('error thrown while dispatching connection:close event', err);\n                    });\n                }\n                return Reflect.set(...args);\n            }\n        });\n        maConn.timeline.upgraded = Date.now();\n        const errConnectionNotMultiplexed = () => {\n            throw new CodeError('connection is not multiplexed', codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n        };\n        // Create the connection\n        connection = createConnection({\n            remoteAddr: maConn.remoteAddr,\n            remotePeer,\n            status: 'open',\n            direction,\n            timeline: maConn.timeline,\n            multiplexer: muxer?.protocol,\n            encryption: cryptoProtocol,\n            transient,\n            logger: this.components.logger,\n            newStream: newStream ?? errConnectionNotMultiplexed,\n            getStreams: () => { if (muxer != null) {\n                return muxer.streams;\n            }\n            else {\n                return [];\n            } },\n            close: async (options) => {\n                // Ensure remaining streams are closed gracefully\n                if (muxer != null) {\n                    connection.log.trace('close muxer');\n                    await muxer.close(options);\n                }\n                connection.log.trace('close maconn');\n                // close the underlying transport\n                await maConn.close(options);\n                connection.log.trace('closed maconn');\n            },\n            abort: (err) => {\n                maConn.abort(err);\n                // Ensure remaining streams are aborted\n                if (muxer != null) {\n                    muxer.abort(err);\n                }\n            }\n        });\n        this.events.safeDispatchEvent('connection:open', {\n            detail: connection\n        });\n        return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     */\n    _onStream(opts) {\n        const { connection, stream, protocol } = opts;\n        const { handler, options } = this.components.registrar.getHandler(protocol);\n        if (connection.transient && options.runOnTransientConnection !== true) {\n            throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION');\n        }\n        handler({ connection, stream });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n     */\n    async _encryptInbound(connection) {\n        const protocols = Array.from(this.connectionEncryption.keys());\n        connection.log('handling inbound crypto protocol selection', protocols);\n        try {\n            const { stream, protocol } = await mss.handle(connection, protocols, {\n                log: connection.log\n            });\n            const encrypter = this.connectionEncryption.get(protocol);\n            if (encrypter == null) {\n                throw new Error(`no crypto module found for ${protocol}`);\n            }\n            connection.log('encrypting inbound connection using', protocol);\n            return {\n                ...await encrypter.secureInbound(this.components.peerId, stream),\n                protocol\n            };\n        }\n        catch (err) {\n            connection.log.error('encrypting inbound connection failed', err);\n            throw new CodeError(err.message, codes.ERR_ENCRYPTION_FAILED);\n        }\n    }\n    /**\n     * Attempts to encrypt the given `connection` with the provided connection encrypters.\n     * The first `ConnectionEncrypter` module to succeed will be used\n     */\n    async _encryptOutbound(connection, remotePeerId) {\n        const protocols = Array.from(this.connectionEncryption.keys());\n        connection.log('selecting outbound crypto protocol', protocols);\n        try {\n            connection.log.trace('selecting encrypter from %s', protocols);\n            const { stream, protocol } = await mss.select(connection, protocols, {\n                log: connection.log,\n                yieldBytes: true\n            });\n            const encrypter = this.connectionEncryption.get(protocol);\n            if (encrypter == null) {\n                throw new Error(`no crypto module found for ${protocol}`);\n            }\n            connection.log('encrypting outbound connection to %p using %s', remotePeerId, encrypter);\n            return {\n                ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),\n                protocol\n            };\n        }\n        catch (err) {\n            connection.log.error('encrypting outbound connection to %p failed', remotePeerId, err);\n            throw new CodeError(err.message, codes.ERR_ENCRYPTION_FAILED);\n        }\n    }\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     */\n    async _multiplexOutbound(connection, muxers) {\n        const protocols = Array.from(muxers.keys());\n        connection.log('outbound selecting muxer %s', protocols);\n        try {\n            connection.log.trace('selecting stream muxer from %s', protocols);\n            const { stream, protocol } = await mss.select(connection, protocols, {\n                log: connection.log,\n                yieldBytes: true\n            });\n            connection.log('selected %s as muxer protocol', protocol);\n            const muxerFactory = muxers.get(protocol);\n            return { stream, muxerFactory };\n        }\n        catch (err) {\n            connection.log.error('error multiplexing outbound connection', err);\n            throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE);\n        }\n    }\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     */\n    async _multiplexInbound(connection, muxers) {\n        const protocols = Array.from(muxers.keys());\n        connection.log('inbound handling muxers %s', protocols);\n        try {\n            const { stream, protocol } = await mss.handle(connection, protocols, {\n                log: connection.log\n            });\n            const muxerFactory = muxers.get(protocol);\n            return { stream, muxerFactory };\n        }\n        catch (err) {\n            connection.log.error('error multiplexing inbound connection', err);\n            throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE);\n        }\n    }\n}\n//# sourceMappingURL=upgrader.js.map","export const version = '1.9.3';\nexport const name = 'libp2p';\n//# sourceMappingURL=version.js.map","/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */\n\nimport mergeOptions from './index.js';\nexport default mergeOptions;\n","import observer from 'observable-webworkers';\nimport { WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK } from './constants.js';\nimport { nanoid } from './utils.js';\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n    return (worker, event) => {\n        if (event.data.type !== requestType) {\n            return;\n        }\n        const requestEvent = {\n            type: event.data.type,\n            name: event.data.name,\n            identifier: event.data.identifier\n        };\n        emitter.dispatchEvent(new MessageEvent(masterEvent, {\n            data: {\n                name: requestEvent.name,\n                handler: async () => {\n                    // grant lock to worker\n                    worker.postMessage({\n                        type: grantType,\n                        name: requestEvent.name,\n                        identifier: requestEvent.identifier\n                    });\n                    // wait for worker to finish\n                    await new Promise((resolve) => {\n                        const releaseEventListener = (event) => {\n                            if (event == null || event.data == null) {\n                                return;\n                            }\n                            const releaseEvent = {\n                                type: event.data.type,\n                                name: event.data.name,\n                                identifier: event.data.identifier\n                            };\n                            if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                                worker.removeEventListener('message', releaseEventListener);\n                                resolve();\n                            }\n                        };\n                        worker.addEventListener('message', releaseEventListener);\n                    });\n                }\n            }\n        }));\n    };\n};\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n    return async () => {\n        const id = nanoid();\n        globalThis.postMessage({\n            type: requestType,\n            identifier: id,\n            name\n        });\n        return new Promise((resolve) => {\n            const listener = (event) => {\n                if (event == null || event.data == null) {\n                    return;\n                }\n                const responseEvent = {\n                    type: event.data.type,\n                    identifier: event.data.identifier\n                };\n                if (responseEvent.type === grantType && responseEvent.identifier === id) {\n                    globalThis.removeEventListener('message', listener);\n                    // grant lock\n                    resolve(() => {\n                        // release lock\n                        globalThis.postMessage({\n                            type: releaseType,\n                            identifier: id,\n                            name\n                        });\n                    });\n                }\n            };\n            globalThis.addEventListener('message', listener);\n        });\n    };\n};\nconst defaultOptions = {\n    singleProcess: false\n};\nexport default (options) => {\n    options = Object.assign({}, defaultOptions, options);\n    const isPrimary = Boolean(globalThis.document) || options.singleProcess;\n    if (isPrimary) {\n        const emitter = new EventTarget();\n        observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));\n        observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));\n        return emitter;\n    }\n    return {\n        isWorker: true,\n        readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n        writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n    };\n};\n//# sourceMappingURL=browser.js.map","export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read';\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read';\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read';\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write';\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write';\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write';\n//# sourceMappingURL=constants.js.map","/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * ## Usage\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice('my-lock', {\n *\n *   // how long before write locks time out (default: 24 hours)\n *   timeout: 30000,\n *\n *    // control how many read operations are executed concurrently (default: Infinity)\n *   concurrency: 5,\n *\n *   // by default the the lock will be held on the main thread, set this to true if the\n *   // a lock should reside on each worker (default: false)\n *   singleProcess: false\n * })\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\nimport PQueue from 'p-queue';\nimport pTimeout from 'p-timeout';\nimport impl from './node.js';\nconst mutexes = {};\nlet implementation;\nasync function createReleaseable(queue, options) {\n    let res;\n    const p = new Promise((resolve) => {\n        res = resolve;\n    });\n    void queue.add(async () => pTimeout((async () => {\n        await new Promise((resolve) => {\n            res(() => {\n                resolve();\n            });\n        });\n    })(), {\n        milliseconds: options.timeout\n    }));\n    return p;\n}\nconst createMutex = (name, options) => {\n    if (implementation.isWorker === true) {\n        return {\n            readLock: implementation.readLock(name, options),\n            writeLock: implementation.writeLock(name, options)\n        };\n    }\n    const masterQueue = new PQueue({ concurrency: 1 });\n    let readQueue;\n    return {\n        async readLock() {\n            // If there's already a read queue, just add the task to it\n            if (readQueue != null) {\n                return createReleaseable(readQueue, options);\n            }\n            // Create a new read queue\n            readQueue = new PQueue({\n                concurrency: options.concurrency,\n                autoStart: false\n            });\n            const localReadQueue = readQueue;\n            // Add the task to the read queue\n            const readPromise = createReleaseable(readQueue, options);\n            void masterQueue.add(async () => {\n                // Start the task only once the master queue has completed processing\n                // any previous tasks\n                localReadQueue.start();\n                // Once all the tasks in the read queue have completed, remove it so\n                // that the next read lock will occur after any write locks that were\n                // started in the interim\n                await localReadQueue.onIdle()\n                    .then(() => {\n                    if (readQueue === localReadQueue) {\n                        readQueue = null;\n                    }\n                });\n            });\n            return readPromise;\n        },\n        async writeLock() {\n            // Remove the read queue reference, so that any later read locks will be\n            // added to a new queue that starts after this write lock has been\n            // released\n            readQueue = null;\n            return createReleaseable(masterQueue, options);\n        }\n    };\n};\nconst defaultOptions = {\n    name: 'lock',\n    concurrency: Infinity,\n    timeout: 84600000,\n    singleProcess: false\n};\nexport default function createMortice(options) {\n    const opts = Object.assign({}, defaultOptions, options);\n    if (implementation == null) {\n        implementation = impl(opts);\n        if (implementation.isWorker !== true) {\n            // we are master, set up worker requests\n            implementation.addEventListener('requestReadLock', (event) => {\n                if (mutexes[event.data.name] == null) {\n                    return;\n                }\n                void mutexes[event.data.name].readLock()\n                    .then(async (release) => event.data.handler().finally(() => { release(); }));\n            });\n            implementation.addEventListener('requestWriteLock', async (event) => {\n                if (mutexes[event.data.name] == null) {\n                    return;\n                }\n                void mutexes[event.data.name].writeLock()\n                    .then(async (release) => event.data.handler().finally(() => { release(); }));\n            });\n        }\n    }\n    if (mutexes[opts.name] == null) {\n        mutexes[opts.name] = createMutex(opts.name, opts);\n    }\n    return mutexes[opts.name];\n}\n//# sourceMappingURL=index.js.map","export const nanoid = (size = 21) => {\n    return Math.random().toString().substring(2);\n};\n//# sourceMappingURL=utils.js.map","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { baseX } from './base.js';\nexport const base10 = baseX({\n    prefix: '9',\n    name: 'base10',\n    alphabet: '0123456789'\n});\n//# sourceMappingURL=base10.js.map","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n    prefix: 'f',\n    name: 'base16',\n    alphabet: '0123456789abcdef',\n    bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n    prefix: 'F',\n    name: 'base16upper',\n    alphabet: '0123456789ABCDEF',\n    bitsPerChar: 4\n});\n//# sourceMappingURL=base16.js.map","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n    prefix: '0',\n    name: 'base2',\n    alphabet: '01',\n    bitsPerChar: 1\n});\n//# sourceMappingURL=base2.js.map","import { from } from './base.js';\nconst alphabet = Array.from('');\nconst alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));\nconst alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));\nfunction encode(data) {\n    return data.reduce((p, c) => {\n        p += alphabetBytesToChars[c];\n        return p;\n    }, '');\n}\nfunction decode(str) {\n    const byts = [];\n    for (const char of str) {\n        const byt = alphabetCharsToBytes[char.codePointAt(0)];\n        if (byt === undefined) {\n            throw new Error(`Non-base256emoji character: ${char}`);\n        }\n        byts.push(byt);\n    }\n    return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n    prefix: '',\n    name: 'base256emoji',\n    encode,\n    decode\n});\n//# sourceMappingURL=base256emoji.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { baseX } from './base.js';\nexport const base36 = baseX({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n    prefix: 'm',\n    name: 'base64',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n    prefix: 'M',\n    name: 'base64pad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n    prefix: 'u',\n    name: 'base64url',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n    bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n    prefix: 'U',\n    name: 'base64urlpad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n    bitsPerChar: 6\n});\n//# sourceMappingURL=base64.js.map","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n    prefix: '7',\n    name: 'base8',\n    alphabet: '01234567',\n    bitsPerChar: 3\n});\n//# sourceMappingURL=base8.js.map","import { fromString, toString } from '../bytes.js';\nimport { from } from './base.js';\nexport const identity = from({\n    prefix: '\\x00',\n    name: 'identity',\n    encode: (buf) => toString(buf),\n    decode: (str) => fromString(str)\n});\n//# sourceMappingURL=identity.js.map","// Base encoders / decoders just base encode / decode between binary and\n// textual representation. They are unaware of multibase.\nexport {};\n//# sourceMappingURL=interface.js.map","import * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base2 from './bases/base2.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base8 from './bases/base8.js';\nimport * as identityBase from './bases/identity.js';\nimport * as json from './codecs/json.js';\nimport * as raw from './codecs/raw.js';\nimport * as identity from './hashes/identity.js';\nimport * as sha2 from './hashes/sha2.js';\nimport { CID, hasher, digest, varint, bytes } from './index.js';\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji };\nexport const hashes = { ...sha2, ...identity };\nexport const codecs = { raw, json };\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=basics.js.map","export {};\n//# sourceMappingURL=interface.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","import { base32 } from './bases/base32.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? base32.encoder));\n    }\n}\nexport function toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nexport function fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nexport class CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = Digest.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            Digest.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = Digest.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = varint.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? base58btc;\n            return [\n                base58btc.prefix,\n                decoder.decode(`${base58btc.prefix}${source}`)\n            ];\n        }\n        case base58btc.prefix: {\n            const decoder = base ?? base58btc;\n            return [base58btc.prefix, decoder.decode(source)];\n        }\n        case base32.prefix: {\n            const decoder = base ?? base32;\n            return [base32.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = varint.encodingLength(version);\n    const hashOffset = codeOffset + varint.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    varint.encodeTo(version, bytes, 0);\n    varint.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map","export {};\n//# sourceMappingURL=interface.js.map","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 0x0200;\nexport function encode(node) {\n    return textEncoder.encode(JSON.stringify(node));\n}\nexport function decode(data) {\n    return JSON.parse(textDecoder.decode(data));\n}\n//# sourceMappingURL=json.js.map","import { coerce } from '../bytes.js';\nexport const name = 'raw';\nexport const code = 0x55;\nexport function encode(node) {\n    return coerce(node);\n}\nexport function decode(data) {\n    return coerce(data);\n}\n//# sourceMappingURL=raw.js.map","import { coerce, equals as equalBytes } from '../bytes.js';\nimport * as varint from '../varint.js';\n/**\n * Creates a multihash digest.\n */\nexport function create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = varint.encodingLength(code);\n    const digestOffset = sizeOffset + varint.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    varint.encodeTo(code, bytes, 0);\n    varint.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode(multihash) {\n    const bytes = coerce(multihash);\n    const [code, sizeOffset] = varint.decode(bytes);\n    const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            equalBytes(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n//# sourceMappingURL=digest.js.map","import * as Digest from './digest.js';\nexport function from({ name, code, encode }) {\n    return new Hasher(name, code, encode);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher {\n    name;\n    code;\n    encode;\n    constructor(name, code, encode) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n    }\n    digest(input) {\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            return result instanceof Uint8Array\n                ? Digest.create(this.code, result)\n                /* c8 ignore next 1 */\n                : result.then(digest => Digest.create(this.code, digest));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n//# sourceMappingURL=hasher.js.map","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0x0;\nconst name = 'identity';\nconst encode = coerce;\nfunction digest(input) {\n    return Digest.create(code, encode(input));\n}\nexport const identity = { code, name, encode, digest };\n//# sourceMappingURL=identity.js.map","// # Multihash\nexport {};\n//# sourceMappingURL=interface.js.map","/* global crypto */\nimport { from } from './hasher.js';\nfunction sha(name) {\n    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));\n}\nexport const sha256 = from({\n    name: 'sha2-256',\n    code: 0x12,\n    encode: sha('SHA-256')\n});\nexport const sha512 = from({\n    name: 'sha2-512',\n    code: 0x13,\n    encode: sha('SHA-512')\n});\n//# sourceMappingURL=sha2-browser.js.map","/**\n * @packageDocumentation\n *\n * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.\n *\n * This library provides implementations for most basics and many others can be found in linked repositories.\n *\n * ```TypeScript\n * import { CID } from 'multiformats/cid'\n * import * as json from 'multiformats/codecs/json'\n * import { sha256 } from 'multiformats/hashes/sha2'\n *\n * const bytes = json.encode({ hello: 'world' })\n *\n * const hash = await sha256.digest(bytes)\n * const cid = CID.create(1, json.code, hash)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Creating Blocks\n *\n * ```TypeScript\n * import * as Block from 'multiformats/block'\n * import * as codec from '@ipld/dag-cbor'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * const value = { hello: 'world' }\n *\n * // encode a block\n * let block = await Block.encode({ value, codec, hasher })\n *\n * block.value // { hello: 'world' }\n * block.bytes // Uint8Array\n * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec\n *\n * // you can also decode blocks from their binary state\n * block = await Block.decode({ bytes: block.bytes, codec, hasher })\n *\n * // if you have the cid you can also verify the hash on decode\n * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })\n * ```\n *\n * ## Multibase Encoders / Decoders / Codecs\n *\n * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:\n *\n * ```TypeScript\n * import { base64 } from \"multiformats/bases/base64\"\n * cid.toString(base64.encoder)\n * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'\n * ```\n *\n * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:\n *\n * ```TypeScript\n * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * Dual of multibase encoder & decoder is defined as multibase codec and it exposes\n * them as `encoder` and `decoder` properties. For added convenience codecs also\n * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be\n * used as either or both:\n *\n * ```TypeScript\n * cid.toString(base64)\n * CID.parse(cid.toString(base64), base64)\n * ```\n *\n * **Note:** CID implementation comes bundled with `base32` and `base58btc`\n * multibase codecs so that CIDs can be base serialized to (version specific)\n * default base encoding and parsed without having to supply base encoders/decoders:\n *\n * ```TypeScript\n * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')\n * v1.toString()\n * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'\n *\n * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')\n * v0.toString()\n * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\n * v0.toV1().toString()\n * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'\n * ```\n *\n * ## Multicodec Encoders / Decoders / Codecs\n *\n * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).\n * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.\n * Here is an example implementation of JSON `BlockCodec`.\n *\n * ```TypeScript\n * export const { name, code, encode, decode } = {\n *   name: 'json',\n *   code: 0x0200,\n *   encode: json => new TextEncoder().encode(JSON.stringify(json)),\n *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))\n * }\n * ```\n *\n * ## Multihash Hashers\n *\n * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:\n *\n * ```TypeScript\n * import * as hasher from 'multiformats/hashes/hasher'\n *\n * const sha256 = hasher.from({\n *   // As per multiformats table\n *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9\n *   name: 'sha2-256',\n *   code: 0x12,\n *\n *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())\n * })\n *\n * const hash = await sha256.digest(json.encode({ hello: 'world' }))\n * CID.create(1, json.code, hash)\n *\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n * ```\n *\n * ## Traversal\n *\n * This library contains higher-order functions for traversing graphs of data easily.\n *\n * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.\n *\n * ```TypeScript\n * import { walk } from 'multiformats/traversal'\n * import * as Block from 'multiformats/block'\n * import * as codec from 'multiformats/codecs/json'\n * import { sha256 as hasher } from 'multiformats/hashes/sha2'\n *\n * // build a DAG (a single block for this simple example)\n * const value = { hello: 'world' }\n * const block = await Block.encode({ value, codec, hasher })\n * const { cid } = block\n * console.log(cid)\n * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)\n *\n * // create a loader function that also collects CIDs of blocks in\n * // their traversal order\n * const load = (cid, blocks) => async (cid) => {\n *   // fetch a block using its cid\n *   // e.g.: const block = await fetchBlockByCID(cid)\n *   blocks.push(cid)\n *   return block\n * }\n *\n * // collect blocks in this DAG starting from the root `cid`\n * const blocks = []\n * await walk({ cid, load: load(cid, blocks) })\n *\n * console.log(blocks)\n * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]\n * ```\n *\n * ## Legacy interface\n *\n * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an\n * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.\n *\n * ## Implementations\n *\n * By default, no base encodings (other than base32 & base58btc), hash functions,\n * or codec implementations are exposed by `multiformats`, you need to\n * import the ones you need yourself.\n *\n * ### Multibase codecs\n *\n * | bases                                                         | import                      | repo                                                                                              |\n * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |\n * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |\n *\n * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.\n *\n * ### Multihash hashers\n *\n * | hashes                                                                                                                          | import                         | repo                                                                                                               |\n * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |\n * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |\n * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |\n * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |\n * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |\n * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |\n *\n * ### IPLD codecs (multicodec)\n *\n * | codec      | import                     | repo                                                                                                   |\n * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |\n * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |\n * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |\n * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |\n * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |\n * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |\n */\nimport * as bytes from './bytes.js';\nimport { CID } from './cid.js';\nimport * as digest from './hashes/digest.js';\nimport * as hasher from './hashes/hasher.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './interface.js';\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=index.js.map","export * from './bases/interface.js';\nexport * from './hashes/interface.js';\nexport * from './codecs/interface.js';\nexport * from './link/interface.js';\nexport * from './block/interface.js';\n//# sourceMappingURL=interface.js.map","/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */\n/* eslint-disable no-use-before-define */\nexport {};\n//# sourceMappingURL=interface.js.map","import varint from './vendor/varint.js';\nexport function decode(data, offset = 0) {\n    const code = varint.decode(data, offset);\n    return [code, varint.decode.bytes];\n}\nexport function encodeTo(int, target, offset = 0) {\n    varint.encode(int, target, offset);\n    return target;\n}\nexport function encodingLength(int) {\n    return varint.encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;\n//# sourceMappingURL=varint.js.map","const events = {};\nconst observable = (worker) => {\n    worker.addEventListener('message', (event) => {\n        observable.dispatchEvent('message', worker, event);\n    });\n    if (worker.port != null) {\n        worker.port.addEventListener('message', (event) => {\n            observable.dispatchEvent('message', worker, event);\n        });\n    }\n};\nobservable.addEventListener = (type, fn) => {\n    if (events[type] == null) {\n        events[type] = [];\n    }\n    events[type].push(fn);\n};\nobservable.removeEventListener = (type, fn) => {\n    if (events[type] == null) {\n        return;\n    }\n    events[type] = events[type]\n        .filter(listener => listener === fn);\n};\nobservable.dispatchEvent = function (type, worker, event) {\n    if (events[type] == null) {\n        return;\n    }\n    events[type].forEach(fn => fn(worker, event));\n};\nexport default observable;\n//# sourceMappingURL=index.js.map","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n","// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n","import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent extends Event {\n    type;\n    detail;\n    constructor(type, detail) {\n        super(type);\n        this.type = type;\n        // @ts-expect-error detail may be undefined\n        this.detail = detail;\n    }\n}\n//# sourceMappingURL=index.js.map","// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport var CODEC_TYPES;\n(function (CODEC_TYPES) {\n    CODEC_TYPES[CODEC_TYPES[\"VARINT\"] = 0] = \"VARINT\";\n    CODEC_TYPES[CODEC_TYPES[\"BIT64\"] = 1] = \"BIT64\";\n    CODEC_TYPES[CODEC_TYPES[\"LENGTH_DELIMITED\"] = 2] = \"LENGTH_DELIMITED\";\n    CODEC_TYPES[CODEC_TYPES[\"START_GROUP\"] = 3] = \"START_GROUP\";\n    CODEC_TYPES[CODEC_TYPES[\"END_GROUP\"] = 4] = \"END_GROUP\";\n    CODEC_TYPES[CODEC_TYPES[\"BIT32\"] = 5] = \"BIT32\";\n})(CODEC_TYPES || (CODEC_TYPES = {}));\nexport function createCodec(name, type, encode, decode) {\n    return {\n        name,\n        type,\n        encode,\n        decode\n    };\n}\n//# sourceMappingURL=codec.js.map","import { createCodec, CODEC_TYPES } from '../codec.js';\nexport function enumeration(v) {\n    function findValue(val) {\n        // Use the reverse mapping to look up the enum key for the stored value\n        // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n        if (v[val.toString()] == null) {\n            throw new Error('Invalid enum value');\n        }\n        return v[val];\n    }\n    const encode = function enumEncode(val, writer) {\n        const enumValue = findValue(val);\n        writer.int32(enumValue);\n    };\n    const decode = function enumDecode(reader) {\n        const val = reader.int32();\n        return findValue(val);\n    };\n    // @ts-expect-error yeah yeah\n    return createCodec('enum', CODEC_TYPES.VARINT, encode, decode);\n}\n//# sourceMappingURL=enum.js.map","import { createCodec, CODEC_TYPES } from '../codec.js';\nexport function message(encode, decode) {\n    return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode);\n}\n//# sourceMappingURL=message.js.map","import { createReader } from './utils/reader.js';\nexport function decodeMessage(buf, codec, opts) {\n    const reader = createReader(buf);\n    return codec.decode(reader, undefined, opts);\n}\n//# sourceMappingURL=decode.js.map","import { createWriter } from './utils/writer.js';\nexport function encodeMessage(message, codec) {\n    const w = createWriter();\n    codec.encode(message, w, {\n        lengthDelimited: false\n    });\n    return w.finish();\n}\n//# sourceMappingURL=encode.js.map","/**\n * @packageDocumentation\n *\n * This module contains serialization/deserialization code used when encoding/decoding protobufs.\n *\n * It should be declared as a dependency of your project:\n *\n * ```console\n * npm i protons-runtime\n * ```\n */\nexport { decodeMessage } from './decode.js';\nexport { encodeMessage } from './encode.js';\nexport { enumeration } from './codecs/enum.js';\nexport { message } from './codecs/message.js';\nexport { createReader as reader } from './utils/reader.js';\nexport { createWriter as writer } from './utils/writer.js';\n/**\n * This will be removed in a future release\n *\n * @deprecated\n */\nexport class CodeError extends Error {\n    code;\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\n/**\n * Thrown when a repeated field has too many elements\n */\nexport class MaxLengthError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_MAX_LENGTH';\n    name = 'MaxLengthError';\n}\n/**\n * Thrown when a map has too many elements\n */\nexport class MaxSizeError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_MAX_SIZE';\n    name = 'MaxSizeError';\n}\nexport class ParseError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_PARSE_ERROR';\n    name = 'ParseError';\n}\nexport class NoMessagesFoundError extends Error {\n    /**\n     * This will be removed in a future release\n     *\n     * @deprecated use the `.name` property instead\n     */\n    code = 'ERR_NO_MESSAGES_FOUND';\n    name = 'NoMessagesFoundError';\n}\n//# sourceMappingURL=index.js.map","const f32 = new Float32Array([-0]);\nconst f8b = new Uint8Array(f32.buffer);\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE(val, buf, pos) {\n    f32[0] = val;\n    buf[pos] = f8b[0];\n    buf[pos + 1] = f8b[1];\n    buf[pos + 2] = f8b[2];\n    buf[pos + 3] = f8b[3];\n}\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE(val, buf, pos) {\n    f32[0] = val;\n    buf[pos] = f8b[3];\n    buf[pos + 1] = f8b[2];\n    buf[pos + 2] = f8b[1];\n    buf[pos + 3] = f8b[0];\n}\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE(buf, pos) {\n    f8b[0] = buf[pos];\n    f8b[1] = buf[pos + 1];\n    f8b[2] = buf[pos + 2];\n    f8b[3] = buf[pos + 3];\n    return f32[0];\n}\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE(buf, pos) {\n    f8b[3] = buf[pos];\n    f8b[2] = buf[pos + 1];\n    f8b[1] = buf[pos + 2];\n    f8b[0] = buf[pos + 3];\n    return f32[0];\n}\nconst f64 = new Float64Array([-0]);\nconst d8b = new Uint8Array(f64.buffer);\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE(val, buf, pos) {\n    f64[0] = val;\n    buf[pos] = d8b[0];\n    buf[pos + 1] = d8b[1];\n    buf[pos + 2] = d8b[2];\n    buf[pos + 3] = d8b[3];\n    buf[pos + 4] = d8b[4];\n    buf[pos + 5] = d8b[5];\n    buf[pos + 6] = d8b[6];\n    buf[pos + 7] = d8b[7];\n}\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE(val, buf, pos) {\n    f64[0] = val;\n    buf[pos] = d8b[7];\n    buf[pos + 1] = d8b[6];\n    buf[pos + 2] = d8b[5];\n    buf[pos + 3] = d8b[4];\n    buf[pos + 4] = d8b[3];\n    buf[pos + 5] = d8b[2];\n    buf[pos + 6] = d8b[1];\n    buf[pos + 7] = d8b[0];\n}\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE(buf, pos) {\n    d8b[0] = buf[pos];\n    d8b[1] = buf[pos + 1];\n    d8b[2] = buf[pos + 2];\n    d8b[3] = buf[pos + 3];\n    d8b[4] = buf[pos + 4];\n    d8b[5] = buf[pos + 5];\n    d8b[6] = buf[pos + 6];\n    d8b[7] = buf[pos + 7];\n    return f64[0];\n}\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE(buf, pos) {\n    d8b[7] = buf[pos];\n    d8b[6] = buf[pos + 1];\n    d8b[5] = buf[pos + 2];\n    d8b[4] = buf[pos + 3];\n    d8b[3] = buf[pos + 4];\n    d8b[2] = buf[pos + 5];\n    d8b[1] = buf[pos + 6];\n    d8b[0] = buf[pos + 7];\n    return f64[0];\n}\n//# sourceMappingURL=float.js.map","// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n    lo;\n    hi;\n    constructor(lo, hi) {\n        // note that the casts below are theoretically unnecessary as of today, but older statically\n        // generated converter code might still call the ctor with signed 32bits. kept for compat.\n        /**\n         * Low bits\n         */\n        this.lo = lo | 0;\n        /**\n         * High bits\n         */\n        this.hi = hi | 0;\n    }\n    /**\n     * Converts this long bits to a possibly unsafe JavaScript number\n     */\n    toNumber(unsigned = false) {\n        if (!unsigned && (this.hi >>> 31) > 0) {\n            const lo = ~this.lo + 1 >>> 0;\n            let hi = ~this.hi >>> 0;\n            if (lo === 0) {\n                hi = hi + 1 >>> 0;\n            }\n            return -(lo + hi * 4294967296);\n        }\n        return this.lo + this.hi * 4294967296;\n    }\n    /**\n     * Converts this long bits to a bigint\n     */\n    toBigInt(unsigned = false) {\n        if (unsigned) {\n            return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);\n        }\n        if ((this.hi >>> 31) !== 0) {\n            const lo = ~this.lo + 1 >>> 0;\n            let hi = ~this.hi >>> 0;\n            if (lo === 0) {\n                hi = hi + 1 >>> 0;\n            }\n            return -(BigInt(lo) + (BigInt(hi) << 32n));\n        }\n        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);\n    }\n    /**\n     * Converts this long bits to a string\n     */\n    toString(unsigned = false) {\n        return this.toBigInt(unsigned).toString();\n    }\n    /**\n     * Zig-zag encodes this long bits\n     */\n    zzEncode() {\n        const mask = this.hi >> 31;\n        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n        this.lo = (this.lo << 1 ^ mask) >>> 0;\n        return this;\n    }\n    /**\n     * Zig-zag decodes this long bits\n     */\n    zzDecode() {\n        const mask = -(this.lo & 1);\n        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n        this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n        return this;\n    }\n    /**\n     * Calculates the length of this longbits when encoded as a varint.\n     */\n    length() {\n        const part0 = this.lo;\n        const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;\n        const part2 = this.hi >>> 24;\n        return part2 === 0\n            ? part1 === 0\n                ? part0 < 16384\n                    ? part0 < 128 ? 1 : 2\n                    : part0 < 2097152 ? 3 : 4\n                : part1 < 16384\n                    ? part1 < 128 ? 5 : 6\n                    : part1 < 2097152 ? 7 : 8\n            : part2 < 128 ? 9 : 10;\n    }\n    /**\n     * Constructs new long bits from the specified number\n     */\n    static fromBigInt(value) {\n        if (value === 0n) {\n            return zero;\n        }\n        if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n            return this.fromNumber(Number(value));\n        }\n        const negative = value < 0n;\n        if (negative) {\n            value = -value;\n        }\n        let hi = value >> 32n;\n        let lo = value - (hi << 32n);\n        if (negative) {\n            hi = ~hi | 0n;\n            lo = ~lo | 0n;\n            if (++lo > TWO_32) {\n                lo = 0n;\n                if (++hi > TWO_32) {\n                    hi = 0n;\n                }\n            }\n        }\n        return new LongBits(Number(lo), Number(hi));\n    }\n    /**\n     * Constructs new long bits from the specified number\n     */\n    static fromNumber(value) {\n        if (value === 0) {\n            return zero;\n        }\n        const sign = value < 0;\n        if (sign) {\n            value = -value;\n        }\n        let lo = value >>> 0;\n        let hi = (value - lo) / 4294967296 >>> 0;\n        if (sign) {\n            hi = ~hi >>> 0;\n            lo = ~lo >>> 0;\n            if (++lo > 4294967295) {\n                lo = 0;\n                if (++hi > 4294967295) {\n                    hi = 0;\n                }\n            }\n        }\n        return new LongBits(lo, hi);\n    }\n    /**\n     * Constructs new long bits from a number, long or string\n     */\n    static from(value) {\n        if (typeof value === 'number') {\n            return LongBits.fromNumber(value);\n        }\n        if (typeof value === 'bigint') {\n            return LongBits.fromBigInt(value);\n        }\n        if (typeof value === 'string') {\n            return LongBits.fromBigInt(BigInt(value));\n        }\n        return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    }\n}\nconst zero = new LongBits(0, 0);\nzero.toBigInt = function () { return 0n; };\nzero.zzEncode = zero.zzDecode = function () { return this; };\nzero.length = function () { return 1; };\nconst TWO_32 = 4294967296n;\n//# sourceMappingURL=longbits.js.map","import { allocUnsafe } from 'uint8arrays/alloc';\n/**\n * A general purpose buffer pool\n */\nexport default function pool(size) {\n    const SIZE = size ?? 8192;\n    const MAX = SIZE >>> 1;\n    let slab;\n    let offset = SIZE;\n    return function poolAlloc(size) {\n        if (size < 1 || size > MAX) {\n            return allocUnsafe(size);\n        }\n        if (offset + size > SIZE) {\n            slab = allocUnsafe(SIZE);\n            offset = 0;\n        }\n        const buf = slab.subarray(offset, offset += size);\n        if ((offset & 7) !== 0) {\n            // align to 32 bit\n            offset = (offset | 7) + 1;\n        }\n        return buf;\n    };\n}\n//# sourceMappingURL=pool.js.map","import { decodeUint8Array, encodingLength } from 'uint8-varint';\nimport { readFloatLE, readDoubleLE } from './float.js';\nimport { LongBits } from './longbits.js';\nimport * as utf8 from './utf8.js';\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);\n}\nfunction readFixed32End(buf, end) {\n    return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0;\n}\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader {\n    buf;\n    pos;\n    len;\n    _slice = Uint8Array.prototype.subarray;\n    constructor(buffer) {\n        /**\n         * Read buffer\n         */\n        this.buf = buffer;\n        /**\n         * Read buffer position\n         */\n        this.pos = 0;\n        /**\n         * Read buffer length\n         */\n        this.len = buffer.length;\n    }\n    /**\n     * Reads a varint as an unsigned 32 bit value\n     */\n    uint32() {\n        let value = 4294967295;\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return value;\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    }\n    /**\n     * Reads a varint as a signed 32 bit value\n     */\n    int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 32 bit value\n     */\n    sint32() {\n        const value = this.uint32();\n        return value >>> 1 ^ -(value & 1) | 0;\n    }\n    /**\n     * Reads a varint as a boolean\n     */\n    bool() {\n        return this.uint32() !== 0;\n    }\n    /**\n     * Reads fixed 32 bits as an unsigned 32 bit integer\n     */\n    fixed32() {\n        if (this.pos + 4 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const res = readFixed32End(this.buf, this.pos += 4);\n        return res;\n    }\n    /**\n     * Reads fixed 32 bits as a signed 32 bit integer\n     */\n    sfixed32() {\n        if (this.pos + 4 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const res = readFixed32End(this.buf, this.pos += 4) | 0;\n        return res;\n    }\n    /**\n     * Reads a float (32 bit) as a number\n     */\n    float() {\n        if (this.pos + 4 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const value = readFloatLE(this.buf, this.pos);\n        this.pos += 4;\n        return value;\n    }\n    /**\n     * Reads a double (64 bit float) as a number\n     */\n    double() {\n        /* istanbul ignore if */\n        if (this.pos + 8 > this.len) {\n            throw indexOutOfRange(this, 4);\n        }\n        const value = readDoubleLE(this.buf, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    /**\n     * Reads a sequence of bytes preceded by its length as a varint\n     */\n    bytes() {\n        const length = this.uint32();\n        const start = this.pos;\n        const end = this.pos + length;\n        /* istanbul ignore if */\n        if (end > this.len) {\n            throw indexOutOfRange(this, length);\n        }\n        this.pos += length;\n        return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n            ? new Uint8Array(0)\n            : this.buf.subarray(start, end);\n    }\n    /**\n     * Reads a string preceded by its byte length as a varint\n     */\n    string() {\n        const bytes = this.bytes();\n        return utf8.read(bytes, 0, bytes.length);\n    }\n    /**\n     * Skips the specified number of bytes if specified, otherwise skips a varint\n     */\n    skip(length) {\n        if (typeof length === 'number') {\n            /* istanbul ignore if */\n            if (this.pos + length > this.len) {\n                throw indexOutOfRange(this, length);\n            }\n            this.pos += length;\n        }\n        else {\n            do {\n                /* istanbul ignore if */\n                if (this.pos >= this.len) {\n                    throw indexOutOfRange(this);\n                }\n            } while ((this.buf[this.pos++] & 128) !== 0);\n        }\n        return this;\n    }\n    /**\n     * Skips the next element of the specified wire type\n     */\n    skipType(wireType) {\n        switch (wireType) {\n            case 0:\n                this.skip();\n                break;\n            case 1:\n                this.skip(8);\n                break;\n            case 2:\n                this.skip(this.uint32());\n                break;\n            case 3:\n                while ((wireType = this.uint32() & 7) !== 4) {\n                    this.skipType(wireType);\n                }\n                break;\n            case 5:\n                this.skip(4);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);\n        }\n        return this;\n    }\n    readLongVarint() {\n        // tends to deopt with local vars for octet etc.\n        const bits = new LongBits(0, 0);\n        let i = 0;\n        if (this.len - this.pos > 4) { // fast route (lo)\n            for (; i < 4; ++i) {\n                // 1st..4th\n                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n            // 5th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n            if (this.buf[this.pos++] < 128) {\n                return bits;\n            }\n            i = 0;\n        }\n        else {\n            for (; i < 3; ++i) {\n                /* istanbul ignore if */\n                if (this.pos >= this.len) {\n                    throw indexOutOfRange(this);\n                }\n                // 1st..3th\n                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n            // 4th\n            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n            return bits;\n        }\n        if (this.len - this.pos > 4) { // fast route (hi)\n            for (; i < 5; ++i) {\n                // 6th..10th\n                bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n        }\n        else {\n            for (; i < 5; ++i) {\n                if (this.pos >= this.len) {\n                    throw indexOutOfRange(this);\n                }\n                // 6th..10th\n                bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n                if (this.buf[this.pos++] < 128) {\n                    return bits;\n                }\n            }\n        }\n        throw Error('invalid varint encoding');\n    }\n    readFixed64() {\n        if (this.pos + 8 > this.len) {\n            throw indexOutOfRange(this, 8);\n        }\n        const lo = readFixed32End(this.buf, this.pos += 4);\n        const hi = readFixed32End(this.buf, this.pos += 4);\n        return new LongBits(lo, hi);\n    }\n    /**\n     * Reads a varint as a signed 64 bit value\n     */\n    int64() {\n        return this.readLongVarint().toBigInt();\n    }\n    /**\n     * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n     * JavaScript number\n     */\n    int64Number() {\n        return this.readLongVarint().toNumber();\n    }\n    /**\n     * Reads a varint as a signed 64 bit value returned as a string\n     */\n    int64String() {\n        return this.readLongVarint().toString();\n    }\n    /**\n     * Reads a varint as an unsigned 64 bit value\n     */\n    uint64() {\n        return this.readLongVarint().toBigInt(true);\n    }\n    /**\n     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n     * JavaScript number\n     */\n    uint64Number() {\n        const value = decodeUint8Array(this.buf, this.pos);\n        this.pos += encodingLength(value);\n        return value;\n    }\n    /**\n     * Reads a varint as an unsigned 64 bit value returned as a string\n     */\n    uint64String() {\n        return this.readLongVarint().toString(true);\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 64 bit value\n     */\n    sint64() {\n        return this.readLongVarint().zzDecode().toBigInt();\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n     * possibly unsafe JavaScript number\n     */\n    sint64Number() {\n        return this.readLongVarint().zzDecode().toNumber();\n    }\n    /**\n     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n     * string\n     */\n    sint64String() {\n        return this.readLongVarint().zzDecode().toString();\n    }\n    /**\n     * Reads fixed 64 bits\n     */\n    fixed64() {\n        return this.readFixed64().toBigInt();\n    }\n    /**\n     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n     */\n    fixed64Number() {\n        return this.readFixed64().toNumber();\n    }\n    /**\n     * Reads fixed 64 bits returned as a string\n     */\n    fixed64String() {\n        return this.readFixed64().toString();\n    }\n    /**\n     * Reads zig-zag encoded fixed 64 bits\n     */\n    sfixed64() {\n        return this.readFixed64().toBigInt();\n    }\n    /**\n     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n     * JavaScript number\n     */\n    sfixed64Number() {\n        return this.readFixed64().toNumber();\n    }\n    /**\n     * Reads zig-zag encoded fixed 64 bits returned as a string\n     */\n    sfixed64String() {\n        return this.readFixed64().toString();\n    }\n}\nexport function createReader(buf) {\n    return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());\n}\n//# sourceMappingURL=reader.js.map","/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length(string) {\n    let len = 0;\n    let c = 0;\n    for (let i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128) {\n            len += 1;\n        }\n        else if (c < 2048) {\n            len += 2;\n        }\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n            ++i;\n            len += 4;\n        }\n        else {\n            len += 3;\n        }\n    }\n    return len;\n}\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read(buffer, start, end) {\n    const len = end - start;\n    if (len < 1) {\n        return '';\n    }\n    let parts;\n    const chunk = [];\n    let i = 0; // char offset\n    let t; // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128) {\n            chunk[i++] = t;\n        }\n        else if (t > 191 && t < 224) {\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        }\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        }\n        else {\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        }\n        if (i > 8191) {\n            (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts != null) {\n        if (i > 0) {\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        }\n        return parts.join('');\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write(string, buffer, offset) {\n    const start = offset;\n    let c1; // character 1\n    let c2; // character 2\n    for (let i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n            buffer[offset++] = c1;\n        }\n        else if (c1 < 2048) {\n            buffer[offset++] = c1 >> 6 | 192;\n            buffer[offset++] = c1 & 63 | 128;\n        }\n        else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            ++i;\n            buffer[offset++] = c1 >> 18 | 240;\n            buffer[offset++] = c1 >> 12 & 63 | 128;\n            buffer[offset++] = c1 >> 6 & 63 | 128;\n            buffer[offset++] = c1 & 63 | 128;\n        }\n        else {\n            buffer[offset++] = c1 >> 12 | 224;\n            buffer[offset++] = c1 >> 6 & 63 | 128;\n            buffer[offset++] = c1 & 63 | 128;\n        }\n    }\n    return offset - start;\n}\n//# sourceMappingURL=utf8.js.map","import { encodeUint8Array, encodingLength } from 'uint8-varint';\nimport { allocUnsafe } from 'uint8arrays/alloc';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { writeFloatLE, writeDoubleLE } from './float.js';\nimport { LongBits } from './longbits.js';\nimport pool from './pool.js';\nimport * as utf8 from './utf8.js';\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op {\n    /**\n     * Function to call\n     */\n    fn;\n    /**\n     * Value byte length\n     */\n    len;\n    /**\n     * Next operation\n     */\n    next;\n    /**\n     * Value to write\n     */\n    val;\n    constructor(fn, len, val) {\n        this.fn = fn;\n        this.len = len;\n        this.next = undefined;\n        this.val = val; // type varies\n    }\n}\n/* istanbul ignore next */\nfunction noop() { } // eslint-disable-line no-empty-function\n/**\n * Constructs a new writer state instance\n */\nclass State {\n    /**\n     * Current head\n     */\n    head;\n    /**\n     * Current tail\n     */\n    tail;\n    /**\n     * Current buffer length\n     */\n    len;\n    /**\n     * Next state\n     */\n    next;\n    constructor(writer) {\n        this.head = writer.head;\n        this.tail = writer.tail;\n        this.len = writer.len;\n        this.next = writer.states;\n    }\n}\nconst bufferPool = pool();\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc(size) {\n    if (globalThis.Buffer != null) {\n        return allocUnsafe(size);\n    }\n    return bufferPool(size);\n}\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter {\n    /**\n     * Current length\n     */\n    len;\n    /**\n     * Operations head\n     */\n    head;\n    /**\n     * Operations tail\n     */\n    tail;\n    /**\n     * Linked forked states\n     */\n    states;\n    constructor() {\n        this.len = 0;\n        this.head = new Op(noop, 0, 0);\n        this.tail = this.head;\n        this.states = null;\n    }\n    /**\n     * Pushes a new operation to the queue\n     */\n    _push(fn, len, val) {\n        this.tail = this.tail.next = new Op(fn, len, val);\n        this.len += len;\n        return this;\n    }\n    /**\n     * Writes an unsigned 32 bit value as a varint\n     */\n    uint32(value) {\n        // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n        // uint32 is by far the most frequently used operation and benefits significantly from this.\n        this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) <\n            128\n            ? 1\n            : value < 16384\n                ? 2\n                : value < 2097152\n                    ? 3\n                    : value < 268435456\n                        ? 4\n                        : 5, value)).len;\n        return this;\n    }\n    /**\n     * Writes a signed 32 bit value as a varint`\n     */\n    int32(value) {\n        return value < 0\n            ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n            : this.uint32(value);\n    }\n    /**\n     * Writes a 32 bit value as a varint, zig-zag encoded\n     */\n    sint32(value) {\n        return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    }\n    /**\n     * Writes an unsigned 64 bit value as a varint\n     */\n    uint64(value) {\n        const bits = LongBits.fromBigInt(value);\n        return this._push(writeVarint64, bits.length(), bits);\n    }\n    /**\n     * Writes an unsigned 64 bit value as a varint\n     */\n    uint64Number(value) {\n        return this._push(encodeUint8Array, encodingLength(value), value);\n    }\n    /**\n     * Writes an unsigned 64 bit value as a varint\n     */\n    uint64String(value) {\n        return this.uint64(BigInt(value));\n    }\n    /**\n     * Writes a signed 64 bit value as a varint\n     */\n    int64(value) {\n        return this.uint64(value);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint\n     */\n    int64Number(value) {\n        return this.uint64Number(value);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint\n     */\n    int64String(value) {\n        return this.uint64String(value);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint, zig-zag encoded\n     */\n    sint64(value) {\n        const bits = LongBits.fromBigInt(value).zzEncode();\n        return this._push(writeVarint64, bits.length(), bits);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint, zig-zag encoded\n     */\n    sint64Number(value) {\n        const bits = LongBits.fromNumber(value).zzEncode();\n        return this._push(writeVarint64, bits.length(), bits);\n    }\n    /**\n     * Writes a signed 64 bit value as a varint, zig-zag encoded\n     */\n    sint64String(value) {\n        return this.sint64(BigInt(value));\n    }\n    /**\n     * Writes a boolish value as a varint\n     */\n    bool(value) {\n        return this._push(writeByte, 1, value ? 1 : 0);\n    }\n    /**\n     * Writes an unsigned 32 bit value as fixed 32 bits\n     */\n    fixed32(value) {\n        return this._push(writeFixed32, 4, value >>> 0);\n    }\n    /**\n     * Writes a signed 32 bit value as fixed 32 bits\n     */\n    sfixed32(value) {\n        return this.fixed32(value);\n    }\n    /**\n     * Writes an unsigned 64 bit value as fixed 64 bits\n     */\n    fixed64(value) {\n        const bits = LongBits.fromBigInt(value);\n        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    }\n    /**\n     * Writes an unsigned 64 bit value as fixed 64 bits\n     */\n    fixed64Number(value) {\n        const bits = LongBits.fromNumber(value);\n        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    }\n    /**\n     * Writes an unsigned 64 bit value as fixed 64 bits\n     */\n    fixed64String(value) {\n        return this.fixed64(BigInt(value));\n    }\n    /**\n     * Writes a signed 64 bit value as fixed 64 bits\n     */\n    sfixed64(value) {\n        return this.fixed64(value);\n    }\n    /**\n     * Writes a signed 64 bit value as fixed 64 bits\n     */\n    sfixed64Number(value) {\n        return this.fixed64Number(value);\n    }\n    /**\n     * Writes a signed 64 bit value as fixed 64 bits\n     */\n    sfixed64String(value) {\n        return this.fixed64String(value);\n    }\n    /**\n     * Writes a float (32 bit)\n     */\n    float(value) {\n        return this._push(writeFloatLE, 4, value);\n    }\n    /**\n     * Writes a double (64 bit float).\n     *\n     * @function\n     * @param {number} value - Value to write\n     * @returns {Writer} `this`\n     */\n    double(value) {\n        return this._push(writeDoubleLE, 8, value);\n    }\n    /**\n     * Writes a sequence of bytes\n     */\n    bytes(value) {\n        const len = value.length >>> 0;\n        if (len === 0) {\n            return this._push(writeByte, 1, 0);\n        }\n        return this.uint32(len)._push(writeBytes, len, value);\n    }\n    /**\n     * Writes a string\n     */\n    string(value) {\n        const len = utf8.length(value);\n        return len !== 0\n            ? this.uint32(len)._push(utf8.write, len, value)\n            : this._push(writeByte, 1, 0);\n    }\n    /**\n     * Forks this writer's state by pushing it to a stack.\n     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n     */\n    fork() {\n        this.states = new State(this);\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n        return this;\n    }\n    /**\n     * Resets this instance to the last state\n     */\n    reset() {\n        if (this.states != null) {\n            this.head = this.states.head;\n            this.tail = this.states.tail;\n            this.len = this.states.len;\n            this.states = this.states.next;\n        }\n        else {\n            this.head = this.tail = new Op(noop, 0, 0);\n            this.len = 0;\n        }\n        return this;\n    }\n    /**\n     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n     */\n    ldelim() {\n        const head = this.head;\n        const tail = this.tail;\n        const len = this.len;\n        this.reset().uint32(len);\n        if (len !== 0) {\n            this.tail.next = head.next; // skip noop\n            this.tail = tail;\n            this.len += len;\n        }\n        return this;\n    }\n    /**\n     * Finishes the write operation\n     */\n    finish() {\n        let head = this.head.next; // skip noop\n        const buf = alloc(this.len);\n        let pos = 0;\n        while (head != null) {\n            head.fn(head.val, buf, pos);\n            pos += head.len;\n            head = head.next;\n        }\n        // this.head = this.tail = null;\n        return buf;\n    }\n}\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op {\n    next;\n    constructor(len, val) {\n        super(writeVarint32, len, val);\n        this.next = undefined;\n    }\n}\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi !== 0) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n}\nfunction writeBytes(val, buf, pos) {\n    buf.set(val, pos);\n}\nif (globalThis.Buffer != null) {\n    Uint8ArrayWriter.prototype.bytes = function (value) {\n        const len = value.length >>> 0;\n        this.uint32(len);\n        if (len > 0) {\n            this._push(writeBytesBuffer, len, value);\n        }\n        return this;\n    };\n    Uint8ArrayWriter.prototype.string = function (value) {\n        const len = globalThis.Buffer.byteLength(value);\n        this.uint32(len);\n        if (len > 0) {\n            this._push(writeStringBuffer, len, value);\n        }\n        return this;\n    };\n}\nfunction writeBytesBuffer(val, buf, pos) {\n    buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n}\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) {\n        // plain js is faster for short strings (probably due to redundant assertions)\n        utf8.write(val, buf, pos);\n        // @ts-expect-error buf isn't a Uint8Array?\n    }\n    else if (buf.utf8Write != null) {\n        // @ts-expect-error buf isn't a Uint8Array?\n        buf.utf8Write(val, pos);\n    }\n    else {\n        buf.set(uint8ArrayFromString(val), pos);\n    }\n}\n/**\n * Creates a new writer\n */\nexport function createWriter() {\n    return new Uint8ArrayWriter();\n}\n//# sourceMappingURL=writer.js.map","/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.name = 'AbortError';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent(emitter, eventName, signal, opts) {\n    // create the error here so we have more context in the stack trace\n    const error = new AbortError(opts?.errorMessage, opts?.errorCode);\n    if (signal?.aborted === true) {\n        return Promise.reject(error);\n    }\n    return new Promise((resolve, reject) => {\n        function removeListeners() {\n            signal?.removeEventListener('abort', abortListener);\n            emitter.removeEventListener(eventName, eventListener);\n            if (opts?.errorEvent != null) {\n                emitter.removeEventListener(opts.errorEvent, errorEventListener);\n            }\n        }\n        const eventListener = (evt) => {\n            try {\n                if (opts?.filter?.(evt) === false) {\n                    return;\n                }\n            }\n            catch (err) {\n                removeListeners();\n                reject(err);\n                return;\n            }\n            removeListeners();\n            resolve(evt);\n        };\n        const errorEventListener = (evt) => {\n            removeListeners();\n            reject(evt.detail);\n        };\n        const abortListener = () => {\n            removeListeners();\n            reject(error);\n        };\n        signal?.addEventListener('abort', abortListener);\n        emitter.addEventListener(eventName, eventListener);\n        if (opts?.errorEvent != null) {\n            emitter.addEventListener(opts.errorEvent, errorEventListener);\n        }\n    });\n}\n//# sourceMappingURL=index.js.map","/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n    type;\n    code;\n    constructor(message, code, name) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.name = name ?? 'AbortError';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal(promise, signal, opts) {\n    if (signal == null) {\n        return promise;\n    }\n    if (signal.aborted) {\n        return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName));\n    }\n    let listener;\n    // create the error here so we have more context in the stack trace\n    const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName);\n    try {\n        return await Promise.race([\n            promise,\n            new Promise((resolve, reject) => {\n                listener = () => {\n                    reject(error);\n                };\n                signal.addEventListener('abort', listener);\n            })\n        ]);\n    }\n    finally {\n        if (listener != null) {\n            signal.removeEventListener('abort', listener);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc';\nconst N1 = Math.pow(2, 7);\nconst N2 = Math.pow(2, 14);\nconst N3 = Math.pow(2, 21);\nconst N4 = Math.pow(2, 28);\nconst N5 = Math.pow(2, 35);\nconst N6 = Math.pow(2, 42);\nconst N7 = Math.pow(2, 49);\n/** Most significant bit of a byte */\nconst MSB = 0x80;\n/** Rest of the bits in a byte */\nconst REST = 0x7f;\nexport function encodingLength(value) {\n    if (value < N1) {\n        return 1;\n    }\n    if (value < N2) {\n        return 2;\n    }\n    if (value < N3) {\n        return 3;\n    }\n    if (value < N4) {\n        return 4;\n    }\n    if (value < N5) {\n        return 5;\n    }\n    if (value < N6) {\n        return 6;\n    }\n    if (value < N7) {\n        return 7;\n    }\n    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n        throw new RangeError('Could not encode varint');\n    }\n    return 8;\n}\nexport function encodeUint8Array(value, buf, offset = 0) {\n    switch (encodingLength(value)) {\n        case 8: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 7: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 6: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 5: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 4: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 3: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 2: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 1: {\n            buf[offset++] = (value & 0xFF);\n            value >>>= 7;\n            break;\n        }\n        default: throw new Error('unreachable');\n    }\n    return buf;\n}\nexport function encodeUint8ArrayList(value, buf, offset = 0) {\n    switch (encodingLength(value)) {\n        case 8: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 7: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 6: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 5: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 4: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 3: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 2: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 1: {\n            buf.set(offset++, (value & 0xFF));\n            value >>>= 7;\n            break;\n        }\n        default: throw new Error('unreachable');\n    }\n    return buf;\n}\nexport function decodeUint8Array(buf, offset) {\n    let b = buf[offset];\n    let res = 0;\n    res += b & REST;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 1];\n    res += (b & REST) << 7;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 2];\n    res += (b & REST) << 14;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 3];\n    res += (b & REST) << 21;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 4];\n    res += (b & REST) * N4;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 5];\n    res += (b & REST) * N5;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 6];\n    res += (b & REST) * N6;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 7];\n    res += (b & REST) * N7;\n    if (b < MSB) {\n        return res;\n    }\n    throw new RangeError('Could not decode varint');\n}\nexport function decodeUint8ArrayList(buf, offset) {\n    let b = buf.get(offset);\n    let res = 0;\n    res += b & REST;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 1);\n    res += (b & REST) << 7;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 2);\n    res += (b & REST) << 14;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 3);\n    res += (b & REST) << 21;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 4);\n    res += (b & REST) * N4;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 5);\n    res += (b & REST) * N5;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 6);\n    res += (b & REST) * N6;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 7);\n    res += (b & REST) * N7;\n    if (b < MSB) {\n        return res;\n    }\n    throw new RangeError('Could not decode varint');\n}\nexport function encode(value, buf, offset = 0) {\n    if (buf == null) {\n        buf = allocUnsafe(encodingLength(value));\n    }\n    if (buf instanceof Uint8Array) {\n        return encodeUint8Array(value, buf, offset);\n    }\n    else {\n        return encodeUint8ArrayList(value, buf, offset);\n    }\n}\nexport function decode(buf, offset = 0) {\n    if (buf instanceof Uint8Array) {\n        return decodeUint8Array(buf, offset);\n    }\n    else {\n        return decodeUint8ArrayList(buf, offset);\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc';\nimport { concat } from 'uint8arrays/concat';\nimport { equals } from 'uint8arrays/equals';\nconst symbol = Symbol.for('@achingbrain/uint8arraylist');\nfunction findBufAndOffset(bufs, index) {\n    if (index == null || index < 0) {\n        throw new RangeError('index is out of bounds');\n    }\n    let offset = 0;\n    for (const buf of bufs) {\n        const bufEnd = offset + buf.byteLength;\n        if (index < bufEnd) {\n            return {\n                buf,\n                index: index - offset\n            };\n        }\n        offset = bufEnd;\n    }\n    throw new RangeError('index is out of bounds');\n}\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList(value) {\n    return Boolean(value?.[symbol]);\n}\nexport class Uint8ArrayList {\n    bufs;\n    length;\n    [symbol] = true;\n    constructor(...data) {\n        this.bufs = [];\n        this.length = 0;\n        if (data.length > 0) {\n            this.appendAll(data);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.bufs;\n    }\n    get byteLength() {\n        return this.length;\n    }\n    /**\n     * Add one or more `bufs` to the end of this Uint8ArrayList\n     */\n    append(...bufs) {\n        this.appendAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the end of this Uint8ArrayList\n     */\n    appendAll(bufs) {\n        let length = 0;\n        for (const buf of bufs) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.push(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.push(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Add one or more `bufs` to the start of this Uint8ArrayList\n     */\n    prepend(...bufs) {\n        this.prependAll(bufs);\n    }\n    /**\n     * Add all `bufs` to the start of this Uint8ArrayList\n     */\n    prependAll(bufs) {\n        let length = 0;\n        for (const buf of bufs.reverse()) {\n            if (buf instanceof Uint8Array) {\n                length += buf.byteLength;\n                this.bufs.unshift(buf);\n            }\n            else if (isUint8ArrayList(buf)) {\n                length += buf.byteLength;\n                this.bufs.unshift(...buf.bufs);\n            }\n            else {\n                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');\n            }\n        }\n        this.length += length;\n    }\n    /**\n     * Read the value at `index`\n     */\n    get(index) {\n        const res = findBufAndOffset(this.bufs, index);\n        return res.buf[res.index];\n    }\n    /**\n     * Set the value at `index` to `value`\n     */\n    set(index, value) {\n        const res = findBufAndOffset(this.bufs, index);\n        res.buf[res.index] = value;\n    }\n    /**\n     * Copy bytes from `buf` to the index specified by `offset`\n     */\n    write(buf, offset = 0) {\n        if (buf instanceof Uint8Array) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf[i]);\n            }\n        }\n        else if (isUint8ArrayList(buf)) {\n            for (let i = 0; i < buf.length; i++) {\n                this.set(offset + i, buf.get(i));\n            }\n        }\n        else {\n            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');\n        }\n    }\n    /**\n     * Remove bytes from the front of the pool\n     */\n    consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes);\n        // do nothing if not a positive number\n        if (Number.isNaN(bytes) || bytes <= 0) {\n            return;\n        }\n        // if consuming all bytes, skip iterating\n        if (bytes === this.byteLength) {\n            this.bufs = [];\n            this.length = 0;\n            return;\n        }\n        while (this.bufs.length > 0) {\n            if (bytes >= this.bufs[0].byteLength) {\n                bytes -= this.bufs[0].byteLength;\n                this.length -= this.bufs[0].byteLength;\n                this.bufs.shift();\n            }\n            else {\n                this.bufs[0] = this.bufs[0].subarray(bytes);\n                this.length -= bytes;\n                break;\n            }\n        }\n    }\n    /**\n     * Extracts a section of an array and returns a new array.\n     *\n     * This is a copy operation as it is with Uint8Arrays and Arrays\n     * - note this is different to the behaviour of Node Buffers.\n     */\n    slice(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a alloc from the given start and end element index.\n     *\n     * In the best case where the data extracted comes from a single Uint8Array\n     * internally this is a no-copy operation otherwise it is a copy operation.\n     */\n    subarray(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        if (bufs.length === 1) {\n            return bufs[0];\n        }\n        return concat(bufs, length);\n    }\n    /**\n     * Returns a allocList from the given start and end element index.\n     *\n     * This is a no-copy operation.\n     */\n    sublist(beginInclusive, endExclusive) {\n        const { bufs, length } = this._subList(beginInclusive, endExclusive);\n        const list = new Uint8ArrayList();\n        list.length = length;\n        // don't loop, just set the bufs\n        list.bufs = [...bufs];\n        return list;\n    }\n    _subList(beginInclusive, endExclusive) {\n        beginInclusive = beginInclusive ?? 0;\n        endExclusive = endExclusive ?? this.length;\n        if (beginInclusive < 0) {\n            beginInclusive = this.length + beginInclusive;\n        }\n        if (endExclusive < 0) {\n            endExclusive = this.length + endExclusive;\n        }\n        if (beginInclusive < 0 || endExclusive > this.length) {\n            throw new RangeError('index is out of bounds');\n        }\n        if (beginInclusive === endExclusive) {\n            return { bufs: [], length: 0 };\n        }\n        if (beginInclusive === 0 && endExclusive === this.length) {\n            return { bufs: this.bufs, length: this.length };\n        }\n        const bufs = [];\n        let offset = 0;\n        for (let i = 0; i < this.bufs.length; i++) {\n            const buf = this.bufs[i];\n            const bufStart = offset;\n            const bufEnd = bufStart + buf.byteLength;\n            // for next loop\n            offset = bufEnd;\n            if (beginInclusive >= bufEnd) {\n                // start after this buf\n                continue;\n            }\n            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;\n            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;\n            if (sliceStartInBuf && sliceEndsInBuf) {\n                // slice is wholly contained within this buffer\n                if (beginInclusive === bufStart && endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                const start = beginInclusive - bufStart;\n                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));\n                break;\n            }\n            if (sliceStartInBuf) {\n                // slice starts in this buffer\n                if (beginInclusive === 0) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    continue;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(beginInclusive - bufStart));\n                continue;\n            }\n            if (sliceEndsInBuf) {\n                if (endExclusive === bufEnd) {\n                    // requested whole buffer\n                    bufs.push(buf);\n                    break;\n                }\n                // requested part of buffer\n                bufs.push(buf.subarray(0, endExclusive - bufStart));\n                break;\n            }\n            // slice started before this buffer and ends after it\n            bufs.push(buf);\n        }\n        return { bufs, length: endExclusive - beginInclusive };\n    }\n    indexOf(search, offset = 0) {\n        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n            throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array');\n        }\n        const needle = search instanceof Uint8Array ? search : search.subarray();\n        offset = Number(offset ?? 0);\n        if (isNaN(offset)) {\n            offset = 0;\n        }\n        if (offset < 0) {\n            offset = this.length + offset;\n        }\n        if (offset < 0) {\n            offset = 0;\n        }\n        if (search.length === 0) {\n            return offset > this.length ? this.length : offset;\n        }\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n        const M = needle.byteLength;\n        if (M === 0) {\n            throw new TypeError('search must be at least 1 byte long');\n        }\n        // radix\n        const radix = 256;\n        const rightmostPositions = new Int32Array(radix);\n        // position of the rightmost occurrence of the byte c in the pattern\n        for (let c = 0; c < radix; c++) {\n            // -1 for bytes not in pattern\n            rightmostPositions[c] = -1;\n        }\n        for (let j = 0; j < M; j++) {\n            // rightmost position for bytes in pattern\n            rightmostPositions[needle[j]] = j;\n        }\n        // Return offset of first match, -1 if no match\n        const right = rightmostPositions;\n        const lastIndex = this.byteLength - needle.byteLength;\n        const lastPatIndex = needle.byteLength - 1;\n        let skip;\n        for (let i = offset; i <= lastIndex; i += skip) {\n            skip = 0;\n            for (let j = lastPatIndex; j >= 0; j--) {\n                const char = this.get(i + j);\n                if (needle[j] !== char) {\n                    skip = Math.max(1, j - right[char]);\n                    break;\n                }\n            }\n            if (skip === 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getInt8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt8(0);\n    }\n    setInt8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getInt16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt16(0, littleEndian);\n    }\n    setInt16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getInt32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getInt32(0, littleEndian);\n    }\n    setInt32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setInt32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigInt64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigInt64(0, littleEndian);\n    }\n    setBigInt64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigInt64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint8(byteOffset) {\n        const buf = this.subarray(byteOffset, byteOffset + 1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint8(0);\n    }\n    setUint8(byteOffset, value) {\n        const buf = allocUnsafe(1);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint8(0, value);\n        this.write(buf, byteOffset);\n    }\n    getUint16(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint16(0, littleEndian);\n    }\n    setUint16(byteOffset, value, littleEndian) {\n        const buf = alloc(2);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint16(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getUint32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getUint32(0, littleEndian);\n    }\n    setUint32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setUint32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getBigUint64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getBigUint64(0, littleEndian);\n    }\n    setBigUint64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setBigUint64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat32(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat32(0, littleEndian);\n    }\n    setFloat32(byteOffset, value, littleEndian) {\n        const buf = alloc(4);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat32(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    getFloat64(byteOffset, littleEndian) {\n        const buf = this.subarray(byteOffset, byteOffset + 8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        return view.getFloat64(0, littleEndian);\n    }\n    setFloat64(byteOffset, value, littleEndian) {\n        const buf = alloc(8);\n        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        view.setFloat64(0, value, littleEndian);\n        this.write(buf, byteOffset);\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof Uint8ArrayList)) {\n            return false;\n        }\n        if (other.bufs.length !== this.bufs.length) {\n            return false;\n        }\n        for (let i = 0; i < this.bufs.length; i++) {\n            if (!equals(this.bufs[i], other.bufs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n     * method if you know the total size of all the Uint8Arrays ahead of time.\n     */\n    static fromUint8Arrays(bufs, length) {\n        const list = new Uint8ArrayList();\n        list.bufs = bufs;\n        if (length == null) {\n            length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);\n        }\n        list.length = length;\n        return list;\n    }\n}\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n//# sourceMappingURL=index.js.map","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","/**\n * Can be used with Array.sort to sort and array with Uint8Array entries\n */\nexport function compare(a, b) {\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        if (a[i] > b[i]) {\n            return 1;\n        }\n    }\n    if (a.byteLength > b.byteLength) {\n        return 1;\n    }\n    if (a.byteLength < b.byteLength) {\n        return -1;\n    }\n    return 0;\n}\n//# sourceMappingURL=compare.js.map","import { allocUnsafe } from '#alloc';\nimport { asUint8Array } from '#util/as-uint8array';\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat(arrays, length) {\n    if (length == null) {\n        length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n    }\n    const output = allocUnsafe(length);\n    let offset = 0;\n    for (const arr of arrays) {\n        output.set(arr, offset);\n        offset += arr.length;\n    }\n    return asUint8Array(output);\n}\n//# sourceMappingURL=concat.js.map","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=equals.js.map","import bases, {} from './util/bases.js';\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString(string, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // add multibase prefix\n    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n//# sourceMappingURL=from-string.js.map","/**\n * @packageDocumentation\n *\n * `Uint8Array`s bring memory-efficient(ish) byte handling to browsers - they are similar to Node.js `Buffer`s but lack a lot of the utility methods present on that class.\n *\n * This module exports a number of function that let you do common operations - joining Uint8Arrays together, seeing if they have the same contents etc.\n *\n * Since Node.js `Buffer`s are also `Uint8Array`s, it falls back to `Buffer` internally where it makes sense for performance reasons.\n *\n * ## alloc(size)\n *\n * Create a new `Uint8Array`. When running under Node.js, `Buffer` will be used in preference to `Uint8Array`.\n *\n * ### Example\n *\n * ```js\n * import { alloc } from 'uint8arrays/alloc'\n *\n * const buf = alloc(100)\n * ```\n *\n * ## allocUnsafe(size)\n *\n * Create a new `Uint8Array`. When running under Node.js, `Buffer` will be used in preference to `Uint8Array`.\n *\n * On platforms that support it, memory referenced by the returned `Uint8Array` will not be initialized.\n *\n * ### Example\n *\n * ```js\n * import { allocUnsafe } from 'uint8arrays/alloc'\n *\n * const buf = allocUnsafe(100)\n * ```\n *\n * ## compare(a, b)\n *\n * Compare two `Uint8Arrays`\n *\n * ### Example\n *\n * ```js\n * import { compare } from 'uint8arrays/compare'\n *\n * const arrays = [\n *   Uint8Array.from([3, 4, 5]),\n *   Uint8Array.from([0, 1, 2])\n * ]\n *\n * const sorted = arrays.sort(compare)\n *\n * console.info(sorted)\n * // [\n * //    Uint8Array[0, 1, 2]\n * //    Uint8Array[3, 4, 5]\n * // ]\n * ```\n *\n * ## concat(arrays, \\[length])\n *\n * Concatenate one or more `Uint8Array`s and return a `Uint8Array` with their contents.\n *\n * If you know the length of the arrays, pass it as a second parameter, otherwise it will be calculated by traversing the list of arrays.\n *\n * ### Example\n *\n * ```js\n * import { concat } from 'uint8arrays/concat'\n *\n * const arrays = [\n *   Uint8Array.from([0, 1, 2]),\n *   Uint8Array.from([3, 4, 5])\n * ]\n *\n * const all = concat(arrays, 6)\n *\n * console.info(all)\n * // Uint8Array[0, 1, 2, 3, 4, 5]\n * ```\n *\n * ## equals(a, b)\n *\n * Returns true if the two arrays are the same array or if they have the same length and contents.\n *\n * ### Example\n *\n * ```js\n * import { equals } from 'uint8arrays/equals'\n *\n * const a = Uint8Array.from([0, 1, 2])\n * const b = Uint8Array.from([3, 4, 5])\n * const c = Uint8Array.from([0, 1, 2])\n *\n * console.info(equals(a, b)) // false\n * console.info(equals(a, c)) // true\n * console.info(equals(a, a)) // true\n * ```\n *\n * ## fromString(string, encoding = 'utf8')\n *\n * Returns a new `Uint8Array` created from the passed string and interpreted as the passed encoding.\n *\n * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).\n *\n * ### Example\n *\n * ```js\n * import { fromString } from 'uint8arrays/from-string'\n *\n * console.info(fromString('hello world')) // Uint8Array[104, 101 ...\n * console.info(fromString('00010203aabbcc', 'base16')) // Uint8Array[0, 1 ...\n * console.info(fromString('AAECA6q7zA', 'base64')) // Uint8Array[0, 1 ...\n * console.info(fromString('01234', 'ascii')) // Uint8Array[48, 49 ...\n * ```\n *\n * ## toString(array, encoding = 'utf8')\n *\n * Returns a string created from the passed `Uint8Array` in the passed encoding.\n *\n * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).\n *\n * ### Example\n *\n * ```js\n * import { toString } from 'uint8arrays/to-string'\n *\n * console.info(toString(Uint8Array.from([104, 101...]))) // 'hello world'\n * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base16')) // '00010203aabbcc'\n * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base64')) // 'AAECA6q7zA'\n * console.info(toString(Uint8Array.from([48, 49, 50...]), 'ascii')) // '01234'\n * ```\n *\n * ## xor(a, b)\n *\n * Returns a `Uint8Array` containing `a` and `b` xored together.\n *\n * ### Example\n *\n * ```js\n * import { xor } from 'uint8arrays/xor'\n *\n * console.info(xor(Uint8Array.from([1, 0]), Uint8Array.from([0, 1]))) // Uint8Array[1, 1]\n * ```\n *\n * ## xorCompare(a, b)\n *\n * Compares the distances between two xor `Uint8Array`s.\n *\n * ### Example\n *\n * ```ts\n * import { xor } from 'uint8arrays/xor'\n * import { xorCompare } from 'uint8arrays/xor-compare'\n *\n * const target = Uint8Array.from([1, 1])\n * const val1 = Uint8Array.from([1, 0])\n * const xor1 = xor(target, val1)\n *\n * const val2 = Uint8Array.from([0, 1])\n * const xor2 = xor(target, val2)\n *\n * console.info(xorCompare(xor1, xor2)) // -1 or 0 or 1\n * ```\n */\nimport { equals } from './equals.js';\nimport { xor } from './xor.js';\nimport { compare } from '#compare';\nimport { concat } from '#concat';\nimport { fromString } from '#from-string';\nimport { toString } from '#to-string';\nexport { compare, concat, equals, fromString, toString, xor };\n//# sourceMappingURL=index.js.map","import bases, {} from './util/bases.js';\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString(array, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n//# sourceMappingURL=to-string.js.map","/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array(buf) {\n    return buf;\n}\n//# sourceMappingURL=as-uint8array.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '#alloc';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","/**\n * Compares two Uint8Arrays representing two xor distances. Returns `-1` if `a`\n * is a lower distance, `1` if `b` is a lower distance or `0` if the distances\n * are equal.\n */\nexport function xorCompare(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        throw new Error('Inputs should have the same length');\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return a[i] < b[i] ? -1 : 1;\n    }\n    return 0;\n}\n//# sourceMappingURL=xor-compare.js.map","import { allocUnsafe } from '#alloc';\nimport { asUint8Array } from '#util/as-uint8array';\n/**\n * Returns the xor distance between two Uint8Arrays\n */\nexport function xor(a, b) {\n    if (a.length !== b.length) {\n        throw new Error('Inputs should have the same length');\n    }\n    const result = allocUnsafe(a.length);\n    for (let i = 0; i < a.length; i++) {\n        result[i] = a[i] ^ b[i];\n    }\n    return asUint8Array(result);\n}\n//# sourceMappingURL=xor.js.map","/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-env browser */\n/**\n * This is the web browser implementation of `debug()`.\n */\nimport humanize from 'ms';\nimport setup from './common.js';\nconst storage = localstorage();\n/**\n * Colors.\n */\nconst colors = [\n    '#0000CC',\n    '#0000FF',\n    '#0033CC',\n    '#0033FF',\n    '#0066CC',\n    '#0066FF',\n    '#0099CC',\n    '#0099FF',\n    '#00CC00',\n    '#00CC33',\n    '#00CC66',\n    '#00CC99',\n    '#00CCCC',\n    '#00CCFF',\n    '#3300CC',\n    '#3300FF',\n    '#3333CC',\n    '#3333FF',\n    '#3366CC',\n    '#3366FF',\n    '#3399CC',\n    '#3399FF',\n    '#33CC00',\n    '#33CC33',\n    '#33CC66',\n    '#33CC99',\n    '#33CCCC',\n    '#33CCFF',\n    '#6600CC',\n    '#6600FF',\n    '#6633CC',\n    '#6633FF',\n    '#66CC00',\n    '#66CC33',\n    '#9900CC',\n    '#9900FF',\n    '#9933CC',\n    '#9933FF',\n    '#99CC00',\n    '#99CC33',\n    '#CC0000',\n    '#CC0033',\n    '#CC0066',\n    '#CC0099',\n    '#CC00CC',\n    '#CC00FF',\n    '#CC3300',\n    '#CC3333',\n    '#CC3366',\n    '#CC3399',\n    '#CC33CC',\n    '#CC33FF',\n    '#CC6600',\n    '#CC6633',\n    '#CC9900',\n    '#CC9933',\n    '#CCCC00',\n    '#CCCC33',\n    '#FF0000',\n    '#FF0033',\n    '#FF0066',\n    '#FF0099',\n    '#FF00CC',\n    '#FF00FF',\n    '#FF3300',\n    '#FF3333',\n    '#FF3366',\n    '#FF3399',\n    '#FF33CC',\n    '#FF33FF',\n    '#FF6600',\n    '#FF6633',\n    '#FF9900',\n    '#FF9933',\n    '#FFCC00',\n    '#FFCC33'\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    // @ts-expect-error window.process.type and window.process.__nwjs are not in the types\n    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n        return true;\n    }\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/(edge|trident)\\/(\\d+)/) != null)) {\n        return false;\n    }\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    // @ts-expect-error document.documentElement.style.WebkitAppearance is not in the types\n    return (typeof document !== 'undefined' && document.documentElement?.style?.WebkitAppearance) ||\n        // Is firebug? http://stackoverflow.com/a/398120/376773\n        // @ts-expect-error window.console.firebug and window.console.exception are not in the types\n        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n        // Is firefox >= v31?\n        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n        (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/firefox\\/(\\d+)/) != null) && parseInt(RegExp.$1, 10) >= 31) ||\n        // Double check webkit in userAgent just in case we are in a worker\n        (typeof navigator !== 'undefined' && navigator.userAgent?.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n/**\n * Colorize log arguments if enabled.\n */\nfunction formatArgs(args) {\n    args[0] = (this.useColors ? '%c' : '') +\n        this.namespace +\n        (this.useColors ? ' %c' : ' ') +\n        args[0] +\n        (this.useColors ? '%c ' : ' ') +\n        '+' + humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = 'color: ' + this.color;\n    args.splice(1, 0, c, 'color: inherit');\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === '%%') {\n            return;\n        }\n        index++;\n        if (match === '%c') {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n */\nconst log = console.debug ?? console.log ?? (() => { });\n/**\n * Save `namespaces`.\n *\n * @param {string} namespaces\n */\nfunction save(namespaces) {\n    try {\n        if (namespaces) {\n            storage?.setItem('debug', namespaces);\n        }\n        else {\n            storage?.removeItem('debug');\n        }\n    }\n    catch (error) {\n        // Swallow\n        // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @returns {string} returns the previously persisted debug modes\n */\nfunction load() {\n    let r;\n    try {\n        r = storage?.getItem('debug');\n    }\n    catch (error) {\n        // Swallow\n        // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== 'undefined' && 'env' in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n */\nfunction localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    }\n    catch (error) {\n        // Swallow\n        // XXX (@Qix-) should we be logging these?\n    }\n}\nfunction setupFormatters(formatters) {\n    /**\n     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n     */\n    formatters.j = function (v) {\n        try {\n            return JSON.stringify(v);\n        }\n        catch (error) {\n            return '[UnexpectedJSONParseError]: ' + error.message;\n        }\n    };\n}\nexport default setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });\n//# sourceMappingURL=browser.js.map","/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nimport humanize from 'ms';\nexport default function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = humanize;\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach(key => {\n        // @ts-expect-error cannot use string to index type\n        createDebug[key] = env[key];\n    });\n    /**\n     * The currently active debug mode names, and names to skip.\n     */\n    createDebug.names = [];\n    createDebug.skips = [];\n    /**\n     * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n     *\n     * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n     */\n    createDebug.formatters = {};\n    /**\n     * Selects a color for a debug namespace\n     *\n     * @param {string} namespace - The namespace string for the debug instance to be colored\n     * @returns {number | string} An ANSI color code for the given namespace\n     */\n    function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n            hash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        // @ts-expect-error colors is not in the types\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n     * Create a debugger with the given `namespace`.\n     *\n     * @param {string} namespace\n     * @returns {Function}\n     */\n    function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            // @ts-expect-error enabled is not in the types\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') {\n                // Anything else let's inspect with %O\n                args.unshift('%O');\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n                // If we encounter an escaped % then don't increase the array index\n                if (match === '%%') {\n                    return '%';\n                }\n                index++;\n                // @ts-expect-error formatters is not in the types\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === 'function') {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            // @ts-expect-error formatArgs is not in the types\n            createDebug.formatArgs.call(self, args);\n            // @ts-expect-error log is not in the types\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        // @ts-expect-error useColors is not in the types\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: () => {\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                // @ts-expect-error namespaces is not in the types\n                if (namespacesCache !== createDebug.namespaces) {\n                    // @ts-expect-error namespaces is not in the types\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: v => {\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        // @ts-expect-error init is not in the types\n        if (typeof createDebug.init === 'function') {\n            // @ts-expect-error init is not in the types\n            createDebug.init(debug);\n        }\n        // @ts-expect-error some properties are added dynamically\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n     * Enables a debug mode by namespaces. This can include modes\n     * separated by a colon and wildcards.\n     *\n     * @param {string} namespaces\n     */\n    function enable(namespaces) {\n        // @ts-expect-error save is not in the types\n        createDebug.save(namespaces);\n        // @ts-expect-error namespaces is not in the types\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n            if (!split[i]) {\n                // ignore empty strings\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, '.*?');\n            if (namespaces[0] === '-') {\n                createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            }\n            else {\n                createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n        }\n    }\n    /**\n     * Disable debug output.\n     *\n     * @returns {string} namespaces\n     */\n    function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n        ].join(',');\n        createDebug.enable('');\n        return namespaces;\n    }\n    /**\n     * Returns true if the given mode name is enabled, false otherwise.\n     *\n     * @param {string} name\n     * @returns {boolean}\n     */\n    function enabled(name) {\n        if (name[name.length - 1] === '*') {\n            return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Convert regexp to namespace\n     */\n    function toNamespace(regexp) {\n        return regexp.toString()\n            .substring(2, regexp.toString().length - 2)\n            .replace(/\\.\\*\\?$/, '*');\n    }\n    /**\n     * Coerce `val`.\n     */\n    function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack ?? val.message;\n        }\n        return val;\n    }\n    /**\n     * XXX DO NOT USE. This is a temporary stub function.\n     * XXX It WILL be removed in the next major release.\n     */\n    function destroy() {\n        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n    }\n    // @ts-expect-error setupFormatters is not in the types\n    createDebug.setupFormatters(createDebug.formatters);\n    // @ts-expect-error load is not in the types\n    createDebug.enable(createDebug.load());\n    // @ts-expect-error some properties are added dynamically\n    return createDebug;\n}\n//# sourceMappingURL=common.js.map","/**\n * @packageDocumentation\n *\n * This module is a fork of the [debug](https://www.npmjs.com/package/debug) module. It has been converted to TypeScript and the output is ESM.\n *\n * It is API compatible with no extra features or bug fixes, it should only be used if you want a 100% ESM application.\n *\n * ESM should be arriving in `debug@5.x.x` so this module can be retired after that.\n *\n * Please see [debug](https://www.npmjs.com/package/debug) for API details.\n */\n/**\n * Module dependencies.\n */\nimport weald from './node.js';\nexport default weald;\n//# sourceMappingURL=index.js.map","// Helpers.\nconst s = 1000;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nconst w = d * 7;\nconst y = d * 365.25;\nfunction ms(value, options) {\n    try {\n        if (typeof value === 'string' && value.length > 0) {\n            return parse(value);\n        }\n        else if (typeof value === 'number' && isFinite(value)) {\n            return options?.long ? fmtLong(value) : fmtShort(value);\n        }\n        throw new Error('Value is not a string or number.');\n    }\n    catch (error) {\n        const message = isError(error)\n            ? `${error.message}. value=${JSON.stringify(value)}`\n            : 'An unknown error has occured.';\n        throw new Error(message);\n    }\n}\n/**\n * Parse the given `str` and return milliseconds.\n */\nfunction parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        throw new Error('Value exceeds the maximum length of 100 characters.');\n    }\n    const match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return NaN;\n    }\n    const n = parseFloat(match[1]);\n    const type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            // This should never occur.\n            throw new Error(`The unit ${type} was matched, but no matching case exists.`);\n    }\n}\nexport default ms;\n/**\n * Short format for `ms`.\n */\nfunction fmtShort(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return `${Math.round(ms / d)}d`;\n    }\n    if (msAbs >= h) {\n        return `${Math.round(ms / h)}h`;\n    }\n    if (msAbs >= m) {\n        return `${Math.round(ms / m)}m`;\n    }\n    if (msAbs >= s) {\n        return `${Math.round(ms / s)}s`;\n    }\n    return `${ms}ms`;\n}\n/**\n * Long format for `ms`.\n */\nfunction fmtLong(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, 'second');\n    }\n    return `${ms} ms`;\n}\n/**\n * Pluralization helper.\n */\nfunction plural(ms, msAbs, n, name) {\n    const isPlural = msAbs >= n * 1.5;\n    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;\n}\n/**\n * A type guard for errors.\n */\nfunction isError(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n","import detectElectron from 'is-electron'\n\nexport const isEnvWithDom = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9\nexport const isElectron = detectElectron()\n\n/**\n * Detects browser main thread  **NOT** web worker or service worker\n */\nexport const isBrowser = isEnvWithDom && !isElectron\nexport const isElectronMain = isElectron && !isEnvWithDom\nexport const isElectronRenderer = isElectron && isEnvWithDom\nexport const isNode = typeof globalThis.process !== 'undefined' && typeof globalThis.process.release !== 'undefined' && globalThis.process.release.name === 'node' && !isElectron\n// @ts-ignore\n// eslint-disable-next-line no-undef\nexport const isWebWorker = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n\n// defeat bundlers replacing process.env.NODE_ENV with \"development\" or whatever\nexport const isTest = typeof globalThis.process !== 'undefined' && typeof globalThis.process.env !== 'undefined' && globalThis.process.env['NODE' + (() => '_')() + 'ENV'] === 'test'\nexport const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/libp2pNode.js\");\n",""],"names":["_regeneratorRuntime","e","t","r","Object","prototype","n","hasOwnProperty","o","defineProperty","value","i","Symbol","a","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","type","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","length","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","_catch","delegateYield","asyncGeneratorStep","_asyncToGenerator","arguments","apply","_next","_throw","_asyncIterator","AsyncFromSyncIterator","AsyncFromSyncIteratorContinuation","reject","_return","createLibp2p","webSockets","noise","mplex","kadDHT","identify","pipe","fromString","toString","node","transports","connectionEncryption","streamMuxers","services","dht","start","console","log","addEventListener","evt","peerId","detail","setInterval","routingTable","peers","checkDHTConnection","getPeers","advertiseRoom","_ref","_callee","roomId","roomKey","closestPeers","_callee$","_context","network","concat","provide","getClosestPeers","t0","error","_x","joinRoom","_ref2","_callee2","_callee2$","_context2","setTimeout","findProviders","Array","isArray","peer","id","_x2","handleChat","_ref4","_callee4","_ref3","stream","_callee4$","_context4","source","_ref5","_callee3","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","msg","chatLog","li","_callee3$","_context3","document","getElementById","createElement","textContent","appendChild","_x4","_x3","sendMessageToPeer","_ref6","_callee5","message","_yield$node$dialProto","_callee5$","_context5","dialProtocol","sink","_x5","_x6","joinAndSendMessage","_ref7","_callee6","_callee6$","_context6","_x7","_x8","window","createRoom","sendMessage"],"sourceRoot":""}